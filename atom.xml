<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenchaoXiu</title>
  
  <subtitle>just try blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WenchaoXiu.github.io/"/>
  <updated>2020-02-25T06:14:43.151Z</updated>
  <id>http://WenchaoXiu.github.io/</id>
  
  <author>
    <name>WenchaoXiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim命令学习</title>
    <link href="http://WenchaoXiu.github.io/2020/02/25/Vim-learning/"/>
    <id>http://WenchaoXiu.github.io/2020/02/25/Vim-learning/</id>
    <published>2020-02-25T05:17:18.000Z</published>
    <updated>2020-02-25T06:14:43.151Z</updated>
    
    <content type="html"><![CDATA[<p class="description">这里记录常见的Vim命令，后续会随着使用不断增加</p><!-- <img src="https://" alt="" style="width:100%" /> --><a id="more"></a><h3 id="基本Vim命令"><a href="#基本Vim命令" class="headerlink" title="基本Vim命令"></a>基本Vim命令</h3><ol><li><p>正常模式与编辑模式切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi xxx <span class="comment"># 利用vim打开文件，此时处于正常模式下</span></span><br><span class="line">esc键 <span class="comment"># 退出编辑模式到正常模式</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x <span class="comment"># 删除光标之后的一个字符</span></span><br><span class="line">dd <span class="comment"># 删除一行</span></span><br><span class="line">u <span class="comment"># 撤销操作</span></span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yy <span class="comment"># 复制光标所在行到缓冲区，yy前可加数字，例如：6yy表示复制6行</span></span><br><span class="line">p <span class="comment"># 将yy复制好的缓冲区内容粘贴到光标所在位置</span></span><br></pre></td></tr></table></figure></li><li><p>插入文字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i <span class="comment"># 对文件进行插入编辑</span></span><br></pre></td></tr></table></figure></li><li><p>保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:q! <span class="comment"># 为文件的编辑不保存退出</span></span><br><span class="line">:wq! <span class="comment"># 对文件的编辑保存退出</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxx <span class="comment"># 查找xxx字符，使用n进行下一次查找的跳转</span></span><br></pre></td></tr></table></figure></li><li><p>替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:%s/old/new/g <span class="comment"># 对全文中的old替换为new</span></span><br><span class="line">:.,+2s/old/new/g <span class="comment"># 替换当前行与接下来两行</span></span><br><span class="line">:5,12s/old/new/g <span class="comment"># 替换5-12行里面的内容</span></span><br></pre></td></tr></table></figure></li><li><p>翻页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+f <span class="comment"># 向下翻一页</span></span><br><span class="line">Ctrl+d <span class="comment"># 向下翻半页</span></span><br><span class="line">Ctrl+b <span class="comment"># 向上翻一页</span></span><br><span class="line">Ctrl+u <span class="comment"># 向上翻半页</span></span><br></pre></td></tr></table></figure></li></ol><p><br></p><h3 id="Vim命令图谱-网上摘来的"><a href="#Vim命令图谱-网上摘来的" class="headerlink" title="Vim命令图谱(网上摘来的)"></a>Vim命令图谱(网上摘来的)</h3><div style="width: 750px; margin: auto"><img src="vim.jpg" alt="Vim命令图谱"></div><hr>]]></content>
    
    <summary type="html">
    
      Vim基本命令使用
    
    </summary>
    
      <category term="Vim" scheme="http://WenchaoXiu.github.io/categories/Vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Git命令学习</title>
    <link href="http://WenchaoXiu.github.io/2020/02/24/git-learning/"/>
    <id>http://WenchaoXiu.github.io/2020/02/24/git-learning/</id>
    <published>2020-02-24T14:55:18.000Z</published>
    <updated>2020-02-26T02:36:19.023Z</updated>
    
    <content type="html"><![CDATA[<p class="description">最近在学习Git命令，这里记录了学习过程中的一些基本命令，2020.02.24更新</p><!-- <img src="https://" alt="" style="width:100%" /> --><a id="more"></a><h2 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h2><h3 id="Git-下载"><a href="#Git-下载" class="headerlink" title="Git 下载"></a>Git 下载</h3><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">Git 下载网站</a></p><h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><ol><li><p>基本配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'xxx'</span></span><br><span class="line">git config --global user.email <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure></li><li><p>不同权限配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> <span class="comment"># 针对某仓库配置</span></span><br><span class="line">git config --add --<span class="built_in">local</span> user.name <span class="string">'xxx'</span> <span class="comment"># 增加一个新的用户名</span></span><br><span class="line">git config --global <span class="comment"># 针对当前用户所有仓库，最常用</span></span><br><span class="line">git config --system <span class="comment"># 对系统中所有用户都有效，基本不用</span></span><br></pre></td></tr></table></figure></li><li><p>当前存在用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别查看不同水平上的配置情况</span></span><br><span class="line">git config --list --<span class="built_in">local</span> <span class="comment"># 需要在具体仓库中使用</span></span><br><span class="line">git config --list --global</span><br><span class="line">git config --list --system</span><br></pre></td></tr></table></figure></li></ol><h3 id="建Git仓库"><a href="#建Git仓库" class="headerlink" title="建Git仓库"></a>建Git仓库</h3><ol><li><p>建仓库之前已有代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录</span><br><span class="line">git init <span class="comment"># 构建仓库</span></span><br></pre></td></tr></table></figure></li><li><p>建仓库之前无代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录</span><br><span class="line">git init your_project <span class="comment"># 当前目录下构建仓库</span></span><br><span class="line"><span class="built_in">cd</span> your_project <span class="comment"># 目录下只有.git文件</span></span><br></pre></td></tr></table></figure></li><li><p>使用commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; readme <span class="comment"># 当前文件夹下创建readme</span></span><br><span class="line">git status <span class="comment"># 注意当前还未别git管控，会出现"Untracked files:"提示</span></span><br><span class="line">git add readme <span class="comment"># 通过add命令实现了对文件readme的管控，及加入暂存区可以使用git status查看</span></span><br><span class="line">git add -u <span class="comment"># 将所有的都直接update</span></span><br><span class="line">git commit -m<span class="string">'Add readme'</span> <span class="comment"># 添加对本次操作的记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 可以查看对应的修改日志详情</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="git-暂存区工作区"><a href="#git-暂存区工作区" class="headerlink" title="git 暂存区工作区"></a>git 暂存区工作区</h3><ol><li><p>工作目录，暂存区，版本历史<br><div style="width: 300px; margin: auto"><img src="gitzone.png" alt="Git区域"></div></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将"工作目录"下的文件加入"暂存区"。处于暂存区的文件可以被覆盖。</span></span><br><span class="line"><span class="comment"># git add 后面可以加多个文件及文件夹，空格隔开即可</span></span><br><span class="line">git add files</span><br><span class="line">git add -u <span class="comment"># 当对本地文件进行修改更新后，重新对所有已经加入暂存区的文件进行更新</span></span><br><span class="line"><span class="comment"># 将暂存区的文件作为历史版本提交</span></span><br><span class="line">git commit -m<span class="string">'xxx'</span></span><br></pre></td></tr></table></figure></li><li><p>暂存区的意义<br> 关于暂存区，有的人可能有以下疑问，一般情况下，我有什么代码上的改动，在本地实现完了之后，直接提交不就得了，问啥多此一举把在本地也能修改操作的文件提交到暂存区上？<br> 查阅相关资料，其实涉及到原子性提交这么一个问题，简单来说，原子性提交就是一次提交修改的内容，要么全都成功，要么全都失败，好处在于，将项目还原到某个时间点的版本十分容易。<br> 那么对于命令行的git来说，为了在命令行状态下实现这一操作，即出于某个目的对文件进行多次修改，并最终将对此修改一次性提交（防止每次修改都提交，难以回到之前某个稳定的版本），发明了”暂存区”这一概念。暂存区相当于一个对修改文件打包的作用，方便用户一次性提交修改内容。</p></li></ol><h3 id="文件夹重命名"><a href="#文件夹重命名" class="headerlink" title="文件夹重命名"></a>文件夹重命名</h3><ol><li><p>麻烦的做法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv old new <span class="comment"># 在本地修改文件</span></span><br><span class="line">git add new <span class="comment"># 将新文件加入暂存区</span></span><br><span class="line">git rm old <span class="comment"># 将旧文件从暂存区删除</span></span><br><span class="line">git reset --hard <span class="comment"># ！！！这个命令是将之前存到暂存区的修改文件全部抹去的操作，不会影响git历史。小心使用！！！</span></span><br></pre></td></tr></table></figure></li><li><p>简单的做法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git mv old new <span class="comment"># 直接将暂存区中的文件进行修改</span></span><br><span class="line">git commit m<span class="string">'xxx'</span> <span class="comment"># 提交</span></span><br><span class="line">git commit -am <span class="string">'xxx'</span> <span class="comment"># 也是提交，但是是越过暂存区，直接将当前目录下的变更进行commit，一般不推荐，如果你确定修改之后的内容不存在bug，也可以使用</span></span><br><span class="line">git status <span class="comment"># 查看暂存区状态</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看commit提交历史</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="查看git提交记录"><a href="#查看git提交记录" class="headerlink" title="查看git提交记录"></a>查看git提交记录</h3><ol><li><p>单分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 简洁的查看git提交的变更历史，其中最近提交对应较靠上行，较早提交对应较靠下行</span></span><br><span class="line">git <span class="built_in">log</span> -n4 --oneline <span class="comment"># 查看最近的4条commit记录</span></span><br></pre></td></tr></table></figure></li><li><p>多分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch -av <span class="comment"># 本地有多少分支</span></span><br><span class="line">git checkout -b temp xxxx <span class="comment"># 创建并切换到新分支新分支，名为temp。其中xxxx为对应以往commit的哈希值，可以通过git log查看，除此之外，xxxx还可以是某个branch名称</span></span><br><span class="line">git checkout temp <span class="comment"># 切换到某分支</span></span><br><span class="line">git commit -am<span class="string">'xxx'</span> <span class="comment"># 将工作区的文件直接加入版本库中</span></span><br><span class="line">git <span class="built_in">log</span> --all graph <span class="comment"># 查看多个分支的版本演进情况</span></span><br><span class="line">git <span class="built_in">log</span> --oneline -n4 --graph temp <span class="comment"># 查看temp分支对应的版本演进历史</span></span><br><span class="line">git <span class="built_in">help</span> --web <span class="built_in">log</span> <span class="comment"># 查看git log详细命令情况（网页端）</span></span><br></pre></td></tr></table></figure></li><li><p>图形界面演示版本历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk --all <span class="comment"># 可以通过view new一个all ref的可视化界面，方便查看。其中头指针指向的branch为黄色（当前branch）。蓝色点代表commit对象，绿色框代表branch，黄色框是tag</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="解密-git文件"><a href="#解密-git文件" class="headerlink" title="解密.git文件"></a>解密.git文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .git 是一个文件夹里面存在相应的仓库信息</span></span><br><span class="line">git checkout master <span class="comment"># 切换分支到master上</span></span><br><span class="line">cat ./git/HEAD <span class="comment"># 查看当前的仓库分支</span></span><br><span class="line"></span><br><span class="line">cat ./git/config <span class="comment"># 查看当前的仓库配置，修改之后配置变化，例如：修改user.name之后再查看“git config --list user.name”发生改变</span></span><br><span class="line"></span><br><span class="line">ls .git/refs <span class="comment"># 里面有heads以及tags，其中heads是对应的分支信息，tags是当项目进展到一定程度的时候对应的关键标签</span></span><br><span class="line">git cat-file -t xxx <span class="comment"># heads文件中哈希值对应的文件类型</span></span><br><span class="line">git cat-file -p xxx <span class="comment"># heads文件中哈希值对应的文件内容</span></span><br><span class="line">git branch -av <span class="comment"># 分支里面的信息和heads里面文件信息对应</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .git/objects <span class="comment"># 文件夹+内部的哈希值对应了不同对象，可以使用git cat-file -t/-p查看类型及内容，主要有三种类型，tree/blob/commit</span></span><br></pre></td></tr></table></figure><h3 id="Git-对象彼此关系"><a href="#Git-对象彼此关系" class="headerlink" title="Git 对象彼此关系"></a>Git 对象彼此关系</h3><ol><li>commit是一个提交对象，里面包含tree，parent，author，commiter信息</li><li>tree是包含在commit里面的，是每次提交的时候对应的当前时刻的快照，对应了文件夹（tree类型），文件（blob）</li><li>blob是文件类型，每个blob对象跟文件名不相关，即，只要文件内容相同，blob的哈希值就是唯一的，使得存储简洁</li></ol><h3 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h3><ol><li>一句话总结：分离头指针就是变更没有基于branch做，之后的变更可能会被清除。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout xxx <span class="comment"># 其中xxx是一个commit对应的哈希值，而非相应的branch。会有"detached HEAD"的字眼，表明现在正处于分离头指针的状态，工作在一个没有分支的情况下。这种状态下，当切换到branch的时候，很可能当前状态下的commit全都失效，因为commit没有和branch挂钩。</span></span><br><span class="line"><span class="built_in">echo</span> xxx&gt;tmp.txt</span><br><span class="line">git commit -am<span class="string">'Add tmp file'</span> <span class="comment"># 当前工作目录修改后的结构进行提交</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看的commit历史的时候，第一行显示的内容里HEAD并没有指向任何branch，说明确实是基于某commit进行修改的</span></span><br><span class="line">git branch xxxname xxx <span class="comment"># 为了保留之前基于commit进行的变更，需要对其构建branch，xxx是对于commit的哈希值，xxxname是构建branch名称</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="HEAD和branch"><a href="#HEAD和branch" class="headerlink" title="HEAD和branch"></a>HEAD和branch</h3><ol><li>HEAD可以指定到branch中最新一次的commit对象，也可以指向分离头指针中的某个commit，因此，无论如何，HEAD都是指向commit对象的</li><li>HEAD可以作为当前指定的commit<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD HEAD^ <span class="comment"># 该命令表示查看最新提交以及最新一次提交之前的一次提交之间的差别。其中HEAD是专有词汇，表征当前commit，HEAD^1表征当前commit对应的父节点，进一步的，HEAD^^表征当前commit父节点的父节点。HEAD^^等同于HEAD~2</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Git-常用场景命令"><a href="#Git-常用场景命令" class="headerlink" title="Git 常用场景命令"></a>Git 常用场景命令</h2><h3 id="删除branch"><a href="#删除branch" class="headerlink" title="删除branch"></a>删除branch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -av <span class="comment"># 查看现有所有分支</span></span><br><span class="line">git branch -v <span class="comment"># 查看本地分支（不包括远端的）</span></span><br><span class="line">git branch -d/-D xxx <span class="comment"># xxx是对应分支名，其中-d会warning，-D直接执行</span></span><br></pre></td></tr></table></figure><h3 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h3><ol><li><p>最近一次提交message修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -1 <span class="comment"># 和-n1一样，查看最近的commit</span></span><br><span class="line">git commit --amend <span class="comment"># 修改最近一次的commit提交内容</span></span><br></pre></td></tr></table></figure></li><li><p>之前提交的message修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a. 进入修改界面</span></span><br><span class="line">git rebase -i xxx <span class="comment"># 交互式的修改，xxx为想要修改的message对应的commit的父节点的哈希值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b. 在修改界面指定修改策略</span></span><br><span class="line"><span class="comment"># 修改策略在界面里会提示，一般来说，pick是直接挑出，对于想要修改的地方，将pick改为r或者reword，使用:wq!保存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c. 修改message内容</span></span><br><span class="line"><span class="comment"># 修改内容，:wq!保存即可</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：rebase是在本地进行修改时的操作，如果对group项目上进行变基则不可以这样使用</p><h3 id="commit合并"><a href="#commit合并" class="headerlink" title="commit合并"></a>commit合并</h3><p>基本假设：之前做过的commit变更，后续发现其实是为一个功能服务的，因此想要将之前多个commit进行合并</p><ol><li>对于连续的commit合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a. 进入修改界面</span></span><br><span class="line">git rebase -i xxx <span class="comment"># xxx为所有想合并的commit对应的第一个公共父节点的哈希值。</span></span><br><span class="line"><span class="comment"># b.写入修改策略</span></span><br><span class="line"><span class="comment"># 在想要合并的commit之前，写入squash或者s（除第一个外）</span></span><br><span class="line"><span class="comment"># c.写入合并理由</span></span><br><span class="line"><span class="comment"># 在第一行注释下面写入合并理由</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：这里可能有个问题，如果合并的commit从第一个开始咋办？第一个commit没有父节点啊？注意，这时就需要在rebase的交互界面中加入一个pick 后面跟相应的第一个commit的哈希值，即可。</p><ol start="2"><li>对于不连续commit合并<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a. 进入修改界面</span></span><br><span class="line">git rebase -i xxx </span><br><span class="line"><span class="comment"># b.写入修改策略</span></span><br><span class="line"><span class="comment"># 区别在于在rebase交互文件中，修改策略的时候将不连续的commit放在一起，并使用squash命令进行合并即可</span></span><br><span class="line"><span class="comment"># c.写入合并理由</span></span><br><span class="line">git rebase --<span class="built_in">continue</span> <span class="comment"># 在此命令下弹出的文件中写下修改信息</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="比较工作区-暂存区-commit之间内容差别"><a href="#比较工作区-暂存区-commit之间内容差别" class="headerlink" title="比较工作区/暂存区/commit之间内容差别"></a>比较工作区/暂存区/commit之间内容差别</h3><ol><li><p>比较commit之间内容差别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD HEAD^ <span class="comment"># 最近一次提交与其之前父节点之间差别。HEAD^^表征当前commit父节点的父节点。HEAD^^等同于HEAD~2。</span></span><br><span class="line">git diff temp master <span class="comment"># 查看temp和master两个分支之间的差别，其实对应于各自的分支最新的commit。所以使用对应commit的哈希值也是可以的</span></span><br><span class="line">git diff temp master -- xxx <span class="comment"># 查看两个分支之间xxx文件的差异。temp和master分支顺序先后是有影响的，master在后表明，增加和减少都是对于master来说的</span></span><br></pre></td></tr></table></figure></li><li><p>比较暂存区以及HEAD内容<br>目的：比较暂存区和最近commit的内容，方便确认修改内容，正确提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached <span class="comment"># 查看暂存区和HEAD之间的差异</span></span><br></pre></td></tr></table></figure></li><li><p>比较工作区与暂存区内容差别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment"># 直接就可以比较，但是是对所有文件进行比较的</span></span><br><span class="line">git diff -- xxx1 xxx2 <span class="comment"># 只比较某一个文件，xxx1、xxx2为文件名，--和文件名之间有空格，可比较一个文件，也可比较多个文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="将暂存区内容恢复"><a href="#将暂存区内容恢复" class="headerlink" title="将暂存区内容恢复"></a>将暂存区内容恢复</h3><p>目的：目前工作区内容可能优于暂存区内容，因此想将暂存区内容扔掉，恢复到之前commit的状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD <span class="comment"># 取消所有暂存区的内容，会提示"Unstageed change "</span></span><br><span class="line">git reset HEAD -- xxx <span class="comment"># 部分文件恢复，xxx为想恢复成commit的文件，可以为多个文件</span></span><br></pre></td></tr></table></figure></p><h3 id="消除最近几次提交"><a href="#消除最近几次提交" class="headerlink" title="消除最近几次提交"></a>消除最近几次提交</h3><p>目的：工作区暂存区都退回之前的commit操作。比如说我在本地删除了一个文件，但是我想要恢复回来，commit里面是有相应的记录的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从工作区暂存区删除xxx文件，方法1</span></span><br><span class="line">git rm -f xxx <span class="comment"># 删除暂存区以及工作区对应的xxx文件，注意此时还没更新commit</span></span><br><span class="line"><span class="comment"># 从工作区暂存区删除xxx文件，方法2</span></span><br><span class="line">rm -rf xxx <span class="comment"># 本地工作目录删除xxx</span></span><br><span class="line">git rm xxx <span class="comment"># 暂存区删除xxx文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复到删除xxx文件</span></span><br><span class="line">git reset --hard xxx <span class="comment"># 慎用，xxx为想退回的commit对应的哈希值。当前应为HEAD，即commit最近一次提交对应的哈希值，哈希值通过git log查看</span></span><br></pre></td></tr></table></figure></p><h3 id="当前任务中加塞"><a href="#当前任务中加塞" class="headerlink" title="当前任务中加塞"></a>当前任务中加塞</h3><p>场景：当前正在某分支上进行项目的推进，但是突然测试那边说出了bug需要紧急修复，因此需要先把手头上的工作放下存起来，修复bug之后，在回归到原来工作上。相当于不破坏暂存区<br><a href="https://blog.csdn.net/misakaqunianxiatian/article/details/51103734" target="_blank" rel="noopener">常用场景</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 当前进度存起来（保存暂存的和没有暂存的或没有记录的），此时使用git status时会发现当前暂存区是干净的了，可以完成紧急任务了，git diff看工作目录暂存区区别。</span></span><br><span class="line">git stash list <span class="comment"># 可以查看相应存储堆栈</span></span><br><span class="line"></span><br><span class="line">git stash apply/pop <span class="comment"># 完成紧急任务之后，需要回到之前相应的任务继续操作。注意apply在弹出之后，stash的list中不会删除，可以反复弹出。</span></span><br></pre></td></tr></table></figure></p><h3 id="指定不需要Git管控的文件"><a href="#指定不需要Git管控的文件" class="headerlink" title="指定不需要Git管控的文件"></a>指定不需要Git管控的文件</h3><ol><li>在项目所在目录下加入一个.gitignore文件，在里面加入<em>.jar，则说明对于所有的jar后缀文件或者文件夹，git全都不管控（不管控的意思是，如果该类型文件变更了，git status不会warning）。这里需要注意，</em>.jar/和*.jar有区别，前者表明只对该后缀文件夹不管控，jar后缀文件依然管控，后者表明无论该后缀文件夹还是文件都不管控。可以用git status查看。</li><li>注意对于不同框架和语言的.gitignore在github上是有相应的参看文件的。<a href="https://github.com/github/gitignore/" target="_blank" rel="noopener">地址</a></li></ol><h3 id="Git-备份"><a href="#Git-备份" class="headerlink" title="Git 备份"></a>Git 备份</h3><p>说明：主要有本地协议，http/https协议（需要用户名密码），ssh协议（需要公司密钥）</p><ol><li>本地备份<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir back-up <span class="comment"># 建一个备份点</span></span><br><span class="line"><span class="built_in">cd</span> back-up</span><br><span class="line">git <span class="built_in">clone</span> --bare xxxpath/.git ya.git <span class="comment"># bare是不带工作区的裸仓库，该克隆协议为哑协议，慢，不带进度条</span></span><br><span class="line">git <span class="built_in">clone</span> --bare file://xxxpath/.git ya.git <span class="comment"># 智能协议，有进度条，快</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步备份</span></span><br><span class="line">git remote -v <span class="comment"># 查看备份信息，remote相当于桥梁</span></span><br><span class="line">git remote add zhineng file://path/zhineng.git <span class="comment"># 创建远端备份</span></span><br><span class="line">git push --<span class="built_in">set</span>-upstream zhineng <span class="comment"># 在当前工作目录上变更的信息，同步到远端备份</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> <span class="comment"># 注意git clone相当于建立一个origin的remote，同时不必init</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="配置公司钥"><a href="#配置公司钥" class="headerlink" title="配置公司钥"></a>配置公司钥</h3><p>目的：方便本地仓库传到github托管平台的repo上面去(需要在github上先建一个repo)<br>前提是去Github上进行注册<br>创建github钥的<a href="https://gist.github.com/yisibl/8019693" target="_blank" rel="noopener">地址1</a> <a href="https://blog.csdn.net/plei_yue/article/details/78959525" target="_blank" rel="noopener">地址2</a></p><h3 id="本地仓库同步到github"><a href="#本地仓库同步到github" class="headerlink" title="本地仓库同步到github"></a>本地仓库同步到github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:WenchaoXiu/git_learning.git <span class="comment"># 新增一个远端站点，使用github代替远端站点git@github.com:WenchaoXiu/git_learning.git的地址</span></span><br><span class="line">git remote -v <span class="comment"># 查看站点地址情况</span></span><br><span class="line">git push github --all <span class="comment"># 将本地仓库中的内容全都同步到远端仓库，github代指之前的路径。可能远端已经有文件了，会报错，需要像将远端的文件fetch下来，再进行push。</span></span><br><span class="line">git fetch github master <span class="comment"># 将远端报错的master拉下来</span></span><br><span class="line">git checkout master <span class="comment"># 切换到有问题分支</span></span><br><span class="line">git merge --allow-unrelated-histories github/master <span class="comment"># 当前分支和远端master进行merge，当然是用rebase也可以，rebase是线性结构，是fast forward结构</span></span><br><span class="line">git push github master <span class="comment"># 将合并之后的分支传上去</span></span><br><span class="line">git pull github master <span class="comment"># 也可以拉下来，与fetch区别在于，pull=fetch+merge，不如手动merge安全</span></span><br></pre></td></tr></table></figure><h3 id="相同分支不同人修改不同文件-修改相同文件不同部分"><a href="#相同分支不同人修改不同文件-修改相同文件不同部分" class="headerlink" title="相同分支不同人修改不同文件/修改相同文件不同部分"></a>相同分支不同人修改不同文件/修改相同文件不同部分</h3><ol><li><p>准备一个账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxx name02 <span class="comment"># 将xxx地址的git下载下来，并重新命名为name02文件夹</span></span><br><span class="line">git config --add --<span class="built_in">local</span> user.name <span class="string">'xxx'</span> <span class="comment"># 将项目下的名称修改为自己的</span></span><br><span class="line">git config --add --<span class="built_in">local</span> user.email <span class="string">'xxx'</span> <span class="comment"># 将项目下的邮箱修改为自己的</span></span><br><span class="line">git config --<span class="built_in">local</span> -l <span class="comment"># 查看配置信息</span></span><br><span class="line">git checkout -b xxxx/xxx original/xxx/xxx <span class="comment"># 基于远端分支构建本地的分支，并切换过去</span></span><br><span class="line">git push 本地分支:远端分支 <span class="comment"># 将本地修改之后的分支传上去</span></span><br></pre></td></tr></table></figure></li><li><p>两人修改不同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push github/origin <span class="comment"># 失败</span></span><br><span class="line">git fetch github <span class="comment"># 远端下载</span></span><br><span class="line">git branch -av <span class="comment"># 查看变化</span></span><br><span class="line">git merge github/xxx/xxx <span class="comment"># 合并远端与当前修改，或用rebase</span></span><br><span class="line">git push github <span class="comment"># 因为merge之后是fast forward，所以commit顺利</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="修改相同文件的差不多相同位置"><a href="#修改相同文件的差不多相同位置" class="headerlink" title="修改相同文件的差不多相同位置"></a>修改相同文件的差不多相同位置</h3><p>场景：两个人修改同一文件同一位置，一个人提交，另一个人提交报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 拉下来远端的</span></span><br><span class="line">git merge xxx <span class="comment"># 发现没报错</span></span><br><span class="line">vi xxxfile <span class="comment"># 修改冲突文件，会有&gt;&gt;&gt;&gt;&gt;符号，手动修改之后，再add commit push即可</span></span><br></pre></td></tr></table></figure></p><h3 id="两人一个修改文件名，一个基于原文件名进行内容修改"><a href="#两人一个修改文件名，一个基于原文件名进行内容修改" class="headerlink" title="两人一个修改文件名，一个基于原文件名进行内容修改"></a>两人一个修改文件名，一个基于原文件名进行内容修改</h3><ol><li><p>一人修改文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv xxx xxx01 <span class="comment"># 变更文件名</span></span><br><span class="line">git commit -am<span class="string">'mv file name'</span> <span class="comment"># 提交</span></span><br><span class="line">git push github <span class="comment"># 远端更新</span></span><br></pre></td></tr></table></figure></li><li><p>一人修改内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi xxx <span class="comment"># 修改文件</span></span><br><span class="line">git commit -am<span class="string">'change content'</span> <span class="comment"># 变更内容</span></span><br><span class="line">git push <span class="comment"># 失败</span></span><br><span class="line">git pull github <span class="comment"># 拉下来，直接就可以识别</span></span><br><span class="line">git push <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="两人都修改文件名"><a href="#两人都修改文件名" class="headerlink" title="两人都修改文件名"></a>两人都修改文件名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment"># 报错</span></span><br><span class="line">git pull <span class="comment"># 提示信息两个名</span></span><br><span class="line">git rm name <span class="comment"># 删除源文件</span></span><br><span class="line">git add name1 <span class="comment"># 加入某人修改</span></span><br><span class="line">git rm name2 <span class="comment"># 删除另一人修改</span></span><br><span class="line">git commit -am<span class="string">'keep one name'</span> <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure><h3 id="两台机器上的提交冲突"><a href="#两台机器上的提交冲突" class="headerlink" title="两台机器上的提交冲突"></a>两台机器上的提交冲突</h3><p>场景：回到学校，同事说项目某部分有bug，本地修改提交了。回公司之后忘了下最新的代码，直接在原来电脑的基础上修改，进行push的时候报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 暂存起来电脑上已经修改的内容</span></span><br><span class="line">git fetch xxx <span class="comment"># 远端内容下载到本地</span></span><br><span class="line">git branch -av <span class="comment"># 查看有冲突的branch</span></span><br><span class="line">git merge xxx <span class="comment"># 将本地即远端有冲突的内容进行合并，此时远端与本地一致</span></span><br><span class="line">git stash pop <span class="comment"># 弹出之前在公司电脑上修改的代码，会合并上一步与远端一致的代码以及在公司电脑上修改的代码。注意可能会有冲突。</span></span><br><span class="line">git status <span class="comment"># 查看是否两者有冲突，如果有，手动改</span></span><br><span class="line">git add/commmit <span class="comment"># 进行add/commit</span></span><br><span class="line">git push <span class="comment"># 同步到远端</span></span><br></pre></td></tr></table></figure></p><h3 id="GitHub项目搜索"><a href="#GitHub项目搜索" class="headerlink" title="GitHub项目搜索"></a>GitHub项目搜索</h3><ol><li>在搜索框输入自己想要的内容，之后加入”in:readme”，会在readme中进行搜索，效率更高</li><li>对于star数进行限制，”starts:&gt;1000”，即star数大于1000的项目</li><li>‘after_script:’+’stage: deploy’ filename:.gitlab-ci.yml # 搜索.gitlab-ci.yml文件，且文件中包含after_script:以及stage: deploy内容</li><li>code和repo搜索不能同时进行</li></ol><!-- 参考资料：苏玲-玩转Git三剑客 1-45集--><hr>]]></content>
    
    <summary type="html">
    
      Git基本命令使用
    
    </summary>
    
      <category term="Git" scheme="http://WenchaoXiu.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode代码记录</title>
    <link href="http://WenchaoXiu.github.io/2019/06/02/Leetcode/"/>
    <id>http://WenchaoXiu.github.io/2019/06/02/Leetcode/</id>
    <published>2019-06-02T03:17:06.000Z</published>
    <updated>2020-02-25T02:57:54.504Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>解题思路：</strong><br>对于target来说，从array的右上角进行搜索如果target比当前的数大则行加1列不变，向下搜索；如果target比当前的数小则列减1行不变，向左搜索。如果最后行列超出限制，则返回false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row,col = <span class="number">0</span>,len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;=len(array)<span class="number">-1</span> <span class="keyword">and</span> col&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[row][col]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> target&gt;array[row][col]:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>可能有其他解法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%20'</span>.join(s.split(<span class="string">' '</span>))</span><br></pre></td></tr></table></figure><h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p><strong>解题思路</strong><br>使用递归，首先给出终止条件，如果链表为空返回[]，之后只需要return 当前链表的next+[当前的value]即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> listNode <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.printListFromTailToHead(listNode.next)+[listNode.val]</span><br></pre></td></tr></table></figure><h2 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>解题思路：</strong><br>使用递归进行重构，首先给出终止条件，如果当前list是空返回none，如果长度只有1，返回当前值为根节点的tree，除了上面两个情况，首先构建root，是前序遍历的第一个值，之后根据index函数求解对应中序遍历list总改值节点的位置，之后使用递归，将前序遍历list和中序遍历list分别拆分作为左右节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            idx = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:(idx+<span class="number">1</span>)], tin[:idx])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[(idx+<span class="number">1</span>):], tin[(idx+<span class="number">1</span>):])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><p><strong>解题思路：</strong><br>构建两个两个list，push的话就不断压栈即可，pop的话如果list2有元素则弹出，否者将list1中的值全部弹出并压入list2中最后弹出一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''使用两个栈，list的append和pop本身就是栈,记得初始化两个list</span></span><br><span class="line"><span class="string">    如果有新值需要插入的话直接插入stack1中，如果有值要弹出的话，如果stack2中还有值，直接弹，否则</span></span><br><span class="line"><span class="string">    把stack1中的值弹出到stack2中再弹出'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure><h2 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>解题思路：</strong><br>根据题目的思路，其实只要遍历数组找到对应的相邻的两个值是倒序的即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rotateArray)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i]&gt;rotateArray[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p><strong>解题思路：</strong><br>fib数列主要使用递归表达式实现，只需要存储前后两个数字就可以进行更新，f(n) = f(n-1)+f(n-2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        before, after = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">            before,after = after, before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>解题思路：</strong><br>依然使用递归思路，假设f(n)为当前台阶的跳法，因为只有两种跳跃方式，所以之前的一次跳跃方式只可能跳了1次或者跳了2次，如果跳了1次，那么其实和f(n-1)一样，如果跳了2次，那么其实和f(n-2)一样，所以可以通过递推公式f(n) = f(n-1)+f(n-2)进行更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        before = <span class="number">1</span></span><br><span class="line">        after = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            before,after = after,before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>解题思路:</strong><br>其实跟上一题类似，只不过推广一下，相当于对之前所有的可能性求和，作为当前台阶的跳法，即f(n) = f(n-1)+f(n-2)…f(1),f(1)为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        alist = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            alist.append(sum(alist)+<span class="number">1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h2><p>我们可以用2 <em> 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p><strong>解题思路：</strong><br>仍然使用上题的思路，因为当前的砖只能横着放，或者竖着放，因此上一次是竖着放的时候f(n)方法和f(n-1)方法相同，上一次是横着放的时候f(n)方法和f(n-2)方法相同，所以的得到递归式 f(n) = f(n-1) + f(n-2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        before,after = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            before,after = after, before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h2><h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p><p><strong>解题思路：</strong><br>对于exponent为0/1/-1单独计算，之后判断正负设定flag，然后判断exponent%2是否为1，如果为1转化为base <em> [(base </em> base) <strong> (exponent/2)]，否则为(base * base) </strong> (exponent/2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> exponent==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line">        <span class="keyword">elif</span> exponent==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/base</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            isneg = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">                isneg = <span class="keyword">True</span></span><br><span class="line">            exponent = abs(exponent)</span><br><span class="line">            <span class="keyword">if</span> exponent%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                ret = self.Power(base*base,exponent/<span class="number">2</span>)*base</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = self.Power(base*base,exponent/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ret <span class="keyword">if</span> isneg <span class="keyword">else</span> ret</span><br></pre></td></tr></table></figure><h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><strong>解题思路</strong><br>使用list自带的insert以及pop，pop弹出对应的index的值，insert插入的位置可能比遍历数组的指针要慢（使用两个指针，一个指针遍历数组，一个指针用来标定奇数的位置）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 利用pop和insert</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(array):</span><br><span class="line">            <span class="keyword">if</span> v%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">                array.insert(idx,array.pop(k))</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="14-反转链表"><a href="#14-反转链表" class="headerlink" title="14. 反转链表"></a>14. 反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><p><strong>解题思路：</strong><br>使用头插法，设置新链表，同时对于旧链表的next值改为新链表的next，并将新链表的next赋值为旧链表，注意需要更新旧链表，在最上层更新防止覆盖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        ret = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            nextval = pHead.next</span><br><span class="line">            pHead.next = ret.next</span><br><span class="line">            ret.next = pHead</span><br><span class="line">            pHead = nextval</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="15-合并两个排序的链表"><a href="#15-合并两个排序的链表" class="headerlink" title="15. 合并两个排序的链表"></a>15. 合并两个排序的链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p><strong>解题思路：</strong><br>设置新链表，如果满足两个旧链表都不为空，则比较大小，并将小值赋给next，同时next更新，跳出循环之后，如果其中一个还不为空就直接加在新链表的next上即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val&gt;=pHead2.val:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">if</span> pHead1:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="16-数组中出现次数超过一半的数字"><a href="#16-数组中出现次数超过一半的数字" class="headerlink" title="16. 数组中出现次数超过一半的数字"></a>16. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p><strong>解题思路：</strong><br>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p><p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        val = numbers[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i==val:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt==<span class="number">0</span>:</span><br><span class="line">                val = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i==val:</span><br><span class="line">                ret += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> val <span class="keyword">if</span> ret&gt;(len(numbers)/<span class="number">2</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="17-最小的K个数"><a href="#17-最小的K个数" class="headerlink" title="17. 最小的K个数"></a>17. 最小的K个数</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><p><strong>解题思路：</strong><br>使用快排，把比当前数字小的数字作为left list，比当前数字大的数字作为right list，递归排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(x)&lt;=<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = []</span><br><span class="line">                right = []</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> x[<span class="number">1</span>:]:</span><br><span class="line">                    <span class="keyword">if</span> i&lt;=x[<span class="number">0</span>]:</span><br><span class="line">                        left.append(i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right.append(i)</span><br><span class="line">                <span class="keyword">return</span> quickSort(left) + [x[<span class="number">0</span>]] + quickSort(right)</span><br><span class="line">        <span class="keyword">if</span> k&gt;len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> quickSort(tinput)[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr)</span>:</span></span><br><span class="line">    m = arr[<span class="number">0</span>]</span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=m]</span><br><span class="line">    h = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;m]</span><br><span class="line">    <span class="keyword">return</span> l,m,h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(arr, k)</span>:</span></span><br><span class="line">    l,m,h = partition(arr)</span><br><span class="line">    <span class="keyword">if</span> len(l)==k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">elif</span> len(l)&lt;k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> select(h, k-len(l)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(l, k)</span><br><span class="line">select([<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="18-连续子数组的最大和"><a href="#18-连续子数组的最大和" class="headerlink" title="18. 连续子数组的最大和"></a>18. 连续子数组的最大和</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><p><strong>解题思路：</strong><br>如果list不存在返回0，长度为1返回第一个元素，否则对list进行遍历，分别设置两个变量，一个变量记录以当前元素结尾时最大和，一个记录整体最大值，使用tmpmax=max(tmpmax+i, i),maxval=max(maxval,tmpmax)，最后返回maxval即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = max(a[n], f(n-1)+a[n])</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line">        alist = [array[<span class="number">0</span>],]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">            tmp = max(array[i], alist[<span class="number">-1</span>]+array[i])</span><br><span class="line">            alist.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> max(alist)</span><br></pre></td></tr></table></figure><h2 id="19-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#19-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="19. 整数中1出现的次数（从1到n整数中1出现的次数）"></a>19. 整数中1出现的次数（从1到n整数中1出现的次数）</h2><p>求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数？为此他特别数了一下1 ~ 13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p><strong>解题思路：</strong><br>对每个位置为1的个数进行加和，对每个位置上来说主要考虑三种情况，为0，为1，大于1，详细请看这个blog<a href="https://blog.csdn.net/weixin_40533355/article/details/83861895" target="_blank" rel="noopener">思路</a><br>设置三个变量，cnt记录1个数，base记录当前指数位数，raw记录原始数字，<br>对于n不为0，n=n/10,single=n%10，之后对single进行判断，如果single为0则cnt+=n <em> (10 ** base)<br>如果为1，cnt+=n </em> (10 <strong> base)+raw%(10 </strong> base)+1<br>如果为其他，cnt+=(n+1) * (10 ** base)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        base = <span class="number">0</span></span><br><span class="line">        raw = n</span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">0</span>:</span><br><span class="line">            single = n%<span class="number">10</span></span><br><span class="line">            n = n/<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> single==<span class="number">0</span>:</span><br><span class="line">                cnt += n*(<span class="number">10</span>**base) <span class="comment"># 0的时候只有上面的数字会影响</span></span><br><span class="line">            <span class="keyword">elif</span> single==<span class="number">1</span>:</span><br><span class="line">                cnt += n*(<span class="number">10</span>**base) + raw%(<span class="number">10</span>**base) + <span class="number">1</span> <span class="comment"># 1的时候上下都影响</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += (n+<span class="number">1</span>)*(<span class="number">10</span>**base) <span class="comment"># &gt;1时上面影响+所有下面的</span></span><br><span class="line">            base += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h2 id="20-把数组排成最小的数"><a href="#20-把数组排成最小的数" class="headerlink" title="20. 把数组排成最小的数"></a>20. 把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p><strong>解题思路：</strong><br>注意这里活用sorted的cmp比较器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = map(str, numbers)</span><br><span class="line">        ret = sorted(alist, cmp=<span class="keyword">lambda</span> x,y: cmp(x+y,y+x)) <span class="comment"># 如果x+y小输出x后y</span></span><br><span class="line">        <span class="comment"># ret = sorted(alist, cmp=lambda x,y: cmp(y+x,x+y)) # 如果x+y小输出y后x</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ret)</span><br></pre></td></tr></table></figure><h2 id="21-第一个只出现一次的字符"><a href="#21-第一个只出现一次的字符" class="headerlink" title="21. 第一个只出现一次的字符"></a>21. 第一个只出现一次的字符</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><p><strong>解题思路：</strong><br>利用字典，没啥说的，基本操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = []</span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                adic[v] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[v] = <span class="number">1</span></span><br><span class="line">                alist.append((k,v)) <span class="comment"># 活用元组保存位置</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> alist:</span><br><span class="line">            <span class="keyword">if</span> adic[v]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="22-数组中只出现一次的数字"><a href="#22-数组中只出现一次的数字" class="headerlink" title="22. 数组中只出现一次的数字"></a>22. 数组中只出现一次的数字</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p><strong>解题思路：</strong><br>使用字典，使用list，如果在就remove，最后剩下的就返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">            <span class="keyword">if</span> adic[i]==<span class="number">1</span>:</span><br><span class="line">                alist.append(i)</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure><h2 id="23-和为S的连续正数序列"><a href="#23-和为S的连续正数序列" class="headerlink" title="23. 和为S的连续正数序列"></a>23. 和为S的连续正数序列</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9 ~ 16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p><strong>解题思路：</strong><br>使用滑窗法，设定一个list存结果，start为1，end为2，计算start-end之间的和，如果start &lt; end就while循环，如果和与target相同，list加入结果，如果大，start+1，如果小end+1同时更新和，直到最后返回list即可</p><p>注意：两个窗口都是从左边出发，不是两边夹逼。另外，当小于目标数时high++；大于目标数时low++，如果是high–，那么你仔细想想，你的窗口还怎么往后移动，整个结果在第一次大于目标数之后就不会往后移动，相反，而是在在这个low和high之间夹逼试探，最终啥都找不到或者只能找到一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = []</span><br><span class="line">        idx_low,idx_high = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        sum_val = (idx_low+idx_high)*(idx_high-idx_low+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> idx_low&lt;idx_high:</span><br><span class="line">            <span class="keyword">if</span> sum_val==tsum:</span><br><span class="line">                alist.append(range(idx_low,idx_high+<span class="number">1</span>))</span><br><span class="line">                idx_high += <span class="number">1</span> <span class="comment"># 需要更新否则stall在这里了</span></span><br><span class="line">                sum_val += idx_high <span class="comment"># 这里只要加新的即可</span></span><br><span class="line">            <span class="keyword">elif</span> sum_val&lt;tsum:</span><br><span class="line">                idx_high += <span class="number">1</span></span><br><span class="line">                sum_val += idx_high <span class="comment"># 这里只要加新的即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum_val -= idx_low <span class="comment"># 注意顺序</span></span><br><span class="line">                idx_low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure><h2 id="24-翻转单词顺序列"><a href="#24-翻转单词顺序列" class="headerlink" title="24. 翻转单词顺序列"></a>24. 翻转单词顺序列</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s.split(<span class="string">' '</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="25-求1-2-3-…-n"><a href="#25-求1-2-3-…-n" class="headerlink" title="25. 求1+2+3+…+n"></a>25. 求1+2+3+…+n</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>解题思路：</strong><br>肯定是要用递归来解决，但是又不能使用if来给出终止条件，所以只能通过逻辑符号进行终止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> self.Sum_Solution(n<span class="number">-1</span>)+n</span><br></pre></td></tr></table></figure><h2 id="26-数组中重复的数字"><a href="#26-数组中重复的数字" class="headerlink" title="26. 数组中重复的数字"></a>26. 数组中重复的数字</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p><strong>解题思路：</strong><br>对数组进行遍历，对于每个位置，while判断当前index和value是否不相等，如果不等进入循环，判断value和list[value]相等则输出，不相等则替换位置，直至index和value相等。最后返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">while</span> k!=v:</span><br><span class="line">                <span class="keyword">if</span> v==numbers[v]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = v</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                tmp = numbers[v]</span><br><span class="line">                numbers[v] = v</span><br><span class="line">                v = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="27-构建乘积数组"><a href="#27-构建乘积数组" class="headerlink" title="27. 构建乘积数组"></a>27. 构建乘积数组</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。</p><p><strong>解题思路：</strong><br>主要想法就是两次遍历，正序遍历每个元素都为前面所有元素之积，倒序遍历每个元素都为所有后面元素之积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = [<span class="number">1</span>]</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[:<span class="number">-1</span>]:</span><br><span class="line">            tmp *= i</span><br><span class="line">            ret.append(tmp)</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            tmp *= A[i+<span class="number">1</span>]</span><br><span class="line">            ret[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="28-二叉树的下一个结点"><a href="#28-二叉树的下一个结点" class="headerlink" title="28. 二叉树的下一个结点"></a>28. 二叉树的下一个结点</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><strong>解题思路：</strong><br>因为是基于中序遍历，所以正常遍历是左中右，首先判断某个节点是否有右节点，如果有右节点设置临时节点tmp同时对tmp.left不断遍历，直到null然后返回对应值<br>对于没有有节点的值，向上找到父节点，判断是否父节点的left与当前节点是否相同，相同的话返回父节点，否则不断向上追溯，直到某个父节点的left与当前节点相同返回父节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            tmp = pNode.right</span><br><span class="line">            <span class="keyword">while</span> tmp.left:</span><br><span class="line">                tmp = tmp.left</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                parent = pNode.next</span><br><span class="line">                <span class="keyword">if</span> (parent.left==pNode):</span><br><span class="line">                    <span class="keyword">return</span> parent</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2 id="29-矩阵中的路径"><a href="#29-矩阵中的路径" class="headerlink" title="29. 矩阵中的路径"></a>29. 矩阵中的路径</h2><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p><strong>解题思路：</strong></p><pre><code>- 这道题利用回溯法，需要设定对应的矩阵的状态情况以及当前路径长度，需要一个辅助函数，主函数给定边界条件，当cols和rows都小于0或者要搜寻的路径小于0的时候返回False。- 因为不知道具体的其实点在哪，所以两层循环，对不同的ij进行试探hasPathCore(matrix, rows, cols, path, i, j, pathlen, markMTX)，其中pathlen是给定的路径的长度，markMTX是对应的状态。- hasPathCore这个函数首先判断pathlen是否跟len(path)相等，如果相等返回true。之后查看col/row是否满足边界条件，以及markMTX[i][j]状态是否未遍历，以及matrix[i][j]是否跟path[pathlen]相等，如果相等对当前矩阵状态进行变更同时pathlen+1，分别对上下左右进行递归or连接，如果返回true，直接return，如果返回false，对矩阵状态/pathlen进行退回，返回false</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># 过滤条件</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> cols&lt;<span class="number">0</span> <span class="keyword">or</span> rows&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        markMTX = [<span class="number">0</span>]*(rows*cols)</span><br><span class="line">        pathlen = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 确定逐个起始点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> self.hasPathCore(matrix, rows, cols, path, i, j, pathlen, markMTX):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathCore</span><span class="params">(self, matrix, rows, cols, path, row, col, pathlen, markMTX)</span>:</span></span><br><span class="line">        <span class="comment"># 3.终止条件</span></span><br><span class="line">        <span class="keyword">if</span> pathlen == len(path):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 2.设置初始防止一开始不满足</span></span><br><span class="line">        haspath = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 1.满足条件递归</span></span><br><span class="line">        <span class="keyword">if</span> row&gt;=<span class="number">0</span> <span class="keyword">and</span> row&lt;rows <span class="keyword">and</span> col&gt;=<span class="number">0</span> <span class="keyword">and</span> col&lt;cols <span class="keyword">and</span> matrix[cols*row+col]==path[pathlen] <span class="keyword">and</span> <span class="keyword">not</span> markMTX[cols*row+col]:</span><br><span class="line">            pathlen += <span class="number">1</span></span><br><span class="line">            markMTX[cols*row+col] = <span class="number">1</span></span><br><span class="line">            haspath = self.hasPathCore(matrix, rows, cols, path, row<span class="number">-1</span>, col, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row+<span class="number">1</span>, col, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row, col<span class="number">-1</span>, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row, col+<span class="number">1</span>, pathlen, markMTX)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> haspath:</span><br><span class="line">                pathlen -= <span class="number">1</span></span><br><span class="line">                markMTX[cols*row+col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> haspath</span><br></pre></td></tr></table></figure><h2 id="30-机器人的运动范围"><a href="#30-机器人的运动范围" class="headerlink" title="30. 机器人的运动范围"></a>30. 机器人的运动范围</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p><p><strong>解题思路：</strong><br>边界判断，是否长宽都小于0，否则返回0<br>之后设置辅助函数，一个是求位数和的，一个是用来计算能有多少个符合的格子，设定矩阵状态，给定00为起始点，对于每次满足ij范围且state[i][j]为0且坐标位数之和小于阈值，则计算count=1+上下左右，返回count即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stateMTX = [<span class="number">0</span>]*(rows*cols)</span><br><span class="line">        num = self.GetNum(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, stateMTX)</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNum</span><span class="params">(self, threshold, rows, cols, row, col, markmatrix)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.GetSum(threshold, rows, cols, row, col, markmatrix):</span><br><span class="line">            markmatrix[row * cols + col] = <span class="keyword">True</span></span><br><span class="line">            count = <span class="number">1</span> + self.GetNum(threshold, rows, cols, row - <span class="number">1</span>, col, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row, col - <span class="number">1</span>, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row + <span class="number">1</span>, col, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row, col + <span class="number">1</span>, markmatrix)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetSum</span><span class="params">(self, threshold, rows, cols, row, col, markmatrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> self.getdigit(row) + self.getdigit(</span><br><span class="line">                col) &lt;= threshold <span class="keyword">and</span> <span class="keyword">not</span> markmatrix[row * cols + col]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdigit</span><span class="params">(self,number)</span>:</span></span><br><span class="line">        sumval = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number&gt;<span class="number">0</span>:</span><br><span class="line">            sumval += number%<span class="number">10</span></span><br><span class="line">            number = number//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sumval</span><br></pre></td></tr></table></figure><h3 id="31-剪绳子-leetcode-343-整数拆分"><a href="#31-剪绳子-leetcode-343-整数拆分" class="headerlink" title="31. 剪绳子(leetcode 343 整数拆分)"></a>31. 剪绳子(leetcode 343 整数拆分)</h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>你可以假设 n 不小于 2 且不大于 58。</p><p>n = 2<br>return 1 (2 = 1 + 1)</p><p>n = 10<br>return 36 (10 = 3 + 3 + 4)</p><p><strong>解题思路</strong><br>使用动态规划，当长度为2时返回1，当长度为3时返回2，当长度大于等于4时，因为当前最优解是建立在之前最优解的基础上的，因此，只需要遍历之前最优解进行乘积找到最大即可。首先设定list[0,1,2,3]因为按照分各状态前三个分各状态是这样的，之后只需要不断向list里面添加最大值即可。最后输出最后一个元素即可。</p><p>或者求与3的余数，如果为1减一个3错一个4，为2则单拎出2.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">            idx = <span class="number">4</span></span><br><span class="line">            <span class="keyword">while</span> idx&lt;=n:</span><br><span class="line">                maxval = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,idx):</span><br><span class="line">                    maxval = max(maxval, alist[i]*alist[idx-i])</span><br><span class="line">                alist.append(maxval)</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="32-在-O-1-时间内删除链表节点"><a href="#32-在-O-1-时间内删除链表节点" class="headerlink" title="32. 在 O(1) 时间内删除链表节点"></a>32. 在 O(1) 时间内删除链表节点</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解题思路:</span><br><span class="line">判断链表是否存在，然后判断删除节点的<span class="keyword">next</span>是否是<span class="keyword">null</span>，如果不是<span class="keyword">null</span>，直接<span class="keyword">delete</span>.val = <span class="keyword">next</span>.val以及<span class="keyword">delete</span>.<span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>即可</span><br><span class="line">如果是<span class="keyword">null</span>要判断head是否与<span class="keyword">delete</span>相等，如果相等直接head=None，否则产生一个tmp节点遍历直至tmp.<span class="keyword">next</span>与删除节点相等，同时使tmp.<span class="keyword">next</span>=<span class="keyword">null</span>即可</span><br></pre></td></tr></table></figure><h3 id="33-删除链表中重复的结点"><a href="#33-删除链表中重复的结点" class="headerlink" title="33. 删除链表中重复的结点"></a>33. 删除链表中重复的结点</h3><p><strong>解题思路：</strong><br>对于基础情况如果phead为空或者next为空返回本身，否则设定nextnode，如果nextnode值与当前值不等，直接利用递归phead.next=self.deleteDuplication(phead.next)然后return-phead，否则使用while循环在满足有nextnode以及nextnode.val==phead.val条件时，不断.next，然后跳出循环时，返回利用递归返回self.deleteDuplication(nextnode)即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nextnode = pHead.next</span><br><span class="line">            <span class="keyword">if</span> nextnode.val==pHead.val:</span><br><span class="line">                <span class="keyword">while</span> nextnode <span class="keyword">and</span> nextnode.val==pHead.val:</span><br><span class="line">                    nextnode = nextnode.next</span><br><span class="line">                <span class="keyword">return</span> self.deleteDuplication(nextnode)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pHead.next = self.deleteDuplication(pHead.next)</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure><h2 id="34-链表中倒数第-K-个结点"><a href="#34-链表中倒数第-K-个结点" class="headerlink" title="34. 链表中倒数第 K 个结点"></a>34. 链表中倒数第 K 个结点</h2><p><strong>解题思路</strong><br>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p><p>注意边界条件，k为负数head为空，还要考虑k&gt;len(head)的情况，使用while循环避免</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> i&lt;k:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p2</span><br></pre></td></tr></table></figure><h2 id="35-链表中环的入口结点"><a href="#35-链表中环的入口结点" class="headerlink" title="35. 链表中环的入口结点"></a>35. 链表中环的入口结点</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><p><strong>解题思路：</strong><br>首先确定是否有环，快慢指针如果相等返回相遇节点。(一定在环里)<br>确定环的长度，根据该点在环内，如果相遇记录下长度<br>之后重新弄两个节点，想让一个走环长度，一个作为头，只后相同步数(1)相遇即为入口(因为此时环中点以及起始点距离环入口刚好都相等)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断是否为有环链表，如果是的话计算环的长度，指定两个idx，其中一个往后延伸环长度距离，之后以相同的步伐后移，</span></span><br><span class="line"><span class="string">        当相交的时候对应的节点即为入口</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isloop</span><span class="params">(pHead)</span>:</span></span><br><span class="line">            <span class="comment"># 判断是否为loop，是返回橡胶节点，一定在环中</span></span><br><span class="line">            idx1,idx2 = pHead, pHead</span><br><span class="line">            <span class="keyword">while</span> idx1.next <span class="keyword">and</span> idx2.next.next:</span><br><span class="line">                idx1 = idx1.next</span><br><span class="line">                idx2 = idx2.next.next</span><br><span class="line">                <span class="keyword">if</span> idx1 == idx2:</span><br><span class="line">                    <span class="keyword">return</span> idx1</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 计算环长度</span></span><br><span class="line">        ret = isloop(pHead)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            tmp = ret</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> tmp.next != ret:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                tmp = tmp.next</span><br><span class="line">            <span class="comment"># idx2先往后延长length距离，在以相同步伐前进，如果相等返回idx1/idx2节点</span></span><br><span class="line">            idx1,idx2 = pHead, pHead</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                idx2 = idx2.next</span><br><span class="line">            <span class="keyword">while</span> idx1!=idx2:</span><br><span class="line">                idx1 = idx1.next</span><br><span class="line">                idx2 = idx2.next</span><br><span class="line">            <span class="keyword">return</span> idx1</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2 id="36-树的子结构"><a href="#36-树的子结构" class="headerlink" title="36. 树的子结构"></a>36. 树的子结构</h2><p><strong>解题思路：</strong><br>设置一个辅助函数，叫做isRootSubtree，给定两个树，判断是不是这两个树相等，如果root1不存在或者root1.val!=root.val返回false，如果root2为None返回true，之后再利用isRootSubtree递归判断左右两个节点<br>对于主函数，如果root1或者root2为空返回false(因为空树不是子结构)，否则判断isRootSubtree以及对左右节点进行递归循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_subtree</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(A.left,B.left) <span class="keyword">and</span> self.is_subtree(A.right, B.right)</span><br></pre></td></tr></table></figure><h2 id="37-二叉树的镜像"><a href="#37-二叉树的镜像" class="headerlink" title="37. 二叉树的镜像"></a>37. 二叉树的镜像</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><strong>解题思路：</strong><br>首先边界条件，如果根节点是空的那么返回false，然后左右交换，再判断如果左节点存在则对于左节点递归，如果右节点存在则对于右节点递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''还是使用递归，中间不变左右交换，因此先判断tree是不是空，而且左右是否全为空，如果是false停止，</span></span><br><span class="line"><span class="string">        然后先换一次左和右，如果左子树非空再利用递归在左子树，右子树也是相同的'''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure><h2 id="38-对称的二叉树"><a href="#38-对称的二叉树" class="headerlink" title="38 对称的二叉树"></a>38 对称的二叉树</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p><strong>解题思路：</strong><br>根节点如果为空返回true，否则使用辅助函数isequal来判断根节点左子节点与右节点是否相等<br>辅助函数是为了判断树是否是对称的，判断两个节点如果都空返回true，如果两个节点有一个空返回false，如果两个节点值相等再使用递归返回对左右子树分别判断and连接结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_right</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> left.val==right.val:</span><br><span class="line">            <span class="keyword">return</span> self.left_right(left.left,right.right) <span class="keyword">and</span> self.left_right(left.right,right.left)</span><br><span class="line">        <span class="comment"># class里面所有的function都需要使用self调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 根节点比较特殊</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.left_right(pRoot.left, pRoot.right)</span><br></pre></td></tr></table></figure><h2 id="39-顺时针打印矩阵"><a href="#39-顺时针打印矩阵" class="headerlink" title="39. 顺时针打印矩阵"></a>39. 顺时针打印矩阵</h2><p>矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p><p><strong>解题思路：</strong><br>首先确定矩阵row和col的边界，使用while循环在row的上边界&lt;=下边界和col左边界&lt;=右边界时，<br>对矩阵顺时针遍历，一行一列之后需要判断row的上下边界是否相等，不相等遍历添加，同理col左右边界也是一样。最后统一对上下左右边界进行更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = []</span><br><span class="line">        c1,c2,r1,r2 = <span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>,<span class="number">0</span>,len(matrix)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> c1&lt;=c2 <span class="keyword">and</span> r1&lt;=r2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(c1,c2+<span class="number">1</span>):</span><br><span class="line">                ret.append(matrix[r1][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r1+<span class="number">1</span>,r2+<span class="number">1</span>):</span><br><span class="line">                ret.append(matrix[i][c2])</span><br><span class="line">            <span class="keyword">if</span> r1!=r2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(c1,c2)[::<span class="number">-1</span>]:</span><br><span class="line">                    ret.append(matrix[r2][i])</span><br><span class="line">            <span class="keyword">if</span> c1!=c2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(r1+<span class="number">1</span>,r2)[::<span class="number">-1</span>]:</span><br><span class="line">                    ret.append(matrix[i][c1])</span><br><span class="line">            c1+=<span class="number">1</span>;c2-=<span class="number">1</span>;r1+=<span class="number">1</span>;r2-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="40-包含-min-函数的栈"><a href="#40-包含-min-函数的栈" class="headerlink" title="40. 包含 min 函数的栈"></a>40. 包含 min 函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p><p><strong>题目解析：</strong><br>对于整个class，设置初始值函数，设置push函数，如果help栈为空data和help压入，如果data压入的值小于help最后一个值，则将新值压入help，弹栈的时候help和data都弹，栈的最小值求解的时候直接弹出辅助栈最后一个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    定义两个list分别是数据以及辅助列表，当有数值压入的时候，data一定压入，help判断是否为空，为空压入，</span></span><br><span class="line"><span class="string">    不为空时如果最后一个值大于新值，也压入。弹栈的时候如果help和data相同则都弹出，否则只弹出data。</span></span><br><span class="line"><span class="string">    top返回最后一个值即可。min返回help最后一个值即可。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line">        self.help = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.data.append(node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.help:</span><br><span class="line">            self.help.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.help[<span class="number">-1</span>]&gt;node:</span><br><span class="line">            self.help.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.data[<span class="number">-1</span>] == self.help[<span class="number">-1</span>]:</span><br><span class="line">            self.help.pop()</span><br><span class="line">        <span class="keyword">return</span> self.data.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.data[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.help[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="41-栈的压入、弹出序列"><a href="#41-栈的压入、弹出序列" class="headerlink" title="41. 栈的压入、弹出序列"></a>41. 栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p><p><strong>解题思路：</strong><br>遍历压栈list，使用while循环如果压栈不空且压栈值与弹栈值第一个相等则弹出值，同时弹栈序列index向后推，最后判断压栈是否为空，为空返回true否则false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        借助一个list和一个指针实现，list存储压栈元素，指针表征弹栈位置，</span></span><br><span class="line"><span class="string">        遍历压栈，如果压栈之后最后一个元素和弹栈指针所指元素相等(list不空)，那么list弹栈，指针加1，</span></span><br><span class="line"><span class="string">        如果不是则继续遍历压栈，最后查看list情况，如果空了返回True反之返回False</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        alist = []</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pushV: <span class="comment"># 压栈只有一次，遍历即可</span></span><br><span class="line">            alist.append(i)</span><br><span class="line">            <span class="keyword">while</span> alist <span class="keyword">and</span> alist[<span class="number">-1</span>]==popV[j]:</span><br><span class="line">                alist.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> alist:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="42-从上往下打印二叉树"><a href="#42-从上往下打印二叉树" class="headerlink" title="42 从上往下打印二叉树"></a>42 从上往下打印二叉树</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p><p><strong>解题思路:</strong><br>使用广度优先搜索，考虑边界，如果根节点为空返回None，设置一个list放置节点，先放入根节点，如果list不空，则弹出节点同时加入节点对应的val，如果节点左右节点是有的之加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        通过每次只输出根节点的值，并把后续的值append到tmp中，直至tmp为空，遍历完成</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        alist = []</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            cur = tmp.pop(<span class="number">0</span>)</span><br><span class="line">            alist.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                tmp.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                tmp.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure><h2 id="43-把二叉树打印成多行"><a href="#43-把二叉树打印成多行" class="headerlink" title="43. 把二叉树打印成多行"></a>43. 把二叉树打印成多行</h2><p><strong>解题思路：</strong><br>对于根节点进行判断，如果空则返回false，如果不空，加入临时list中，在list不为空时，使用一个辅助list保存当前层值，同时记录当前list长度，再利用一个循环对长度范围进行遍历，之后将list加入到结果列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = []</span><br><span class="line">            tmp = [pRoot]</span><br><span class="line">            <span class="keyword">while</span> tmp:</span><br><span class="line">                alist = []</span><br><span class="line">                length = len(tmp)</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                    node = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                    alist.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        tmp.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        tmp.append(node.right)</span><br><span class="line">                ret.append(alist)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="44-按之字形顺序打印二叉树"><a href="#44-按之字形顺序打印二叉树" class="headerlink" title="44. 按之字形顺序打印二叉树"></a>44. 按之字形顺序打印二叉树</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p><strong>解题思路：</strong><br>和上题一样，列表控制元素添加，当前列表长度控制行数，同时再加一个cnt用来判断是否是基数行，如果是则正序否则倒序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist = [pRoot]</span><br><span class="line">            ret = []</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> alist:</span><br><span class="line">                length = len(alist)</span><br><span class="line">                vallist = []</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                    pop = alist.pop(<span class="number">0</span>)</span><br><span class="line">                    vallist.append(pop.val)</span><br><span class="line">                    <span class="keyword">if</span> pop.left:</span><br><span class="line">                        alist.append(pop.left)</span><br><span class="line">                    <span class="keyword">if</span> pop.right:</span><br><span class="line">                        alist.append(pop.right)</span><br><span class="line">                <span class="keyword">if</span> cnt%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                    ret.append(vallist)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ret.append(vallist[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h3 id="45-二叉搜索树的后序遍历序列"><a href="#45-二叉搜索树的后序遍历序列" class="headerlink" title="45. 二叉搜索树的后序遍历序列"></a>45. 二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p><p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p><p><strong>解题思路:</strong><br>对于二叉搜索树，左&lt;中&lt;右，后序遍历是左右中，因此，list最后一个是根节点，根据根节点的值将list分成两部分，左节点右节点，分割index，如果右节点的值中有小于根节点的，返回false，否则返回true。之后如果左节点不空递归查看，右节点一样，然后返回左右结果并值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        这里要输出False/True而不是yes/no</span></span><br><span class="line"><span class="string">        注意二叉搜索树指的是二叉树中所有左边节点数值都比根节点数值小，右边节点数值都比根节点数值大</span></span><br><span class="line"><span class="string">        后续遍历是先左节点再右节点最后根节点</span></span><br><span class="line"><span class="string">        按照后序遍历方法root一定是最后一个值，左节点树在前右节点树在后，所以可以根据root值将list分为</span></span><br><span class="line"><span class="string">        两部分，所以根据前部分值确定分隔点index(小于root)，再根据index确定时候后半部分值都大于root，</span></span><br><span class="line"><span class="string">        如果是的话返回true，否则返回False，列表为空返回false</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        root = sequence[<span class="number">-1</span>]</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence[:<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i&lt;root:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sequence[idx:<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> j &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> sequence[:idx+<span class="number">1</span>]:</span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[:idx+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> sequence[idx+<span class="number">1</span>:<span class="number">-1</span>]:</span><br><span class="line">            right =  self.VerifySquenceOfBST(sequence[idx+<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><h2 id="46-二叉树中和为某一值的路径"><a href="#46-二叉树中和为某一值的路径" class="headerlink" title="46. 二叉树中和为某一值的路径"></a>46. 二叉树中和为某一值的路径</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p><p><strong>解题思路：</strong><br>使用递归，终止条件有两个如果tree为none返回none，如果node左右节点为空且当前节点值与target相等，返回[[node.val]]，然后对左右节点分别使用递归，最后遍历左右节点，分别于root.val相加返回最终值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [] <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val==expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]] <span class="comment"># 终止条件</span></span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val) <span class="comment"># 循环体</span></span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val) <span class="comment"># 循环体</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:</span><br><span class="line">            ret.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="47-复杂链表的复制"><a href="#47-复杂链表的复制" class="headerlink" title="47. 复杂链表的复制"></a>47. 复杂链表的复制</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p><p><strong>解题思路：</strong><br>首先找到边界条件，如果为空返回None，之后复制链表分成三步，首先先复制node然后node与前后进行连接(next连接)利用while进行遍历，之后再对random进行复制(如果random存在的话)，最后再对链表进行分割(cur.next存在)，next=cur.next，之后cur.next=next.next，cur=next，之后再返回对应的clone节点即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = RandomListNode(cur.label)</span><br><span class="line">            tmp.next = cur.next</span><br><span class="line">            cur.next = tmp</span><br><span class="line">            cur = tmp.next</span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nextnode = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                nextnode.random = cur.random.next</span><br><span class="line">            cur = nextnode.next</span><br><span class="line">        cur = pHead</span><br><span class="line">        clonehead = pHead.next</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            nextval = cur.next</span><br><span class="line">            cur.next = nextval.next</span><br><span class="line">            cur = nextval</span><br><span class="line">        <span class="keyword">return</span> clonehead</span><br></pre></td></tr></table></figure><h2 id="48-二叉搜索树与双向链表"><a href="#48-二叉搜索树与双向链表" class="headerlink" title="48. 二叉搜索树与双向链表"></a>48. 二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>解题思路：</strong><br>其实就是中序遍历的变体，首先初始化listhead和listtail分别为none，之后使用中序遍历，在中间过程中对节点进行判断，如果是第一次，就把root节点给head和tail，否则改变节点指向，tail.right指向root，root.left指向tail，同时tail更新为root，最后返回即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.listhead = <span class="keyword">None</span></span><br><span class="line">        self.listtail = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.listhead:</span><br><span class="line">            self.listhead = pRootOfTree</span><br><span class="line">            self.listtail = pRootOfTree</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.listtail.right = pRootOfTree</span><br><span class="line">            pRootOfTree.left = self.listtail</span><br><span class="line">            self.listtail = pRootOfTree</span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">return</span> self.listhead</span><br></pre></td></tr></table></figure><h2 id="49-序列化二叉树"><a href="#49-序列化二叉树" class="headerlink" title="49. 序列化二叉树"></a>49. 序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p><strong>解题思路：</strong><br>对于二叉树的序列化，可以对tree进行判断，如果为空返回#，否则返回根值,树左节点遍历,树右节点遍历，使用逗号隔开<br>对于反序列化，对序列按照逗号进行分割，然后使用一个辅助函数，辅助函数：如果list为空返回None，之后对对list.pop(0)，如果该值不为#则返回构建的树，记得左右节点是递归构建的，再return root即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 前序遍历如果有none存在就返回'#'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right) <span class="comment"># 字符串转化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deser</span><span class="params">(self, alist)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> alist: <span class="comment"># 如果为空#都没了返回None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        val = alist.pop(<span class="number">0</span>) <span class="comment"># 如果有的话pop</span></span><br><span class="line">        root = <span class="keyword">None</span> <span class="comment"># 设定为空，如果上来就是#，也要返回None</span></span><br><span class="line">        <span class="keyword">if</span> val!=<span class="string">'#'</span>:</span><br><span class="line">            root = TreeNode(int(val))</span><br><span class="line">            root.left = self.deser(alist) <span class="comment"># 顺序输出可以保证左右</span></span><br><span class="line">            root.right = self.deser(alist)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> self.deser(alist)</span><br></pre></td></tr></table></figure><h2 id="50-字符串的排列"><a href="#50-字符串的排列" class="headerlink" title="50. 字符串的排列"></a>50. 字符串的排列</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p><p><strong>解题思路：</strong><br>首先基本的边界判断，如果ss为空返回[]，否则设定ret=[]作为结果存放，path=’’作为开始的字符串长度<br>利用辅助函数，递归终止条件是当ss为空的对path插入到ret中(便利到最后一个字符的时候会一次性插入不用担心path有问题)，否则对每个字符进行遍历，使用递归更新子问题</p><p>ss是状态，ret是结果，类似于之前的机器人和路径查找，只不过是状态矩阵以及以及length分别作为判断，结果返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(self.help(ss))))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ss)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(ss)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [ss]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> self.help(ss[:i]+ss[i+<span class="number">1</span>:]):</span><br><span class="line">                    ret.append(v+j)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="51-数据流中的中位数"><a href="#51-数据流中的中位数" class="headerlink" title="51. 数据流中的中位数"></a>51. 数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>解题思路：</strong><br>可以初始化一个列表，然后insert数据流中的数，之后对于数据进行排序，在输出中位数即可<br>要熟悉一下各类排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.alist = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.alist.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self,n=None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        list_len = len(self.alist)</span><br><span class="line">        sort_list = sorted(self.alist)</span><br><span class="line">        <span class="keyword">if</span> list_len%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sort_list[list_len/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (sort_list[list_len/<span class="number">2</span>]+sort_list[list_len/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure><h2 id="52-字符流中第一个不重复的字符"><a href="#52-字符流中第一个不重复的字符" class="headerlink" title="52 字符流中第一个不重复的字符"></a>52 字符流中第一个不重复的字符</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。</p><p><strong>解题思路：</strong><br>设置初始函数，一个s一个dic分别用作记录不重复字符以及对应的字符字典，插入功能：对字符进行统计，如果是新的需要s加入此元素(顺序加入)，之后对于不重复的元素只要遍历self.s进行对比是否为1即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">        self.adic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.adic[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.adic:</span><br><span class="line">            self.adic[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.adic[char] = <span class="number">1</span></span><br><span class="line">            self.s += char</span><br></pre></td></tr></table></figure><h2 id="53-把数字翻译成字符串"><a href="#53-把数字翻译成字符串" class="headerlink" title="53. 把数字翻译成字符串"></a>53. 把数字翻译成字符串</h2><p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”… 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>解题思路：</strong><br>典型的动态规划问题，分歧点就在于是否新加入的字符串能够和上一个字符串构成有效字母。<br>初始值，如果num&lt;0返回0，如果len(str(num))为1，则返回1，否则对其进行倒叙遍历从倒数第二个开始，before,after=0,1,递推公式f(r-2) = f(r-1)+g(r-2,r-1)<em>f(r)；<br>before,after=after,after+flag</em>before</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'10'</span>&lt;s[i<span class="number">-2</span>:i]&lt;=<span class="string">'26'</span> <span class="keyword">and</span> s[i<span class="number">-2</span>:i]!=<span class="string">'20'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-2</span>]+ret[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-2</span>:i]==<span class="string">'10'</span> <span class="keyword">or</span> s[i<span class="number">-2</span>:i]==<span class="string">'20'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-2</span>])</span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-1</span>]!=<span class="string">'0'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ret.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret[len(s)]</span><br><span class="line">https://zhuanlan.zhihu.com/p/<span class="number">60238439</span></span><br></pre></td></tr></table></figure><h2 id="54-礼物的最大价值"><a href="#54-礼物的最大价值" class="headerlink" title="54. 礼物的最大价值"></a>54. 礼物的最大价值</h2><p>在一个 m * n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p><p><strong>解题思路：</strong><br>还是动态规划，maxval = max(left,up)+val[i][j]<br>首先进行边界判断，如果矩阵row和col都&lt;=0，return 0<br>之后建立dp矩阵存储上一次的值，对row和col进行遍历，利用递推公式将dp进行填充，需要考虑left或者up是否存在(对index判断)，并对dp当前值进行更新，注意left和up要初始化为0<br>最后返回最后一个值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bonus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMost</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(board)&lt;=<span class="number">0</span> <span class="keyword">or</span> len(board[<span class="number">0</span>])&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        row,col=len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(col)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                up,left=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    up = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    left = dp[i][j<span class="number">-1</span>]</span><br><span class="line">                dp[i][j] = max(up,left)+board[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="55-丑数"><a href="#55-丑数" class="headerlink" title="55. 丑数"></a>55. 丑数</h3><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p><p><strong>解题思路：</strong><br>对于index&lt;7的直接返回index，之后初始化t2,t3,t5,对应list中的321，之后for循环直到n，向list不断加min(alist[t2]<em>2,alist[t3]</em>3,alist[t5]<em>5)即可<br>更新t2/t3/t5，分别都使用while循环，例如alist[t2]</em>2&lt;=alist[-1], t2+=1<br>最后返回alist[-1]即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        丑数是由235组成的，如果顺序排列好，新的丑数为之前所有丑数*2、3、5之后大于当前最大丑数的最小的值，</span></span><br><span class="line"><span class="string">        但因为是排好序的，只需要确定T2，T3，T5的index这个index之前的数成2，3，5都小于当前最大丑数，只要更新这个index即可</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        alist = range(<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        t2,t3,t5=<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>,index):</span><br><span class="line">            alist.append(min([alist[t2]*<span class="number">2</span>,alist[t3]*<span class="number">3</span>,alist[t5]*<span class="number">5</span>])) <span class="comment"># 添加新丑数</span></span><br><span class="line">            <span class="comment"># 对t2t3t5更新</span></span><br><span class="line">            <span class="keyword">while</span> alist[t2]*<span class="number">2</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> alist[t3]*<span class="number">3</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> alist[t5]*<span class="number">5</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="56-数字在排序数组中出现的次数"><a href="#56-数字在排序数组中出现的次数" class="headerlink" title="56. 数字在排序数组中出现的次数"></a>56. 数字在排序数组中出现的次数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            first = self.getFirstK(data, k , <span class="number">0</span>, len(data) - <span class="number">1</span>)</span><br><span class="line">            last = self.getLastK(data, k, <span class="number">0</span>, len(data) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">-1</span> <span class="keyword">and</span> last &gt; <span class="number">-1</span>:</span><br><span class="line">                num = last - first + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFirstK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        midD = data[mid]</span><br><span class="line">        <span class="keyword">if</span> midD &gt; k:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> midD &lt; k:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>) <span class="keyword">or</span> (mid &gt; <span class="number">0</span> <span class="keyword">and</span> data[mid - <span class="number">1</span>] != k):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.getFirstK(data, k, start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        midD = data[mid]</span><br><span class="line">        <span class="keyword">if</span> midD &gt; k:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> midD &lt; k:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (mid == len(data) - <span class="number">1</span>) <span class="keyword">or</span> (mid &lt; len(data) - <span class="number">1</span> <span class="keyword">and</span> data[mid + <span class="number">1</span>] != k):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.getLastK(data, k, start, end)<span class="comment">#复制粘贴搞错了。。</span></span><br></pre></td></tr></table></figure><h2 id="57-二叉查找树的第-K-个结点"><a href="#57-二叉查找树的第-K-个结点" class="headerlink" title="57. 二叉查找树的第 K 个结点"></a>57. 二叉查找树的第 K 个结点</h2><p>利用二叉查找树中序遍历有序的特点。</p><p><strong>解题思路</strong><br>二叉树左边&lt;中间&lt;右边，所以使用中序遍历，使用递归，函数要有一个格外的list存结果<br>之后找到第k个元素即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="string">'''中序遍历可以对节点从大到小排'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mid</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            ret.extend(self.mid(root.left)) <span class="comment"># extend是因为返回的是个list</span></span><br><span class="line">        ret.append(root) <span class="comment"># 这里是循环添加的元素</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            ret.extend(self.mid(root.right))</span><br><span class="line">        <span class="keyword">return</span> ret <span class="comment"># 返回的是list</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span>: <span class="comment"># k=0异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        ret = self.mid(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(ret)&lt;k: <span class="comment"># k异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> ret[k<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#    def mid(self, pRoot):</span></span><br><span class="line"><span class="comment">#        if not pRoot:</span></span><br><span class="line"><span class="comment">#            return []</span></span><br><span class="line"><span class="comment">#        ret = []</span></span><br><span class="line"><span class="comment">#        ret += self.mid(pRoot.left)</span></span><br><span class="line"><span class="comment">#        ret.append(pRoot.val)</span></span><br><span class="line"><span class="comment">#        ret += self.mid(pRoot.right)</span></span><br><span class="line"><span class="comment">#        return ret</span></span><br></pre></td></tr></table></figure><h2 id="58-二叉树的深度"><a href="#58-二叉树的深度" class="headerlink" title="58. 二叉树的深度"></a>58. 二叉树的深度</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>解题思路：</strong><br>递归：一棵树的长度 = 1 (根节点) + max(左子树长度, 右子树长度)<br>所以终止条件如果为空那么久返回0，否则使用递归左节点以及右节点且分别加1，然后判断两者大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        递归</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.TreeDepth(pRoot.left)+<span class="number">1</span>,self.TreeDepth(pRoot.right)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="59-平衡二叉树"><a href="#59-平衡二叉树" class="headerlink" title="59 平衡二叉树"></a>59 平衡二叉树</h2><p>问题描述：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中的任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>解题思路</strong><br>递归：使用上面的求深度函数，对每个节点的左右子树检查。<br>如果为空返回true，如果左右子树深度差大于1返回false，对左右节点进行递归检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        left = self.depth(pRoot.left)</span><br><span class="line">        right = self.depth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> abs(left-right)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">1</span>+self.depth(pRoot.left),<span class="number">1</span>+self.depth(pRoot.right))</span><br></pre></td></tr></table></figure><h2 id="60-和为-S-的两个数字"><a href="#60-和为-S-的两个数字" class="headerlink" title="60. 和为 S 的两个数字"></a>60. 和为 S 的两个数字</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><p><strong>解题思路：</strong><br>使用双指针，对于左指针&lt;右指针时while循环，如果对应的数字和为target，返回两个数字，此时肯定成绩最小，否则更新left和right的index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        left,right = <span class="number">0</span>, len(array)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            <span class="keyword">if</span> array[left]+array[right]==tsum:</span><br><span class="line">                <span class="keyword">return</span> array[left],array[right]</span><br><span class="line">            <span class="keyword">elif</span> array[left]+array[right]&gt;tsum:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="61-滑动窗口的最大值"><a href="#61-滑动窗口的最大值" class="headerlink" title="61. 滑动窗口的最大值"></a>61. 滑动窗口的最大值</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p><p><strong>解题思路：</strong><br>直接遍历，求最大值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)-size+<span class="number">1</span>):</span><br><span class="line">            ret.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="62-扑克牌顺子"><a href="#62-扑克牌顺子" class="headerlink" title="62. 扑克牌顺子"></a>62. 扑克牌顺子</h2><p>五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p><p><strong>解题思路：</strong><br>首先统计0的个数，然后对数组排序，从不为0的数开始进行遍历，查看是否相邻数字相等，相等返回false，不相等则cnt-=后-前-1，如果最后cnt&gt;=0，返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        sortnum = sorted(numbers)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sortnum:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt,len(sortnum)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sortnum[i]==sortnum[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cnt -= sortnum[i+<span class="number">1</span>]-sortnum[i]<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h2><p>可以有一次买入和一次卖出，买入必须在前。求最大收益。 </p><p><strong>解题思路：</strong><br>设定当前index之前的最小值(第一个)，和最大收益(初始为0)，对数组进行遍历从第二个开始，确定之前最小值，以及以该节点为结尾的值和之前最大值的max，返回最后的max</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：动态规划，f(n) = max(f(n-1), A[n]-min(A[:n-1]))</span></span><br><span class="line"><span class="string">        当前天收入=max(前一天受益，当前天价值-之前所有天最小值)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            maxpre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minpre = prices[<span class="number">0</span>]</span><br><span class="line">            maxpre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">                maxpre = max(prices[i]-minpre, maxpre)</span><br><span class="line">                minpre = min(minpre, prices[i])</span><br><span class="line">        <span class="keyword">return</span> maxpre</span><br></pre></td></tr></table></figure><h2 id="64-圆圈中最后剩下的数"><a href="#64-圆圈中最后剩下的数" class="headerlink" title="64. 圆圈中最后剩下的数"></a>64. 圆圈中最后剩下的数</h2><p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数 …. 这样下去 …. 直到剩下最后一个小朋友，可以不用表演。</p><p><strong>解题思路：</strong><br>约瑟夫环，如果n=0时返回-1，如果n=1返回0，之后return (self.xxx(n-1,m)+m)%n<br>环为n,指定数为m，结果等于度为n-1的约瑟夫环+m % n即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (self.xxx(n<span class="number">-1</span>,m)+m)%n</span><br></pre></td></tr></table></figure><h2 id="65-n-个骰子的点数"><a href="#65-n-个骰子的点数" class="headerlink" title="65. n 个骰子的点数"></a>65. n 个骰子的点数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把 n 个骰子仍在地上，求点数和为 s 的概率。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用动态规划，dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-2</span>]+dp[i<span class="number">-1</span>][j<span class="number">-3</span>]+dp[i<span class="number">-1</span>][j<span class="number">-4</span>]+dp[i<span class="number">-1</span>][j<span class="number">-5</span>]+dp[i<span class="number">-1</span>][j<span class="number">-6</span>]</span><br><span class="line">首先初始化一个矩阵，行是n，列是n*<span class="number">6</span>，值全部为<span class="number">0</span>，然后对于第一行进行初始化，前<span class="number">6</span>个值是<span class="number">1</span></span><br><span class="line">之后使用循环对于<span class="number">1</span>-n来说(<span class="number">1</span>这里代表<span class="number">2</span>)，遍历n~(n+<span class="number">1</span>)*<span class="number">6</span>，动态规划对结果进行填充，最后返回dp[n<span class="number">-1</span>]即可</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/leokingszx/article/details/80794407" target="_blank" rel="noopener">说明</a></p><h2 id="66-树中两个节点的最低公共祖先"><a href="#66-树中两个节点的最低公共祖先" class="headerlink" title="66. 树中两个节点的最低公共祖先"></a>66. 树中两个节点的最低公共祖先</h2><p>(1) 二叉查找树<br>解题思路：<br>因为所有节点都不重复，而且按照中序遍历一定是顺序的，所以，首先确定特殊情况，如果root为空返回None，如果root.val&lt;p.val and root.val&lt;q.val，则说明是在右子树，则使用递归(root.right,p,q)<br>如果root.val&gt;p.val and root.val&gt;q.val，则说明是在左子树，则使用递归(root.left,p,q)，否则return root(此时一定不相等)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>(2) 普通二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> p==root <span class="keyword">or</span> q==root: <span class="comment"># 判断特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right =  self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="comment"># 如果左右节点都存在，返回root</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left: <span class="comment"># 否则，如果左节点都存在，返回left</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right: <span class="comment"># 否则，如果右节点都存在，返回right</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><h2 id="67-在排序数组中查找数字"><a href="#67-在排序数组中查找数字" class="headerlink" title="67.在排序数组中查找数字"></a>67.在排序数组中查找数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题描述：统计一个数字在排序数组中出现的次数。如，输入排序数组&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;和数字<span class="number">3</span>，由于<span class="number">3</span>在这个数组中出现了<span class="number">4</span>次，因此输出<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">直接用字典</span><br><span class="line">或者使用二分查找，分别找到头和尾，查头的时候，在k=data[mid]的位置，如果mid是第一位或者如果不是第一位其之前的数不等于k，那么返回mid，否则end为mid<span class="number">-1</span></span><br><span class="line">查尾的时候，在k=data[mid]的位置，如果mid是最后一位或者如果不是最后一位其之后的数不等于k，那么返回mid，否则start为mid+<span class="number">1</span>(start&gt;end返回<span class="number">-1</span>)</span><br><span class="line">之后再使用end-start+<span class="number">1</span>，如果返回<span class="number">-1</span>则直接返回<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="68-数字序列中的某一位数字"><a href="#68-数字序列中的某一位数字" class="headerlink" title="68. 数字序列中的某一位数字"></a>68. 数字序列中的某一位数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">数字以 <span class="number">0123456789101112131415.</span>.. 的格式序列化到一个字符串中，求这个字符串的第 index 位。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">对于数字进行循环，并且不断累加数字长度，当数字长度大于index的时候输出str(i)[length-n]即可</span><br></pre></td></tr></table></figure><h2 id="69-最长不含重复字符的子字符串"><a href="#69-最长不含重复字符的子字符串" class="headerlink" title="69.最长不含重复字符的子字符串"></a>69.最长不含重复字符的子字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题描述：请从字符串中找出一个最长的不包含重复字符串的子字符串，计算该最长子字符串的长度。假设字符串中只包含‘a’~‘z’的字符。例如，在字符串“arabcacfr”中，最长的不含重复字符的子字符串是“acfr”，长度是<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">动态规划，首先设定三个变量，curmax,totalmax,字母表字典记录上次出现位置(初始<span class="number">-1</span>)</span><br><span class="line">对字符串进行遍历，如果某个字符位置是<span class="number">-1</span>或者字符串位置和上次出现位置之差&gt;cur那么cur+=<span class="number">1</span>，否则cur=两次位置距离差</span><br><span class="line">然后跟totalmax进行比较，进行更新，更新字典。最后返回长度</span><br></pre></td></tr></table></figure><h2 id="70-两个链表的第一个公共节点"><a href="#70-两个链表的第一个公共节点" class="headerlink" title="70.两个链表的第一个公共节点"></a>70.两个链表的第一个公共节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">问题描述：输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">如果<span class="keyword">while</span>循环两个链表不相等的话持续循环，如果<span class="number">1</span>链表到结尾了则让<span class="number">1</span>链表连接到<span class="number">2</span>上否则next，<span class="number">2</span>链表也一样，最后输出共同链表</span><br></pre></td></tr></table></figure><h1 id="Leetcode习题"><a href="#Leetcode习题" class="headerlink" title="Leetcode习题"></a>Leetcode习题</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p><p>给定一个整型数组 nums 和一个目标值 target ，请找出数组中和为 target 的两个整数，并返回这两个数的数组下标。<br>假设：<br>1）每个输入只对应一个答案；<br>2）不允许重复使用数组中的数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">return</span> [adic[v],k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[target-v] = k</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Example:<br>Given nums = [0,1,2,2,3,0,4,2], val = 2,<br>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.<br>Note that the order of those five elements can be arbitrary.<br>It doesn’t matter what values are set beyond the returned length.</p><p>给定一个数组 nums 和一个值 val ，请在原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>要求：<br>1）原地操作的意思是不允许开辟额外的数组空间，空间复杂度必须为O(1)；<br>2）数组中元素的顺序是可以改变的，也不需要考虑超出新长度后面的元素。</p><p><strong>解题思路1：</strong><br>本题难点在于不允许使用额外的数组空间，因此考虑使用两个下标指针 i，j（初始都指向数组头部）：<br>当 nums[j] 等于 val（需移除的元素），忽略当前这个元素，j++；<br>当 nums[j] 不等于 val（需保留的元素），用 nums[j] 的值覆盖 nums[i] 的值，i++，j++。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            <span class="keyword">if</span> nums[start]==val:</span><br><span class="line">                nums[start] = nums[end]</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        nums = nums[:start]</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure></p><p><strong>解题思路2：</strong><br>另一种思路仍是采用两个指针，一个从头向后扫，另一个从尾向前扫，遇到和 val 相等的值就和数组尾部的元素交换或覆盖。（假如需要移除的元素很少时，这种思路需要赋值的次数更少）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 保留与val不同的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i!=val:</span><br><span class="line">                nums[count] = i</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        nums = nums[:count] <span class="comment"># 注意这里count其实多加了1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p><h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</p><p>Example1:<br>Input: [1,3,5,6], 5<br>Output: 2</p><p>Example2:<br>Input: [1,3,5,6], 2<br>Output: 1</p><p>Example3:<br>Input: [1,3,5,6], 7<br>Output: 4</p><p>Example4:<br>Input: [1,3,5,6], 0<br>Output: 0<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p><p><strong>解题思路：</strong><br>因为数组是有序的，所以直观的想法是考察nums中相邻元素与target的关系，如果target在相邻元素范围内，进一步判断是否与左边的数相等，进而判断插入或所在位置，当然除此之外还需要考虑target在nums最大最小值之外的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先判断两头</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]&gt;=target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># 在判断中间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (target&gt;=nums[i]) <span class="keyword">and</span> (target&lt;=nums[i+<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> target==nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53.Maximum Subarray"></a>53.Maximum Subarray</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p><p>Follow up:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>解题思路：</strong><br>利用动态规划思想，我们假设f(n)为末尾下标为n的最优子序列的和，那么f(n-1)即为末尾下标为n-1的最优子序列和，A(n)为nums数组中下标为n的元素，我们来考察三者的关系，即为：f(n)=max( f(n-1)+A(n), A(n) )，解释一下，因为我们之前已经给过定义f(n)是以n为末尾的子序列，那么他只可能有两种情况，要么是f(n-1)所在的子序列加上A(n)作为f(n)，要么就是只有A(n)这一个元素(因为A(n)时一定要存在的)，所以我们只需要判断一下，哪种序列和最大，就保留这个最大值，作为以n为末尾的子序列的最大值。这样我们遍历整个数组，把每个结果存起来，最后比较出最大值，即为整体子序列的最大值(其下标所在位置即为最优子序列末尾下表位置)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = [] <span class="comment"># 存储从0~len(nums)-1为末尾下标的最优子序列值</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                before = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                after = max(before+v,v)</span><br><span class="line">                before = after</span><br><span class="line">            alist.append(before)</span><br><span class="line">        <span class="keyword">return</span> max(alist)</span><br></pre></td></tr></table></figure><h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66.Plus One"></a>66.Plus One</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.<br>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.<br>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p>Example 1:<br>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p><p>Example 2:<br>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 借助类型转换</span></span><br><span class="line">        before = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            before += str(i)</span><br><span class="line">        after = str(int(before)+<span class="number">1</span>)</span><br><span class="line">        ret = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> after]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>Note:<br>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:<br>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>Output: [1,2,2,3,5,6]</p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。</p><p>说明:<br>初始时， nums1 和 nums2 的元素数量分别为 m 和 n。<br>假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p><strong>解题思路：</strong><br>通过双指针进行操作，因为nums1数组长度为m+n且nums1和nums2都是有序的，所以，我们分别把m和n作为nums1和nums2的指针(即指向末尾)，对两个数组遍历，终止条件是其中一个数组下标为0(即只要有一个数组遍历完就结束)，将指针所指的元素进行比较，将较大的数放在num1的末尾，同时较大数所在数组的指针减1，以此类推。最后如果m下标所在数组没有遍历完，则说明剩下的数字都比nums2的最小数字小，nums1数组不应做任何操作，如果nums2所在数组没有遍历完，那么说明nums2剩下的数字都比num1最小值小，此时需要把nums2剩下数字填充到nums1最前面相应位置即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>]&gt;=nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure><h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.Pascal’s Triangle"></a>118.Pascal’s Triangle</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br>Note: In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:<br>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>注意：在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p><p><strong>解题思路：</strong><br>官方的图片其实很清楚的解释了原理，即从第三行开始，每一组两边的数都是1，中间的数都是由上一层相邻元素相加获得的，因此如果想要获取当前行数组，只需要上一层数组即可，有点像斐波那契数列的感觉，因为题目要求输出所有行因此需要把每行保存起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,numRows+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before = alist[<span class="number">-1</span>]</span><br><span class="line">                after = [<span class="number">1</span>]+[before[j]+before[j+<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]+[<span class="number">1</span>]</span><br><span class="line">                alist.append(after)</span><br><span class="line">            <span class="keyword">print</span> alist</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121.Best Time to Buy and Sell Stock"></a>121.Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p><p>Example1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p><p>Example2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p><p><strong>解题思路：</strong><br>动态规划，f(n) = max(f(n-1), A[n]-min(A[:n-1]))<br>当前天收入=max(前一天受益，当前天价值-之前所有天最小值)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_profit = <span class="number">0</span> <span class="comment"># max of f(n)</span></span><br><span class="line">            min_num = prices[<span class="number">0</span>] <span class="comment"># min(A[:n-1])</span></span><br><span class="line">            before = <span class="number">0</span> <span class="comment"># f(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">                cur = prices[i+<span class="number">1</span>] <span class="comment"># A[n]</span></span><br><span class="line">                after = max(before, cur-min_num) <span class="comment"># f(n)</span></span><br><span class="line">                <span class="keyword">print</span> after</span><br><span class="line">                before = after</span><br><span class="line">                min_num = cur <span class="keyword">if</span> cur&lt;min_num <span class="keyword">else</span> min_num <span class="comment"># update min value</span></span><br><span class="line">                max_profit = before <span class="keyword">if</span> before&gt;max_profit <span class="keyword">else</span> max_profit</span><br><span class="line">            <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p><h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119.Pascal’s Triangle II"></a>119.Pascal’s Triangle II</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.<br>Note that the row index starts from 0.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><strong>解题思路:</strong><br>当前层可以通过上一层得到，因此每次保留上一层数即可，得到当前层之后，将当前层替换成before即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> rowIndex==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            before = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(rowIndex - <span class="number">1</span>):</span><br><span class="line">                mid = [before[i]+before[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]</span><br><span class="line">                after = [<span class="number">1</span>] + mid + [<span class="number">1</span>]</span><br><span class="line">                before = after</span><br><span class="line">            <span class="keyword">return</span> before</span><br></pre></td></tr></table></figure></p><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p><strong>解题思路：</strong><br>与股票买卖1相比，主要的差别在于可以多次买卖，换句话说也就是“股票买卖1”问题每个数字只能进行一次操作，但是该问题每个数字可以进行多次操作(买与卖)。因此，每天先买入(不会亏)，查看下一天，如果会亏就把当天的卖了，就相当于赚了0元，如果下一天会赚那么就直接卖掉，再买入下一天的股票，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i]&lt;prices[i+<span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p><h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>Example 1:<br>Given nums = [1,1,2],<br>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.<br>It doesn’t matter what you leave beyond the returned length.<br>Example 2:<br>Given nums = [0,0,1,1,1,2,2,3,3,4],</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>解题思路：</strong><br>通过两个下标index和i完成，index下标从0开始，i从1开始，i是用来遍历数组的，当遇到重复值就跳过，index不增加，如果遇到的是非重复值，index下标加1并对原数组进行修改，将值改为i对应的值，直至遍历完整个数组，最后得到的元素组的前index+1个元素就是不重复元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index控制不重复数字，i对列表变进行遍历</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        nums = nums[:index+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="167-Two-Sum-II"><a href="#167-Two-Sum-II" class="headerlink" title="167. Two Sum II"></a>167. Two Sum II</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:<br>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><p>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p><strong>解题思路：</strong><br>跟第一题twosum的思路一样<br>就是遍历整个数组，之后将每一个target与数组元素之差作为字典的key存起来，同时将该元素所在位置下标作为value存起来，在遍历过程中，如果遇到元素与之前建立的字典的key相同，即取出之前的元素对应的下标，同时和当前元素对应下标，输出出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">return</span> [adic[v]+<span class="number">1</span>,k+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[target-v] = k</span><br></pre></td></tr></table></figure><h2 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169. 求众数"></a>169. 求众数</h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2</p><p><strong>解题思路：</strong><br>没啥说的，主要注意sorted的用法，应该还有更快的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sorted(adic.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><p><strong>解题思路：</strong><br>利用list的pop功能(类似于栈)对数据弹出，再从头插入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>, nums.pop())</span><br></pre></td></tr></table></figure><h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p><p>示例 2:<br>输入: [1,2,3,4]<br>输出: false</p><p>示例 3:<br>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p><p><strong>解题思路：</strong><br>利用集合不重复特性，根据长度进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(set(nums))!=len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219.存在重复元素 II"></a>219.存在重复元素 II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且存在 i 和 j 的差的绝对值不大于k的组合。</p><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p><p>示例 2:<br>输入: nums = [1,0,1,1], k = 1<br>输出: true</p><p>示例 3:<br>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p><p><strong>解题思路：</strong><br>首先建立一个字典，将所有的元素作为key，元素对应的下标作为value，如果value有重复则直接加入相应key所在的list即可，之后遍历字典，如果字典key对应的value有重复值，计算重复值相邻数字之间的差的绝对值，如果绝对值最小值小于k，则证明存在这样一组下标符合条件，否则返回False(即不存在这样的组合)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125; <span class="comment"># 储存数组值及对应index</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> adic:</span><br><span class="line">                adic[j].append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[j] = [i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">            adic_v = adic[i]</span><br><span class="line">            <span class="keyword">if</span> len(adic_v)&gt;<span class="number">1</span>:</span><br><span class="line">                adic_v_diffmin = min([abs(adic_v[j]-adic_v[j+<span class="number">1</span>]) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(adic_v)<span class="number">-1</span>)]) <span class="comment"># 求相邻index的差的绝对值的最小值</span></span><br><span class="line">                <span class="keyword">if</span> adic_v_diffmin&lt;=k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:<br>输入: [3,0,1]<br>输出: 2</p><p>示例 2:<br>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p><p>说明:<br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><p><strong>解题思路：</strong><br>求解0-n所有数的和，然后减去nums的和，差的那个数就是缺失的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        list_len = len(nums)</span><br><span class="line">        total = (<span class="number">1</span>+list_len)*list_len/<span class="number">2</span></span><br><span class="line">        rest = total-sum(nums)</span><br><span class="line">        <span class="keyword">return</span> rest</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p>说明:<br>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p><strong>解题思路：</strong><br>使用双指针，其中一个指针real_idx代表非0数字下标，另一个指针iter_idx代表遍历数组的下标，连个下标都为0，从头开始遍历数组，当遇到数组为0的时候real_idx不变，当不为0的时候，交换real_idx所在下标的值以及iter_idx所在下标的值，则相当于把0后置，相对的非0值顺序没有改变，最后返回nums原数组即为所求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        real_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> iter_idx <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[iter_idx]!=<span class="number">0</span>:</span><br><span class="line">                nums[real_idx],nums[iter_idx] = nums[iter_idx],nums[real_idx]</span><br><span class="line">                real_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a>414. 第三大的数</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p>示例 1:<br>输入: [3, 2, 1]<br>输出: 1<br>解释: 第三大的数是 1.</p><p>示例 2:<br>输入: [1, 2]<br>输出: 2<br>解释: 第三大的数不存在, 所以返回最大的数 2 .</p><p>示例 3:<br>输入: [2, 2, 3, 1]<br>输出: 1<br>解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。<br>存在两个值为2的数，它们都排第二。</p><p><strong>解题思路：</strong><br>遍历数组，可以借鉴求最大值的思路，只不过扩展一下，求解前三大的数字而已，利用判断语句判断nums当前的值的范围，如果比最大值大就替代，在最大值第二大值之间就替代第二大值，在第二大值及第三大值之间就替代第三大值，否则跳过。有一点需要注意的是赋值的顺序，不能有交叉影响下一个复制表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max1, max2, max3 = float(<span class="string">'-inf'</span>),float(<span class="string">'-inf'</span>),float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> [max1,max2,max3]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;max1:</span><br><span class="line">                max3 = max2 <span class="comment"># 注意顺序</span></span><br><span class="line">                max2 = max1</span><br><span class="line">                max1 = i <span class="comment"># 注意修改的值放最后</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;max2:</span><br><span class="line">                max3 = max2</span><br><span class="line">                max2 = i</span><br><span class="line">            <span class="keyword">elif</span> i&gt;max3:</span><br><span class="line">                max3 = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> max3==float(<span class="string">'-inf'</span>):</span><br><span class="line">            <span class="keyword">return</span> max1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max3</span><br></pre></td></tr></table></figure><h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:<br>输入:<br>[4,3,2,7,8,2,3,1]<br>输出:<br>[5,6]</p><p><strong>解题思路：</strong><br>因为长度和给定数组范围一致，所以可以通过对数组中各元素所代表的下标进行标负，进行元素缺失的确认，遍历完之后剩下的正元素下标即为缺失元素，注意需要使用绝对值，因为有可能出现重复的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            nums[abs(i)<span class="number">-1</span>] = -abs(nums[abs(i)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> [k+<span class="number">1</span> <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> v&gt;<span class="number">0</span> ]</span><br></pre></td></tr></table></figure><h2 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a>485. 最大连续1的个数</h2><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><p>示例 1:<br>输入: [1,1,0,1,1,1]<br>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</p><p>注意：<br>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p><p><strong>解题思路：</strong><br>确定nums数组中各个0点的位置，之后进行相邻值求差，得到最大值即为最长1个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index0 = [<span class="number">-1</span>]+[k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> v==<span class="number">0</span>]+[len(nums)]</span><br><span class="line">        length_list = [index0[i+<span class="number">1</span>]-index0[i]<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(index0)<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">return</span> max(length_list)</span><br></pre></td></tr></table></figure><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。</p><p>示例 1：<br>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</p><p>示例 2：<br>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</p><p>示例 3：<br>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</p><p>提示：<br>0 ≤ N ≤ 30</p><p><strong>解题思路：</strong><br>基于表达式进行推导，每次只保留前两个数，基于这两个数生成新的数，之后对这两个数进行更新，以此类推。<br>f(n+2) = f(n) + f(n+1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> N&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            before = <span class="number">1</span></span><br><span class="line">            after = <span class="number">1</span></span><br><span class="line">            n = <span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> n&lt;=N:</span><br><span class="line">                before, after = after, before+after</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a>532. 数组中的K-diff数对</h2><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p><p>示例 1:<br>输入: [3, 1, 4, 1, 5], k = 2<br>输出: 2<br>解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。<br>尽管数组中有两个1，但我们只应返回不同的数对的数量。</p><p>示例 2:<br>输入:[1, 2, 3, 4, 5], k = 1<br>输出: 4<br>解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</p><p>示例 3:<br>输入: [1, 3, 1, 5, 4], k = 0<br>输出: 1<br>解释: 数组中只有一个 0-diff 数对，(1, 1)。</p><p>注意:<br>数对 (i, j) 和数对 (j, i) 被算作同一数对。<br>数组的长度不超过10,000。<br>所有输入的整数的范围在 [-1e7, 1e7]。</p><p><strong>解题思路:</strong><br>这个题目主要的难度在于对题目的解读，其实根据k分成不同情况即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>: <span class="comment"># 意外情况返回0</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">elif</span> k==<span class="number">0</span>: <span class="comment"># 0-diff只需要统计出现次数大于1的数字即可</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> adic.items():</span><br><span class="line">                <span class="keyword">if</span> v&gt;<span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 其余的只需要查看i-k是否在adic中即可,注意不用绝对只是因为(i,j)(j,i)算1对</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">if</span> i-k <span class="keyword">in</span> adic:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h2 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a>561. 数组拆分 I</h2><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p>示例 1:<br>输入: [1,4,3,2]<br>输出: 4<br>解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p><p>提示:<br>n 是正整数,范围在 [1, 10000].<br>数组中的元素范围在 [-10000, 10000].</p><p><strong>解题思路：</strong><br>要是想两对两对数的最小值的和最大，其实从最大的两对数进行推演，如果在nums上找到两个数组成的对，使得这个对的最小值最大，那么一定是整个数组中的最大数以及第二大数，之后再确定剩下数组中数对最小值最大，那么其实就是整个数组的第三大数以及第四大数组成的数对，以此类推，总结起来其实就是对数组排序，同时找到下标为偶数的数字的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrayPairSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = sum([v <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(sorted(nums)) <span class="keyword">if</span> k%<span class="number">2</span>==<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p><strong>解题思路：</strong><br>链表结构进行解题(没掌握好)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = ret</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val&gt;=l2.val:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            cur = cur.next <span class="comment"># 记得向后推</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next=l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            cur.next=l2</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p><p>示例 2:<br>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p><strong>解题思路:</strong><br>链表结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        ret = head <span class="comment"># 注意python变量名都是引用!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.next:</span><br><span class="line">            <span class="keyword">while</span> head.next <span class="keyword">and</span> head.val==head.next.val:</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a>566. 重塑矩阵</h2><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p>示例 1:<br>输入:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br>输出:<br>[[1,2,3,4]]<br>解释:<br>行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</p><p>示例 2:<br>输入:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br>输出:<br>[[1,2],<br> [3,4]]<br>解释:<br>没有办法将 2 <em> 2 矩阵转化为 2 </em> 4 矩阵。 所以输出原矩阵。</p><p>注意：<br>给定矩阵的宽和高范围在 [1, 100]。<br>给定的 r 和 c 都是正数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span><span class="params">(self, nums, r, c)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[List[int]]</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> r*c!=len(nums)*len(nums[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = []</span><br><span class="line">            new = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                    tmp.append(j)</span><br><span class="line">                    <span class="keyword">if</span> len(tmp)==c:</span><br><span class="line">                        new.append(tmp)</span><br><span class="line">                        tmp = []</span><br><span class="line">            <span class="keyword">return</span> new</span><br></pre></td></tr></table></figure><h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:<br>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p><p>说明 :<br>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p><p><strong>解题思路</strong><br>就是排序前后数据进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(sorted(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[k]!=v:</span><br><span class="line">                alist.append(k)</span><br><span class="line">        <span class="keyword">if</span> len(alist)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(alist) - min(alist) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p><strong>解题思路：</strong><br>利用快慢指针，如果有环快指针一定会在某个时刻与慢指针相遇，否则快指针为空</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> head.next.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow = head.next</span><br><span class="line">        fast = head.next.next</span><br><span class="line">        <span class="keyword">while</span> slow!=fast <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：<br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：<br>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p><strong>解题思路：</strong><br>判断两个链表长度，将较长的链表移动到与短链表相差的长度位置，进行遍历，如果两个链表相同返回当前链表，否则返回None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1,l2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        l1node,l2node = headA,headB</span><br><span class="line">        <span class="keyword">while</span> l1node:</span><br><span class="line">            l1 += <span class="number">1</span></span><br><span class="line">            l1node = l1node.next</span><br><span class="line">        <span class="keyword">while</span> l2node:</span><br><span class="line">            l2 += <span class="number">1</span></span><br><span class="line">            l2node = l2node.next</span><br><span class="line">        <span class="keyword">if</span> l1&gt;l2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1-l2):</span><br><span class="line">                headA = headA.next</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l2-l1):</span><br><span class="line">                headB = headB.next</span><br><span class="line">        <span class="keyword">while</span> headA!=headB:</span><br><span class="line">            headA,headB = headA.next,headB.next </span><br><span class="line">        <span class="keyword">if</span> headA:</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:<br>输入: flowerbed = [1,0,0,0,1], n = 1<br>输出: True</p><p>示例 2:<br>输入: flowerbed = [1,0,0,0,1], n = 2<br>输出: False</p><p>注意:<br>数组内已种好的花不会违反种植规则。<br>输入的数组长度范围为 [1, 20000]。<br>n 是非负整数，且不会超过输入数组的大小。<br>在真实的面试中遇到过这道题？</p><p><strong>解题思路：</strong><br>头尾加一个0，然后找三个连续的0出现的次数大于n即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type flowerbed: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_list = [<span class="number">0</span>]+flowerbed+[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(new_list)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> new_list[i]==<span class="number">0</span> <span class="keyword">and</span> new_list[i<span class="number">-1</span>]==<span class="number">0</span> <span class="keyword">and</span> new_list[i+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                new_list[i] = <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=n</span><br></pre></td></tr></table></figure><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>删除链表中等于给定值 val 的所有节点。</p><p>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p><strong>解题思路：</strong><br>转化为数组，再重新构建链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val != val:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>反转一个单链表。</p><p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><strong>解题思路：</strong><br>将链表转化成list，在进行反转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val==<span class="number">0</span>:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            <span class="keyword">if</span> head.val:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist[::<span class="number">-1</span>]:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:<br>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p>示例 2:<br>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p><strong>解题思路：</strong><br>典型的动态规划问题，dp[i] = max(dp[i-1], dp[i-2]+a[i])<br>所以只需要保存前两天的记录就能根据当天的记录计算当前最大收益，初始的两天算0即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        before = <span class="number">0</span></span><br><span class="line">        after = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            before,after = after, max(before+i, after)</span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例:<br>输入: 19<br>输出: true<br>解释:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p><p><strong>解题思路：</strong><br>对不是快乐数的进行储存判断(有可能重复)，对是的返回true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> alist:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist.append(n)</span><br><span class="line">            tmp = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> str(n):</span><br><span class="line">                tmp += int(i)**<span class="number">2</span></span><br><span class="line">            n = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p>统计所有小于非负整数 n 的质数的数量。</p><p>示例:<br>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><p><strong>解题思路：</strong><br>对于每个位置赋1，如果是质数就就对其平方之后的所有间隔为本数的赋值为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prime = [<span class="number">1</span>]*n</span><br><span class="line">        prime[:<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prime[i]==<span class="number">1</span>:</span><br><span class="line">                prime[i*i:n:i]=[<span class="number">0</span>]*len(prime[i*i:n:i])</span><br><span class="line">        <span class="keyword">return</span> sum(prime)</span><br></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p><p>示例 1:<br>输入: 1-&gt;2<br>输出: false</p><p>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p><p><strong>解题思路：</strong><br>转成list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> alist==alist[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:<br>输入: [1,2,3]<br>输出: 6</p><p>示例 2:<br>输入: [1,2,3,4]<br>输出: 24</p><p><strong>解题思路：</strong><br>最大的三个数乘积以及最小两个数乘积与最大数乘积比较选择大的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sort_list = sorted(nums)</span><br><span class="line">        <span class="keyword">return</span> max(sort_list[<span class="number">-1</span>]*sort_list[<span class="number">-2</span>]*sort_list[<span class="number">-3</span>], sort_list[<span class="number">0</span>]*sort_list[<span class="number">1</span>]*sort_list[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>示例 1:<br>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p>示例 2:<br>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>说明:<br>链表至少包含两个节点。<br>链表中所有节点的值都是唯一的。<br>给定的节点为非末尾节点并且一定是链表中的一个有效节点。<br>不要从你的函数中返回任何结果。</p><p><strong>解题思路：</strong><br>注意只有当前要删节点的访问权限，所以直接删除就好。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure><h2 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例 1:<br>输入: [1,12,-5,-6,50,3], k = 4<br>输出: 12.75<br>解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p><p>注意:<br>1 &lt;= k &lt;= n &lt;= 30,000。<br>所给数据范围 [-10,000，10,000]。</p><p><strong>解题思路：</strong><br>计算的时候需要主要不能重复计算否则超时，可以使用减去头加上尾的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                mean_val = sum(nums[i:i+k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mean_val = mean_val-nums[i<span class="number">-1</span>]+nums[i+k<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> mean_val&gt;ret:</span><br><span class="line">                ret = mean_val</span><br><span class="line">        <span class="keyword">return</span> ret*<span class="number">1.0</span>/k</span><br></pre></td></tr></table></figure><h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：<br>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p><p>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：<br>给定链表的结点数介于 1 和 100 之间。</p><p><strong>解题思路：</strong><br>借助列表即可完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist[len(alist)/<span class="number">2</span>:]:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><h2 id="876"><a href="#876" class="headerlink" title="876"></a>876</h2><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br>输入: “III”<br>输出: 3</p><p>示例 2:<br>输入: “IV”<br>输出: 4</p><p>示例 3:<br>输入: “IX”<br>输出: 9</p><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><p><strong>解题思路：</strong><br>从后向前遍历，如果小于前一个就加，如果大于前一个就减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>,&#125;</span><br><span class="line">        revs = s[::<span class="number">-1</span>]</span><br><span class="line">        numsum = adic[revs[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(revs[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">if</span> adic[v]&gt;=adic[revs[i]]:</span><br><span class="line">                numsum += adic[v]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numsum -= adic[v]</span><br><span class="line">        <span class="keyword">return</span> numsum</span><br></pre></td></tr></table></figure><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p><p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><p><strong>解题思路：</strong><br>注意这里”前缀”这个描述，之后利用python的转置即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(i))==<span class="number">1</span>:</span><br><span class="line">                ret += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="661-图片平滑器"><a href="#661-图片平滑器" class="headerlink" title="661. 图片平滑器"></a>661. 图片平滑器</h2><p>包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p><p>示例 1:<br>输入:<br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br>输出:<br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]</p><p>解释:<br>对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0<br>对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0<br>对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0</p><p>注意:<br>给定矩阵中的整数范围为 [0, 255]。<br>矩阵的长和宽的范围均为 [1, 150]。</p><p><strong>解题思路：</strong><br>就是很简单的遍历，没啥特点，先确定左上角位置坐标以及右下角坐标，然后注意和数组的边界的关系，求均值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">imageSmoother</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row = len(M)</span><br><span class="line">        col = len(M[<span class="number">0</span>])</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                left = [max(i<span class="number">-1</span>,<span class="number">0</span>),max(j<span class="number">-1</span>,<span class="number">0</span>)] <span class="comment"># 左上角坐标</span></span><br><span class="line">                right = [min(i+<span class="number">1</span>,row<span class="number">-1</span>),min(j+<span class="number">1</span>,col<span class="number">-1</span>)] <span class="comment"># 右下角坐标</span></span><br><span class="line">                sum_val = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 遍历需要平滑位置的数值</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> range(left[<span class="number">0</span>],right[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> q <span class="keyword">in</span> range(left[<span class="number">1</span>],right[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># print p,q</span></span><br><span class="line">                        sum_val += M[p][q]</span><br><span class="line">                <span class="comment"># 根据窗口的形状求均值</span></span><br><span class="line">                avg_val = sum_val/((right[<span class="number">0</span>]+<span class="number">1</span>-left[<span class="number">0</span>])*(right[<span class="number">1</span>]+<span class="number">1</span>-left[<span class="number">1</span>]))</span><br><span class="line">                tmp.append(avg_val)</span><br><span class="line">            ret.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br>输入: “()”<br>输出: true</p><p>示例 2:<br>输入: “()[]{}”<br>输出: true</p><p>示例 3:<br>输入: “(]”<br>输出: false</p><p>示例 4:<br>输入: “([)]”<br>输出: false</p><p>示例 5:<br>输入: “{[]}”<br>输出: true</p><p><strong>解题思路:</strong><br>利用栈进行操作，如果是左边的括号就压进去，右边的就弹出，判断最后是否为空即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;<span class="string">'('</span>:<span class="string">')'</span>, <span class="string">'['</span>:<span class="string">']'</span>, <span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                alist.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> alist) <span class="keyword">or</span> adic[alist.pop()]!=i:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> alist:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>##28. 实现strStr()</p><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p><p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>说明:</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><p><strong>解题思路：</strong><br>直接判断就可以了，没什么技巧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lenN = len(needle)</span><br><span class="line">        lenH = len(haystack)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenH-lenN+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+lenN]==needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h2><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。<br>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p><p>示例 1:<br>输入: [4,2,3]<br>输出: True<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</p><p>示例 2:<br>输入: [4,2,1]<br>输出: False<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<br>说明:  n 的范围为 [1, 10,000]。</p><p><strong>解题思路：</strong><br>其实就是遇到nums[i]&gt;nums[i+1]时，修改nums[i]还是nums[i+1]，如果在头上修改nums[i]，再根据i-1，i+1判断修改哪个值，i-1&gt;i+1时修改i+1(不能保证i+1不变所以只能修改这个元素)，否则修改i-1保持i+1不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                    nums[i] = nums[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[i<span class="number">-1</span>]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                        nums[i+<span class="number">1</span>] = nums[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        nums[i] = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cnt&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h2><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><ol><li>1</li><li>11</li><li>21</li><li>1211</li><li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li></ol><p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p><p>注意：整数顺序将表示为一个字符串。</p><p>示例 1:<br>输入: 1<br>输出: “1”</p><p>示例 2:<br>输入: 4<br>输出: “1211”</p><p><strong>解题思路：</strong><br>只要保留上一次的值就可以长生出当前值，需要有几个变量记录，i当前正整数，val，cnt使用来统计数字的值以及个数的(转化成字符串统计)，strNum当前的报数值。说白了这道题就是一个统计数字的题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        pre = <span class="string">'1'</span> <span class="comment"># 用来记录之前时刻的数字，用来推断下一个数字</span></span><br><span class="line">        i = <span class="number">1</span> <span class="comment"># 当前数字值</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            val = pre[<span class="number">0</span>] <span class="comment"># 当前的值</span></span><br><span class="line">            cnt = <span class="number">0</span> <span class="comment"># 当前值的个数</span></span><br><span class="line">            strNum = <span class="string">''</span> <span class="comment"># 产生出来的数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> pre:</span><br><span class="line">                <span class="keyword">if</span> j==val:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    strNum += str(cnt)+val <span class="comment"># 拼接</span></span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">                    val = j</span><br><span class="line">            strNum += str(cnt)+val</span><br><span class="line">            pre = strNum</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p><p>示例:<br>输入: “Hello World”<br>输出: 5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(s.strip().split(<span class="string">' '</span>)[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><p>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 3<br>解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 </p><p>示例 2:<br>输入: [2,2,2,2,2]<br>输出: 1<br>解释: 最长连续递增序列是 [2], 长度为1。<br>注意：数组长度不会超过10000。</p><p><strong>解题思路：</strong><br>首先肯定是要设置滑动窗口的，比较nums[i]和nums[i+1]的值的大小，同时设置两个变量本别记录当前最大子序列长度，和全局最大子序列长度，每次先判断是否nums[i]&lt;nums[i+1]，如果为真，当前的长度+1也就是tmp+1，同时跟全剧最长子序列比较如果大于全局就更新，如果nums[i]&gt;=nums[i+1]，则重置当前子序列长度即可。注意序列为空的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = <span class="number">1</span> <span class="comment"># 存储当前的升序值</span></span><br><span class="line">        ret = <span class="number">1</span> <span class="comment"># 储存最大的升序值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> tmp&gt;ret:</span><br><span class="line">                ret = tmp</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。<br>输入为非空字符串且只包含数字 1 和 0。</p><p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p><p>示例 2:<br>输入: a = “1010”, b = “1011”<br>输出: “10101”</p><p><strong>解题思路：</strong><br>bin十进制转二进制，int将字符串转化为十进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bin(int(a,<span class="number">2</span>)+int(b,<span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true</p><p>示例 2:<br>输入: “race a car”<br>输出: false</p><p><strong>解题思路：</strong><br>注意isalnum()的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        tmp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i.isalnum():</span><br><span class="line">                tmp += i.lower()</span><br><span class="line">        <span class="keyword">return</span> tmp==tmp[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a>697. 数组的度</h2><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。<br>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p><p>示例 1:<br>输入: [1, 2, 2, 3, 1]<br>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>最短连续子数组[2, 2]的长度为2，所以返回2.</p><p>示例 2:<br>输入: [1,2,2,3,1,4,2]<br>输出: 6</p><p>注意:<br>nums.length 在1到50,000区间范围内。<br>nums[i] 是一个在0到49,999范围内的整数。</p><p><strong>解题思路：</strong><br>利用字典进行数值个数的统计，并针对出现次数最多的数值确定初始以及末尾对应的index，通过index相减获得对应的最短子序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findShortestSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 对每个值的数量，起始index终止index进行统计</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                adic[v][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                adic[v][<span class="number">2</span>] = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[v] = [<span class="number">1</span>,k,<span class="number">-1</span>]</span><br><span class="line">        max_cnt = max(zip(*adic.values())[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 最大频数如果是1直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> max_cnt==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定最大频数并找到最短子序列长度</span></span><br><span class="line">        min_len = float(<span class="string">'Inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> adic.items():</span><br><span class="line">            <span class="keyword">if</span> v[<span class="number">0</span>]==max_cnt:</span><br><span class="line">                len_tmp = v[<span class="number">2</span>]-v[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> len_tmp&lt;min_len:</span><br><span class="line">                    min_len = len_tmp</span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><p><strong>解题思路：</strong><br>根据python指针的特性，使用双指针，一个头一个尾，调换数值顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: List[str]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[i],s[j] = s[j],s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:<br>输入: “hello”<br>输出: “holle”</p><p>示例 2:<br>输入: “leetcode”<br>输出: “leotcede”<br>说明:<br>元音字母不包含字母”y”。</p><p><strong>解题思路：</strong><br>其实跟反转字符串是一个套路，双指针即可，唯一需要注意的是需要对元音字母进行判断,注意转化成list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j=<span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        s_list = list(s)</span><br><span class="line">        alp = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>] <span class="comment"># 注意大写</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">if</span> s_list[i] <span class="keyword">in</span> alp:</span><br><span class="line">                <span class="keyword">if</span> s_list[j] <span class="keyword">in</span> alp:</span><br><span class="line">                    s_list[i],s_list[j] = s_list[j],s_list[i]</span><br><span class="line">                    i += <span class="number">1</span> <span class="comment"># 记得换位置啊</span></span><br><span class="line">                    j -= <span class="number">1</span> <span class="comment"># 记得换位置啊</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s_list)</span><br></pre></td></tr></table></figure><h2 id="717-1比特与2比特字符"><a href="#717-1比特与2比特字符" class="headerlink" title="717. 1比特与2比特字符"></a>717. 1比特与2比特字符</h2><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。<br>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p>示例 1:<br>输入:<br>bits = [1, 0, 0]<br>输出: True<br>解释:<br>唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</p><p>示例 2:<br>输入:<br>bits = [1, 1, 1, 0]<br>输出: False<br>解释:<br>唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</p><p><strong>解题思路：</strong><br>因为list只由0，10/11组成，观察特点，10/11都是以1开头，0是以0开头，因此正向遍历，遇到1跳两个格，因为只能在10/11中且长度为2，遇到0则跳一个格，因为0长度只能是1，最后看指针所指位置，如果是最后一次指针加了2那么说明不是以单个0结尾，否则就是以单个0结尾的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOneBitCharacter</span><span class="params">(self, bits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(bits):</span><br><span class="line">            <span class="keyword">if</span> bits[i]==<span class="number">1</span>:</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                ret = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                ret = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</p><p>注意：<br>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p><strong>解题思路:</strong><br>这个题的意思是：你要从magazine里面找字母，ransomNote中的每个字母都包含在magazine里面，且个数要小于magazine这个里面的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote, magazine)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ransomNote: str</span></span><br><span class="line"><span class="string">        :type magazine: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic1 = &#123;&#125;;adic2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic1:</span><br><span class="line">                adic1[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic1[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic2:</span><br><span class="line">                adic2[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic2[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> adic1.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> adic2 <span class="keyword">and</span> v&lt;=adic2[k]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>案例:<br>s = “leetcode”<br>返回 0.</p><p>s = “loveleetcode”,<br>返回 2.</p><p><strong>解题思路</strong><br>利用两个list，一个存储uniq字符，一个存储dup字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        uniq = []</span><br><span class="line">        dup = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> uniq:</span><br><span class="line">                uniq.remove(i)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dup:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dup.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dup:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uniq.append(i)</span><br><span class="line">        <span class="keyword">if</span> uniq:</span><br><span class="line">            <span class="keyword">return</span> s.index(uniq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a>724. 寻找数组的中心索引</h2><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。<br>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>示例 1:<br>输入:<br>nums = [1, 7, 3, 6, 5, 6]<br>输出: 3<br>解释:<br>索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。<br>同时, 3 也是第一个符合要求的中心索引。</p><p>示例 2:<br>输入:<br>nums = [1, 2, 3]<br>输出: -1<br>解释:<br>数组中不存在满足此条件的中心索引。<br>说明:</p><p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p><p><strong>解题思路：</strong><br>先对list求和，之后对list进行遍历，每次遍历都对前半部分进行累加，并通过总和减去前半部分以及当前遍历值求解后半部分值，进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        sum_val = sum(nums)</span><br><span class="line">        before = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> before==sum_val-before-v:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            before = before+v</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="…"><a href="#…" class="headerlink" title="…."></a>….</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        三数之和的解题思路：</span></span><br><span class="line"><span class="string">        首先对数组进行排序，之后对数字进行遍历，在遍历过程中如果是第一个或者当前的数字与之前的不相等进行判断，start和end分别是下一节点以及最后节点</span></span><br><span class="line"><span class="string">        start&lt;end进行while循环，如果两个游标以及当前数字之和为0，添加结果，同时两个游标同时更新，下一步跳过相同的</span></span><br><span class="line"><span class="string">        如果不相等的话要么跟新左游标要么右游标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        ret = []<span class="comment"># 记录结果</span></span><br><span class="line">        nums = sorted(nums) <span class="comment"># 一定要排序</span></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            start,end = i+<span class="number">1</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> nums[i]&gt;nums[i<span class="number">-1</span>]:<span class="comment"># 跳过相同的</span></span><br><span class="line">                <span class="keyword">while</span> start&lt;end:</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[start]+nums[end]==<span class="number">0</span>:</span><br><span class="line">                        ret.append([nums[i],nums[start],nums[end]])</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[start]==nums[start<span class="number">-1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            start += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end+<span class="number">1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i]+nums[start]+nums[end]&gt;<span class="number">0</span>:</span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h1 id="Leetcode-Hot100"><a href="#Leetcode-Hot100" class="headerlink" title="Leetcode Hot100"></a>Leetcode Hot100</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">使用遍历，结合字典，记录每次target-val对应的值，如果遍历的值在其中，直接输出即可</span><br></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">遍历链表，得到数字进行int转换，进行运算，同时在构造新的链表</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">初始化start和最长值为<span class="number">0</span>，之后遍历整个数组，如果字符出现在之前的字符串中，start就+<span class="number">1</span>，然后得到相应的长度，和最大值比较进行更新即可</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</span><br><span class="line">请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</span><br><span class="line">你可以假设 nums1 和 nums2 不会同时为空。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用归并，对数组进行排序，得到新的数组之后再跟据长度求解相应的中位数</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 <span class="number">1000</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">中心扩增法，遍历每个字符，使用辅助函数，使之以其idx-idx或者idx-idx+<span class="number">1</span>进行查看回文，返回最大值，之后奇偶最大长度比较同时跟当前最大长度比较，进行字符串更新</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, <span class="number">0</span>)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line">说明：你不能倾斜容器，且 n 的值至少为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">双指针，给定left=<span class="number">0</span>，right=len(s)<span class="number">-1</span>，maxarea=(right-left)*min(left,right)，之后<span class="keyword">while</span>循环如果left&lt;right，如果left低那么left+<span class="number">1</span>否则right<span class="number">-1</span>，不断计算更新最大面积</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = <span class="number">0</span> ？找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        三数之和的解题思路：</span></span><br><span class="line"><span class="string">        首先对数组进行排序，之后对数字进行遍历，在遍历过程中如果是第一个或者当前的数字与之前的不相等进行判断，start和end分别是下一节点以及最后节点</span></span><br><span class="line"><span class="string">        start&lt;end进行while循环，如果两个游标以及当前数字之和为0，添加结果，同时两个游标同时更新，下一步跳过相同的</span></span><br><span class="line"><span class="string">        如果不相等的话要么跟新左游标要么右游标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        ret = []<span class="comment"># 记录结果</span></span><br><span class="line">        nums = sorted(nums) <span class="comment"># 一定要排序</span></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            start,end = i+<span class="number">1</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> nums[i]&gt;nums[i<span class="number">-1</span>]:<span class="comment"># 跳过相同的</span></span><br><span class="line">                <span class="keyword">while</span> start&lt;end:</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[start]+nums[end]==<span class="number">0</span>:</span><br><span class="line">                        ret.append([nums[i],nums[start],nums[end]])</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[start]==nums[start<span class="number">-1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            start += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end+<span class="number">1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i]+nums[start]+nums[end]&gt;<span class="number">0</span>:</span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给定一个仅包含数字 <span class="number">2</span><span class="number">-9</span> 的字符串，返回所有它能表示的字母组合。</span><br><span class="line">给出数字到字母的映射如下（与电话按键相同）。注意 <span class="number">1</span> 不对应任何字母。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">对于每个数字建立字典，然后对每个数字的多个字符进行遍历，将之前得到的字符串与之相加，并重新赋值，不断这样循环</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        adic = &#123;<span class="string">'2'</span>:<span class="string">'abc'</span>, <span class="string">'3'</span>:<span class="string">'def'</span>, <span class="string">'4'</span>:<span class="string">'ghi'</span>, <span class="string">'5'</span>:<span class="string">'jkl'</span>, <span class="string">'6'</span>:<span class="string">'mno'</span>, \</span><br><span class="line">                <span class="string">'7'</span>:<span class="string">'pqrs'</span>, <span class="string">'8'</span>:<span class="string">'tuv'</span>,<span class="string">'9'</span>:<span class="string">'wxyz'</span>&#125;</span><br><span class="line">        ret = [<span class="string">''</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> ret: <span class="comment"># 依次循环上次得到的list</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> list(adic[i]): <span class="comment"># 之前元素加上新的元素</span></span><br><span class="line">                    tmp.append(j + k)</span><br><span class="line">            ret = tmp <span class="comment"># 更新列表</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span><br><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">设置快慢指针，快指针先走n，然后慢指针快指针同时走，当快指针next是空时，将慢指针next跳一个，返回结果</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 <span class="string">'('</span>，<span class="string">')'</span>，<span class="string">'&#123;'</span>，<span class="string">'&#125;'</span>，<span class="string">'['</span>，<span class="string">']'</span> 的字符串，判断字符串是否有效。</span><br><span class="line">有效字符串需满足：</span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line">注意空字符串可被认为是有效字符串。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用栈实现，对字符串进行遍历，如果是左括号，那么需要压栈，如果是右括号的话就弹栈比较，如果不匹配就false，如果最后栈不空false否则true</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</span><br><span class="line"></span><br><span class="line">例如，给出 n = <span class="number">3</span>，生成结果为：</span><br><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用动态规划方法，对于当前括号的值可以遍历上一次括号中的所有值，并在每个空位都进行插入，返回去重后的结果</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'()'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i=<span class="number">2</span></span><br><span class="line">            before=[<span class="string">'()'</span>]</span><br><span class="line">            <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">                after = []</span><br><span class="line">                <span class="keyword">for</span> st <span class="keyword">in</span> before:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(st)):</span><br><span class="line">                        after.append(st[:k]+<span class="string">'()'</span>+st[k:])</span><br><span class="line">                after = list(set(after))</span><br><span class="line">                before = after</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">将所有链表中的值合并到一个list中进行排序，然后排好序之后，重新组织进行输出</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                self.nodes.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> sorted(self.nodes):</span><br><span class="line">            point.next = ListNode(x)</span><br><span class="line">            point = point.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">这里不使用回溯法，相反的使用一个较为简单的方式，即动态规划，每次对列表进行遍历，然后，对之前的列表在不同位置进行插入当前元素，之后更新之前元素，不断轮回即可</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = [[nums[<span class="number">0</span>]]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">                after = []</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> pre:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,len(j)+<span class="number">1</span>):</span><br><span class="line">                        after.append(j[:k]+[i]+j[k:])</span><br><span class="line">                pre = after</span><br><span class="line">            <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">使用辅助函数判断当前的括号是否为有效括号，然后选定偶数括号，一一进行判断，找到最长的即可</span><br></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line">( 例如，数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 可能变为 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] )。</span><br><span class="line">搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <span class="number">-1</span> 。</span><br><span class="line">你可以假设数组中不存在重复的元素。</span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line">直接二分进行查找，只不过判断的时候需要分情况进行考虑</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">'''解题思路：</span></span><br><span class="line"><span class="string">        直接使用二分查找，需要判断边界，进而重新界定left和right</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left,right = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;=nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left]&lt;=target&lt;nums[mid]:</span><br><span class="line">                    right = mid<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target&lt;=nums[right]:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> nums[left]==target <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">找到相应的头以及尾部位置，然后进行range的求取</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">            l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                m = l+(r-l)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m]&gt;target:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[m]&lt;target:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">or</span> (m&gt;<span class="number">0</span> <span class="keyword">and</span> nums[m<span class="number">-1</span>]!=nums[m]):</span><br><span class="line">                        <span class="keyword">return</span> m</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = m<span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">last</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">            l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                m = l+(r-l)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m]&gt;target:</span><br><span class="line">                    r = m<span class="number">-1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[m]&lt;target:</span><br><span class="line">                    l = m+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> (m==len(nums)<span class="number">-1</span>) <span class="keyword">or</span> (m&lt;len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[m]!=nums[m+<span class="number">1</span>]):</span><br><span class="line">                        <span class="keyword">return</span> m</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        s = first(nums, target)</span><br><span class="line">        e = last(nums, target)</span><br><span class="line">        <span class="keyword">return</span> [s,e] <span class="keyword">if</span> nums[s]==target <span class="keyword">else</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">只要把数组先进行转置，在对每行求逆即可</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row,col = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,col):</span><br><span class="line">                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            matrix[i] = matrix[i][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用sorted tuple以及字典进行记录，最后返回values</span><br></pre></td></tr></table></figure><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用递归，注意对n的符号进行判断</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line">判断你是否能够到达最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: true</span><br><span class="line">解释: 从位置 <span class="number">0</span> 到 <span class="number">1</span> 跳 <span class="number">1</span> 步, 然后跳 <span class="number">3</span> 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用贪心算法+动态规划算法，从后向前设置start、end，如果start+nums[start]就更新end，同时每次start都更新，最后查看是否end为<span class="number">0</span>，如果为<span class="number">0</span>说明可以从<span class="number">0</span>开始跳到最后一个位置</span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span><br><span class="line"></span><br><span class="line">问总共有多少条不同的路径？</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">动态规划，dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>]+[<span class="number">0</span>]*(n<span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给定一个 m x n 的矩阵，如果一个元素为 <span class="number">0</span>，则将其所在行和列的所有元素都设为 <span class="number">0</span>。请使用原地算法。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">对<span class="number">0</span>进行记录，使用set进行记录，在此遍历元素，如果行列在里面就直接置为<span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row,col = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        rows=set()</span><br><span class="line">        cols=set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="number">0</span>:</span><br><span class="line">                    rows.add(i)</span><br><span class="line">                    cols.add(j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">动态规划，每增加一个元素其实就是原来list基础上再加上对所有list元素+新的值 产生的list</span><br></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">跟之前的路径搜索一样，回溯，设定state以及路径长度，进行拟合</span><br></pre></td></tr></table></figure><h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">一条包含字母 A-Z 的消息通过以下方式进行了编码：</span><br><span class="line"></span><br><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br><span class="line">给定一个只包含数字的非空字符串，请计算解码方法的总数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"12"</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"226"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">动态规划，起始点是<span class="number">1</span>/看本身是否为<span class="number">0</span>来确定，然后不断更新即可，如果两个字母成立就加before如果一个字母成立就加after</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">递归+非递归</span><br><span class="line">非递归，自己写的栈，再加一个cur指针，<span class="keyword">while</span>栈和指针不空，<span class="keyword">while</span>指针不空，就不断左节点遍历，然后弹栈输出值</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="comment">#       递归</span></span><br><span class="line"><span class="comment">#        if not root:</span></span><br><span class="line"><span class="comment">#            return []</span></span><br><span class="line"><span class="comment">#        ret = []</span></span><br><span class="line"><span class="comment">#        ret += self.inorderTraversal(root.left)</span></span><br><span class="line"><span class="comment">#        ret.append(root.val)</span></span><br><span class="line"><span class="comment">#        ret += self.inorderTraversal(root.right)</span></span><br><span class="line"><span class="comment">#        return ret</span></span><br><span class="line"><span class="comment">#       非递归</span></span><br><span class="line">        ret = []</span><br><span class="line">        stack = []</span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            ret.append(tmp.val)</span><br><span class="line">            p = tmp.right</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">对于二叉搜索树来说，中序遍历是有序的，可以通过中序遍历结果查看是否有序进行判断</span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a>102. 二叉树的层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">参见剑指offer</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack = [root]</span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                tmp = []</span><br><span class="line">                length = len(stack)</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                    cur = stack.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        stack.append(cur.left)</span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        stack.append(cur.right)</span><br><span class="line">                    tmp.append(cur.val)</span><br><span class="line">                ret.append(tmp)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a>103. 二叉树的锯齿形层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">在层次遍历的基础上加一个flag判断行数即可</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">跟剑指offer思路一致</span><br></pre></td></tr></table></figure><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">依旧是层次遍历的变体，只需要记录每一层的节点数，同时再加上next指针即可，同时不断进行每一层的更新</span><br></pre></td></tr></table></figure><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</span><br><span class="line"></span><br><span class="line">每次转换只能改变一个字母。</span><br><span class="line">转换过程中的中间单词必须是字典中的单词。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">如果不存在这样的转换序列，返回 <span class="number">0</span>。</span><br><span class="line">所有单词具有相同的长度。</span><br><span class="line">所有单词只由小写字母组成。</span><br><span class="line">字典中不存在重复的单词。</span><br><span class="line">你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",</span><br><span class="line">     返回它的长度 <span class="number">5</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用广度优先搜索，找最短路径，每一层是上一层可以变化的字符串同时要在字符串list中，不断遍历，找到短值</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            set_words = set(wordList)</span><br><span class="line">            stack = [beginWord]</span><br><span class="line">            nextstack = []</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> word==endWord:</span><br><span class="line">                        <span class="keyword">return</span> length</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                                newword = word[:i]+j+word[(i+<span class="number">1</span>):]</span><br><span class="line">                                <span class="keyword">if</span> newword <span class="keyword">in</span> set_words:</span><br><span class="line">                                    set_words.remove(newword)</span><br><span class="line">                                    nextstack.append(newword)</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                stack = nextstack</span><br><span class="line">                nextstack = []</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维的矩阵，包含 <span class="string">'X'</span> 和 <span class="string">'O'</span>（字母 O）。</span><br><span class="line">找到所有被 <span class="string">'X'</span> 围绕的区域，并将这些区域里所有的 <span class="string">'O'</span> 用 <span class="string">'X'</span> 填充。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">转化问题，将问题转化为相应的非包裹问题，从矩阵四条边出发遍历(因为从四条边出发的一定是包不住的)，使用dfs+递归找到所有最深的包不上的路径，将这些路径标记为<span class="comment">#，然后对所有元素进行遍历，如果是#则转化为O，如果是O，转化为X</span></span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</span><br><span class="line"></span><br><span class="line">返回 s 所有可能的分割方案。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"aab"</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">回溯法+递归，设置help函数，给定start以及存储结果的list，对于list每个元素进行遍历，作为end，如果start到end是回文数，加入ret同时递归查找，终止条件是start&gt;=字符串长度，则找到一条，加入真正结果list中</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = []</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">getstr</span><span class="params">(string, start, ret=[])</span>:</span></span><br><span class="line">                <span class="keyword">if</span> start&gt;=len(string):</span><br><span class="line">                    <span class="keyword">return</span> result.append(ret)</span><br><span class="line">                <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>,len(string)+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> string[start:end]==string[start:end][::<span class="number">-1</span>]:</span><br><span class="line">                        getstr(string, end, ret+[string[start:end]])</span><br><span class="line">            getstr(s, <span class="number">0</span>, ret=[])</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span><br><span class="line"></span><br><span class="line">你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+<span class="number">1</span> 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</span><br><span class="line"></span><br><span class="line">如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">说明: </span><br><span class="line"></span><br><span class="line">如果题目有解，该答案即为唯一答案。</span><br><span class="line">输入数组均为非空数组，且长度相同。</span><br><span class="line">输入数组中的元素均为非负数。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">遍历，如果cur&lt;<span class="number">0</span>就更新，否则一直下去</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur,total=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            cur += gas[i]-cost[i]</span><br><span class="line">            total += gas[i]-cost[i]</span><br><span class="line">            <span class="keyword">if</span> cur&lt;<span class="number">0</span>:</span><br><span class="line">                start = i+<span class="number">1</span>;cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> total&lt;<span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure><h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a>138. 复制带随机指针的链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</span><br><span class="line">要求返回这个链表的深拷贝。 </span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用三步法进行链表的复制，但是注意如果random节点存在的时候才能copy</span><br></pre></td></tr></table></figure><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">拆分时可以重复使用字典中的单词。</span><br><span class="line">你可以假设字典中没有重复的单词。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"leetcode"</span>, wordDict = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用动态规划，start从头开始遍历，end从start+<span class="number">1</span>开始遍历，初始化一个flag list存储当前单词状态，如果s[start:end]在worddic中，就对该下标end对应的位置设置<span class="number">1</span>，然后从值为<span class="number">1</span>的位置向后查看，如果左后为<span class="number">1</span>返回true</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = [<span class="number">1</span>]+[<span class="number">0</span>]*len(s)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> flag[start]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> end <span class="keyword">in</span> range(start+<span class="number">1</span>,len(s)+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> s[start:end] <span class="keyword">in</span> wordDict:</span><br><span class="line">                        flag[end] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> flag[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">根据逆波兰表示法，求表达式的值。</span><br><span class="line"></span><br><span class="line">有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">整数除法只保留整数部分。</span><br><span class="line">给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 <span class="number">0</span> 的情况。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]</span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: ((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">解题思路:</span><br><span class="line">使用栈，只要遇到了符号，就直接进行运算并把值压入，知道输出在后一个值</span><br></pre></td></tr></table></figure><h2 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152. 乘积最大子序列"></a>152. 乘积最大子序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">其实跟最大子序列和一样的，区别在于乘法可能正负颠倒，因此要同时记录最大最小值，如果当前值是负数，那么点到最大最小值</span><br></pre></td></tr></table></figure><h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">峰值元素是指其值大于左右相邻值的元素。</span><br><span class="line">给定一个输入数组 nums，其中 nums[i] ≠ nums[i+<span class="number">1</span>]，找到峰值元素并返回其索引。</span><br><span class="line">数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</span><br><span class="line">你可以假设 nums[<span class="number">-1</span>] = nums[n] = -∞。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">看到复杂度使用二分查找+递归，终止条件左右相等，之后如果点在上升序列中就递归右半边，否则递归左半边</span><br></pre></td></tr></table></figure><h2 id="163-缺失的区间"><a href="#163-缺失的区间" class="headerlink" title="163. 缺失的区间"></a>163. 缺失的区间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">75</span>], lower = <span class="number">0</span> 和 upper = <span class="number">99</span>,</span><br><span class="line">输出: [<span class="string">"2"</span>, <span class="string">"4-&gt;49"</span>, <span class="string">"51-&gt;74"</span>, <span class="string">"76-&gt;99"</span>]</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">主要是将最小值最大值插入到list中，在进行遍历即可</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMissingRanges</span><span class="params">(self, nums, lower, upper)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type lower: int</span></span><br><span class="line"><span class="string">        :type upper: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> lower&lt;nums[<span class="number">0</span>]:</span><br><span class="line">            nums = [lower<span class="number">-1</span>] + nums</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> upper&gt;nums[<span class="number">-1</span>]:</span><br><span class="line">            nums.append(upper+<span class="number">1</span>)</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i+<span class="number">1</span>]-nums[i]==<span class="number">2</span>:</span><br><span class="line">                ret.append(str(nums[i]+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> nums[i+<span class="number">1</span>]-nums[i]&gt;<span class="number">2</span>:</span><br><span class="line">                ret.append(str(nums[i]+<span class="number">1</span>)+<span class="string">'-&gt;'</span>+str(nums[i+<span class="number">1</span>]<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">210</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">9534330</span></span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">转化为字符转之后直接使用比较器进行比较</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums]</span><br><span class="line">        nums = sorted(nums, cmp=<span class="keyword">lambda</span> y,x:int(x+y)-int(y+x))</span><br><span class="line">        <span class="keyword">return</span> str(int(<span class="string">''</span>.join(nums)))</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">给定一个由 <span class="string">'1'</span>（陆地）和 <span class="string">'0'</span>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入:</span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用广度遍历，遍历所有点，以每个点为起始点进行bfs，然后记录个数，最后返回个数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        row = len(grid)</span><br><span class="line">        col = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> row&lt;=<span class="number">0</span> <span class="keyword">or</span> col&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        state = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(col)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> state[i][j]==<span class="number">0</span> <span class="keyword">and</span> grid[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    ret += <span class="number">1</span></span><br><span class="line">                    state[i][j] = <span class="number">1</span></span><br><span class="line">                    stack = [[i,j]]</span><br><span class="line">                    <span class="keyword">while</span> stack:</span><br><span class="line">                        cur = stack.pop(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>]]:</span><br><span class="line">                            newi = cur[<span class="number">0</span>]+k[<span class="number">0</span>];newj = cur[<span class="number">1</span>]+k[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> newi&gt;=<span class="number">0</span> <span class="keyword">and</span> newi&lt;row <span class="keyword">and</span> newj&gt;=<span class="number">0</span> <span class="keyword">and</span> newj&lt;col <span class="keyword">and</span> state[newi][newj]==<span class="number">0</span> <span class="keyword">and</span> grid[newi][newj]==<span class="string">'1'</span>:</span><br><span class="line">                                stack.append([newi,newj])</span><br><span class="line">                                state[newi][newj] = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># print state</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">现在你总共有 n 门课需要选，记为 <span class="number">0</span> 到 n<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">在选修某些课程之前需要一些先修课程。 例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示他们: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用拓扑排序的思想，需要准备入度list，邻接表，然后对于入度为<span class="number">0</span>就加入，如果遍历完了之后值和课程数相等就返回true</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 拓扑排序</span></span><br><span class="line">        <span class="comment"># 需要关于度的list/需要接临表</span></span><br><span class="line">        innode = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        nextdic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            nextdic[i] = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">            innode[i] += <span class="number">1</span></span><br><span class="line">            nextdic[j] += [i]</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(innode):</span><br><span class="line">            <span class="keyword">if</span> v==<span class="number">0</span>:</span><br><span class="line">                stack.append(k)</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop(<span class="number">0</span>)</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print nextdic,cur</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nextdic[cur]: <span class="comment"># 记得对每一值都要初始化空list</span></span><br><span class="line">                innode[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> innode[i]==<span class="number">0</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> numCourses==ret</span><br></pre></td></tr></table></figure><h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">现在你总共有 n 门课需要选，记为 <span class="number">0</span> 到 n<span class="number">-1</span>。</span><br><span class="line">在选修某些课程之前需要一些先修课程。 例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示他们: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</span><br><span class="line">可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。要学习课程 <span class="number">1</span>，你需要先完成课程 <span class="number">0</span>。因此，正确的课程顺序为 [<span class="number">0</span>,<span class="number">1</span>] 。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">依旧是拓扑排序，设定邻接表以及入度list，然后进行遍历，同时不断加入相应的弹出节点，如果最后有效的话就就返回顺序的list否则返回[]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 拓扑排序</span></span><br><span class="line">        <span class="comment"># 构造邻接字典，入度list</span></span><br><span class="line">        innode = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        nextdic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            nextdic[i] = []</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">            innode[i] += <span class="number">1</span></span><br><span class="line">            nextdic[j] += [i]</span><br><span class="line">        <span class="comment"># 节点为0的node</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(innode):</span><br><span class="line">            <span class="keyword">if</span> v==<span class="number">0</span>:</span><br><span class="line">                stack.append(k)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        retlist = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop(<span class="number">0</span>)</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">            retlist.append(cur)</span><br><span class="line">            <span class="comment"># 去除连接</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nextdic[cur]:</span><br><span class="line">                innode[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> innode[i]==<span class="number">0</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> retlist <span class="keyword">if</span> ret==numCourses <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h2><p><strong>解题思路：</strong><br>如果序列长度大于1可以对序列进行拆分，排序，再进行合并<br>当拆分为只有单个元素的list之后默认就是排好序的<br>这样每次迭代的子部分相当于排好序的list，只需对两个排好序的list进行merge即可<br>将这种思想进行扩展即可<br><a href="https://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="noopener">归并排序思路</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mid = len(nums)/<span class="number">2</span></span><br><span class="line">left = mergesort(nums[:mid])</span><br><span class="line">right = mergesort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">ret = []</span><br><span class="line">i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;len(left) <span class="keyword">and</span> j&lt;len(right):</span><br><span class="line"><span class="keyword">if</span> left[i]&lt;=right[j]:</span><br><span class="line">ret.append(left[i])</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ret.append(right[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i==len(left):</span><br><span class="line">ret += right[j:]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ret += left[i:]</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%mergeSort(test)</span><br></pre></td></tr></table></figure><h2 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2.桶排序"></a>2.桶排序</h2><p><strong>解题思路:</strong><br>桶排序是一种计数排序，也就是说，建立最小值到最大值之间的list，<br>计算每个数字在nums中出现的次数，填写在在相应list的位置，<br>最后遍历整个list输出值不为出代表的nums中的数字即可<br>(不适用于范围太大元素个数少的list)<br><a href="https://www.cnblogs.com/king-ding/p/bucketsort.html" target="_blank" rel="noopener">桶排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">max_num = max(nums)</span><br><span class="line">min_num = min(nums)</span><br><span class="line">init_list = [<span class="number">0</span>]*(max_num-min_num+<span class="number">1</span>)</span><br><span class="line">ret_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">init_list[i-min_num] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(init_list):</span><br><span class="line"><span class="keyword">if</span> v!=<span class="number">0</span>:</span><br><span class="line">ret_list += [k+min_num]*v</span><br><span class="line"><span class="keyword">return</span> ret_list</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure></p><h2 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h2><p><strong>解题思路:</strong><br>选择第一个位置作为一个标定，之后遍历后面的list，找出比这个数大的，放在右边，<br>找出比这个数小的放在左边，进一步迭代排序左边和右边子list，即可获得排序后的结果<br>(有一点二分的思想)<br><a href="http://yshblog.com/blog/170" target="_blank" rel="noopener">快排思路1</a><br><a href="https://blog.csdn.net/razor87/article/details/71155518" target="_blank" rel="noopener">快排思路2</a><br><a href="https://blog.csdn.net/qq_34178562/article/details/79903871" target="_blank" rel="noopener">快排递归非递归</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">left = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=nums[<span class="number">0</span>]]</span><br><span class="line">right = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;nums[<span class="number">0</span>]]</span><br><span class="line">ret = quickSort(left)+[nums[<span class="number">0</span>]]+quickSort(right)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure><h2 id="4-基数排序"><a href="#4-基数排序" class="headerlink" title="4.基数排序"></a>4.基数排序</h2><p><strong>解题思路:</strong><br>基数排序主要是这样实现的，首先找出所有数字的最大值，通过最大值得到最大数的位数，<br>建立一个空值的list，分别代表0-9十个数。然后通过对nums中的元素的个位数进行提取，进而排序，<br>放到相应的空值list的位置处，之后将遍历完的数组进行合并，作为一次排序的结果，以此类推，<br>直到所有位数都排完，即可得到排序后的数组<br><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">基数排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jishuSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">k = int(math.ceil(math.log(max(nums), <span class="number">10</span>)))</span><br><span class="line">alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">alist[(v/<span class="number">10</span>**i)%<span class="number">10</span>].append(v)</span><br><span class="line">nums = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> alist:</span><br><span class="line">nums.extend(j)</span><br><span class="line">alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">test = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">123</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%jishuSort(test)</span><br></pre></td></tr></table></figure></p><h2 id="5-二叉树排序"><a href="#5-二叉树排序" class="headerlink" title="5.二叉树排序"></a>5.二叉树排序</h2><p><strong>解题思路：</strong><br>二叉树排序主要有几个步骤，构建节点，通过插值构建二叉树，对构建好的二叉树进行遍历<br><a href="https://blog.csdn.net/Rex_WUST/article/details/83274507" target="_blank" rel="noopener">二叉树排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.value = value</span><br><span class="line">self.left = <span class="keyword">None</span></span><br><span class="line">self.right = <span class="keyword">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.left = Tree(value)</span><br><span class="line"><span class="keyword">return</span> self.left</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.right = Tree(value)</span><br><span class="line"><span class="keyword">return</span> self.right</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertValue</span><span class="params">(node, value)</span>:</span></span><br><span class="line"><span class="keyword">if</span> node.value&gt;value:</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">insertValue(node.left, value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">node.leftInsert(value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">insertValue(node.right, value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">node.rightInsert(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOrder</span><span class="params">(node)</span>:</span></span><br><span class="line"><span class="keyword">if</span> node.value:</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">leftOrder(node.left)</span><br><span class="line">alist.append(node.show()) <span class="comment"># alist是全局变量</span></span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">leftOrder(node.right)</span><br><span class="line"></span><br><span class="line">alist = []</span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">root = Tree(nums[<span class="number">0</span>])</span><br><span class="line">tree = root</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">insertValue(tree, i)</span><br><span class="line">leftOrder(tree)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%nums</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%alist</span><br></pre></td></tr></table></figure></p><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h2><p><a href="https://zhuanlan.zhihu.com/p/58221959" target="_blank" rel="noopener">实例代码</a><br><a href="https://www.jianshu.com/p/d174f1862601" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(arr, s, e)</span>:</span></span><br><span class="line">    N = e<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> s*<span class="number">2</span>&lt;=N:</span><br><span class="line">        j = s*<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> j&lt;N <span class="keyword">and</span> arr[j]&lt;arr[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> arr[s]&lt;arr[j]:</span><br><span class="line">            arr[s],arr[j] = arr[j],arr[s]</span><br><span class="line">            s = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    N = len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N//<span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        help(arr, i, len(arr))</span><br><span class="line">    <span class="keyword">while</span> N&gt;<span class="number">1</span>:</span><br><span class="line">        arr[<span class="number">1</span>],arr[N] = arr[N],arr[<span class="number">1</span>]</span><br><span class="line">        help(arr, <span class="number">1</span>, N)</span><br><span class="line">        N -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">heapsort([<span class="number">-1</span>, <span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># -1是用来占位的</span></span><br></pre></td></tr></table></figure></p><h2 id="7-topK"><a href="#7-topK" class="headerlink" title="7. topK"></a>7. topK</h2><p>基于快排<br><a href="https://blog.csdn.net/lanchunhui/article/details/50960895" target="_blank" rel="noopener">参考</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr)</span>:</span></span><br><span class="line">    m = arr[<span class="number">0</span>]</span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=m]</span><br><span class="line">    h = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;m]</span><br><span class="line">    <span class="keyword">return</span> l,m,h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(arr, k)</span>:</span></span><br><span class="line">    l,m,h = partition(arr)</span><br><span class="line">    <span class="keyword">if</span> len(l)==k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">elif</span> len(l)&lt;k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> select(h, k-len(l)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(l, k)</span><br><span class="line">select([<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="KMP字符搜索"><a href="#KMP字符搜索" class="headerlink" title="KMP字符搜索"></a>KMP字符搜索</h1><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">原理参考</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_table</span><span class="params">(p)</span>:</span></span><br><span class="line">    pre = set()</span><br><span class="line">    post = set()</span><br><span class="line">    ret = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</span><br><span class="line">        pre.add(p[:i])</span><br><span class="line">        post = set([p[j:i+<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>)])</span><br><span class="line">        ret.append(max(map(len, pre &amp; post)+[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMP</span><span class="params">(s, p)</span>:</span></span><br><span class="line">    N = len(s)</span><br><span class="line">    M = len(p)</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    table = word_table(p)</span><br><span class="line">    <span class="keyword">while</span> cur &lt;=N-M:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">            <span class="keyword">if</span> s[cur+i]!=p[i]:</span><br><span class="line">                cur += max(<span class="number">1</span>, i-table[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span> </span><br><span class="line"><span class="keyword">print</span> KMP(<span class="string">"BBC ABCDAB ABCDABCDABDE"</span>, <span class="string">"ABCDABD"</span>)</span><br><span class="line"><span class="keyword">print</span> word_table(<span class="string">'ABCDABR'</span>)</span><br></pre></td></tr></table></figure><h1 id="深度优先与广度优先"><a href="#深度优先与广度优先" class="headerlink" title="深度优先与广度优先"></a>深度优先与广度优先</h1><h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1. BFS"></a>1. BFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>],</span><br><span class="line">    <span class="string">'E'</span>:[<span class="string">'C'</span>,<span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'F'</span>:[<span class="string">'D'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(s)</span><br><span class="line">    seen = set()</span><br><span class="line">    seen.add(s)</span><br><span class="line">    parent=&#123;s:<span class="keyword">None</span>&#125; <span class="comment"># 记录父节点</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        nodes = graph[cur]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                queue.append(i)</span><br><span class="line">                seen.add(i)</span><br><span class="line">                parent[i] = cur <span class="comment"># 记录父节点</span></span><br><span class="line">        <span class="keyword">print</span> cur</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">parent = BFS(graph,<span class="string">'E'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span></span><br><span class="line">v = <span class="string">'B'</span> <span class="comment"># 终点，最短路径</span></span><br><span class="line"><span class="keyword">while</span> v:</span><br><span class="line">    <span class="keyword">print</span> v</span><br><span class="line">    v = parent[v]</span><br></pre></td></tr></table></figure><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2. DFS"></a>2. DFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(graph, s)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(s)</span><br><span class="line">    seen = set()</span><br><span class="line">    seen.add(s)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        nodes = graph[cur]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                stack.append(i)</span><br><span class="line">                seen.add(i)</span><br><span class="line">        <span class="keyword">print</span> cur</span><br><span class="line"><span class="comment"># DFS(graph,'E')</span></span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack = [root]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">print</span> node.val</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br></pre></td></tr></table></figure><h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = root</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">print</span> node.val</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                cur = node.right</span><br></pre></td></tr></table></figure><h2 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack1 = [root]</span><br><span class="line">        stack2 = []</span><br><span class="line">        <span class="keyword">while</span> stack1:</span><br><span class="line">            node = stack1.pop()</span><br><span class="line">            stack2.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack1.append(node.right)</span><br><span class="line">        <span class="keyword">while</span> stack2:</span><br><span class="line">            <span class="keyword">print</span> stack.pop().val</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      面试算法题Python解答代码
    
    </summary>
    
      <category term="Algorithm" scheme="http://WenchaoXiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>葫芦书读书笔记</title>
    <link href="http://WenchaoXiu.github.io/2019/05/04/WaterMelonBook/"/>
    <id>http://WenchaoXiu.github.io/2019/05/04/WaterMelonBook/</id>
    <published>2019-05-04T09:49:19.000Z</published>
    <updated>2020-02-25T02:37:00.467Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="1-为什么需要对数值特征进行归一化"><a href="#1-为什么需要对数值特征进行归一化" class="headerlink" title="1. 为什么需要对数值特征进行归一化"></a>1. 为什么需要对数值特征进行归一化</h2><pre><code>- 为了方便后续进行梯度下降的时候加速收敛- 归一化通常主要分为两种：min-max，Z-Score- 需要进行归一化的模型：线性回归，LR，SVM，神经网络- 树模型不需要进行归一化，因为叶节点生成不涉及到梯度下降</code></pre><h2 id="2-数据预处理时，如何处理类别特征"><a href="#2-数据预处理时，如何处理类别特征" class="headerlink" title="2. 数据预处理时，如何处理类别特征"></a>2. 数据预处理时，如何处理类别特征</h2><pre><code>- 序列编码：类别特征有大小区别- one-hot编码：特征的每个值作为一列- 二进制编码：将类别映射为二进制数字- one-hot编码可能会导致维度灾难，过拟合</code></pre><h2 id="3-推荐算法中-如何解决高维度组合特征参数多问题？"><a href="#3-推荐算法中-如何解决高维度组合特征参数多问题？" class="headerlink" title="3. 推荐算法中,如何解决高维度组合特征参数多问题？"></a>3. 推荐算法中,如何解决高维度组合特征参数多问题？</h2><pre><code>- 可以将M * N矩阵分解为M * K和K * N两个矩阵相乘的形式，这样参数从M * N降到K * (M+N)</code></pre><h2 id="4-如何找到有效的组合特征？"><a href="#4-如何找到有效的组合特征？" class="headerlink" title="4. 如何找到有效的组合特征？"></a>4. 如何找到有效的组合特征？</h2><pre><code>- 可以构建决策树，把决策树各特征顺序组合起来</code></pre><h2 id="5-文本表示模型有哪些，各自优缺点？"><a href="#5-文本表示模型有哪些，各自优缺点？" class="headerlink" title="5. 文本表示模型有哪些，各自优缺点？"></a>5. 文本表示模型有哪些，各自优缺点？</h2><pre><code>- 词袋模型，N-gram，TF-IDF，词嵌入- 词嵌入就是将没个词映射到低位空间，类似于主题模型中不同的topic</code></pre><h2 id="6-Word2Vec是什么以及和LDA有什么区别"><a href="#6-Word2Vec是什么以及和LDA有什么区别" class="headerlink" title="6. Word2Vec是什么以及和LDA有什么区别"></a>6. Word2Vec是什么以及和LDA有什么区别</h2><pre><code>- Word2Vec是google开发的一种词向量嵌入的模型，主要分为分为CBOW和skip-gram两种，最后得到的是词向量的dense vector。- LDA是一种生成模型，最后可以得到文档与主题，主题与词之间的概率分布。</code></pre><h2 id="7-图像分类中，如果训练数据不足如何解决？"><a href="#7-图像分类中，如果训练数据不足如何解决？" class="headerlink" title="7. 图像分类中，如果训练数据不足如何解决？"></a>7. 图像分类中，如果训练数据不足如何解决？</h2><pre><code>- 增加数据    - 对图片进行基本的变换，平移/旋转/裁剪/加噪声/颜色变化/亮度变化等等    - 生成式对抗网络生成图片- 增加数据先验知识- 简化模型    - 减少模型复杂度    - 增加正则化，drop-out- 迁移学习</code></pre><h2 id="8-评估指标有哪些？"><a href="#8-评估指标有哪些？" class="headerlink" title="8. 评估指标有哪些？"></a>8. 评估指标有哪些？</h2><pre><code>- 准确率，精确率，召回率,PR,ROC    - 准确率: (TP+TF)/(P+F)    - 精确率: TP/P    - 召回率: TP/T    - PR曲线就是横坐标为召回率纵坐标为精确率    - ROC曲线是以假阳性率为横坐标真阳性率为纵坐标的曲线        - TPR = TP/P        - FPR = FP/N    - 绘制ROC根据PN样本数，从(0,0)开始，每遇到一个正样本纵轴加1/P,反之横轴加1/N- PR曲线和ROC曲线的差别    - 当正负样本比例变化的时候ROC影响比较小，PR影响大</code></pre><h2 id="9-什么场景下使用余弦相似度而不是欧氏距离？"><a href="#9-什么场景下使用余弦相似度而不是欧氏距离？" class="headerlink" title="9. 什么场景下使用余弦相似度而不是欧氏距离？"></a>9. 什么场景下使用余弦相似度而不是欧氏距离？</h2><pre><code>- 关注于角度而不是绝对距离的时候使用余弦相似度，比如文本内容相近，但是长度差距大时- 欧式距离则更关注绝对差异，当用户活跃度以及登录次数分别为(1,10),(10,100)不能用余弦相似度</code></pre><h2 id="10-余弦距离是否是一个严格的距离定义？"><a href="#10-余弦距离是否是一个严格的距离定义？" class="headerlink" title="10. 余弦距离是否是一个严格的距离定义？"></a>10. 余弦距离是否是一个严格的距离定义？</h2><pre><code>- 余弦距离是 d = 1-cos&lt;A,B&gt;- 满足正定型d&gt;0- 满足对称性- 但是不满足三角不等式(0,1),(1,1),(1,0)就是个反例</code></pre><h2 id="11-如何进行线上测试？"><a href="#11-如何进行线上测试？" class="headerlink" title="11. 如何进行线上测试？"></a>11. 如何进行线上测试？</h2><pre><code>- 将用户分成两部分，不重复的，一部分用新方法，一部分用旧方法</code></pre><h2 id="12-为什么进行了充分的离线测试之后还需要进行A-B测试？"><a href="#12-为什么进行了充分的离线测试之后还需要进行A-B测试？" class="headerlink" title="12. 为什么进行了充分的离线测试之后还需要进行A/B测试？"></a>12. 为什么进行了充分的离线测试之后还需要进行A/B测试？</h2><pre><code>- 离线评估不能完全消除模型模型过拟合的影响- 离线评估无法完全还原线上环境，延迟啊，数据缺失啊之类的- 离线评估一般是对模型本身的评估，但是对于某些指标的变化没办法直接估计</code></pre><h2 id="13-评估模型的方法？以及各自的优缺点？"><a href="#13-评估模型的方法？以及各自的优缺点？" class="headerlink" title="13. 评估模型的方法？以及各自的优缺点？"></a>13. 评估模型的方法？以及各自的优缺点？</h2><pre><code>- Holdout检验    - 直接把样本按照一定比例分成训练集和测试集进行建模和评估- K折交叉验证        - 将数据等分为k份，其中一份作为验证集，其他作为训练集，每次都选择不同的部分    - 最后将k次评估指标的均值作为最终指标- 自助法    - 适用于样本较少的时候，每次有放回采样，将多次采样中没采到的作为验证集</code></pre><h2 id="14-超参数调优有哪些方法？"><a href="#14-超参数调优有哪些方法？" class="headerlink" title="14. 超参数调优有哪些方法？"></a>14. 超参数调优有哪些方法？</h2><pre><code>- 网格搜索    - 设置一定的范围以及一定的步长进行搜索，可以一开始设置较大的步长确定范围    - 之后再缩短步长精确搜索- 随机搜索    - 不再设定范围随机搜索- 贝叶斯优化算法    - 充分利用了之前搜索的信息，具体来说就是设置一个参数的先验分布，随机的确定参数    - 根据这个分布进行采样，利用采样信息确定新的参数分布，之后再根据后验分布确定最优参数值    - 不断迭代</code></pre><h2 id="15-如何降低过拟合欠拟合风险？"><a href="#15-如何降低过拟合欠拟合风险？" class="headerlink" title="15. 如何降低过拟合欠拟合风险？"></a>15. 如何降低过拟合欠拟合风险？</h2><pre><code>- 过拟合    - 降低模型复杂度    - 增加正则项    - 获取更多数据    - 集成学习减少variance- 欠拟合    - 增加模型复杂度    - 添加新特征    - 减少正则化系数</code></pre><h2 id="16-加入松弛变量的SVM中可以误差为0吗？"><a href="#16-加入松弛变量的SVM中可以误差为0吗？" class="headerlink" title="16. 加入松弛变量的SVM中可以误差为0吗？+++++++++"></a>16. 加入松弛变量的SVM中可以误差为0吗？+++++++++</h2><pre><code>- 不一定，因为此时优化函数分为两部分，</code></pre><h2 id="17-逻辑回归与线性回归之间的差别"><a href="#17-逻辑回归与线性回归之间的差别" class="headerlink" title="17. 逻辑回归与线性回归之间的差别"></a>17. 逻辑回归与线性回归之间的差别</h2><pre><code>- 逻辑回归用于分类，线性回归用来做回归问题，逻辑回归是对数几率回归- 两者相同的地方在于都可以用最大似然函数进行优化，都可以使用梯度下降进行参数更新</code></pre><h2 id="18-决策树有哪些启发性函数？"><a href="#18-决策树有哪些启发性函数？" class="headerlink" title="18. 决策树有哪些启发性函数？"></a>18. 决策树有哪些启发性函数？</h2><pre><code>- ID3，C4.5，CART</code></pre><h2 id="19-ID3，C4-5，CART之间的优缺点？"><a href="#19-ID3，C4-5，CART之间的优缺点？" class="headerlink" title="19. ID3，C4.5，CART之间的优缺点？"></a>19. ID3，C4.5，CART之间的优缺点？</h2><pre><code>- ID3基于信息增益，处理分类问题，无法处理缺失值，无法减枝- C4.5是在ID3基础上的改进，可以处理缺失值，通过信息增益率进一步限制了分散化的特征，加入了减枝- CART基于基尼指数进行特征筛选，可用于分类和回归，回归的话通过改变损失函数实现，可以减枝可以处理缺失值，产生二叉树，减枝可以使用CCP代价复杂度减枝</code></pre><h2 id="20-如何对决策树进行减枝？"><a href="#20-如何对决策树进行减枝？" class="headerlink" title="20. 如何对决策树进行减枝？"></a>20. 如何对决策树进行减枝？</h2><pre><code>- 预减枝    - 预减枝是在树生成之间进行判断是否生成的操作    - 基于三个方面，树的深度，当前叶节点的样本数量，每次分裂的准确率的提升阈值    - 但是有可能会有欠拟合的风险- 后减枝    -这里有多种策略，以代价复杂度减枝进行说明    -通过比较减枝前后的误差率的增加作为标准进行减枝操作(选择误差率最低的)    -具体来说就是R(t)-R(Tt)/(L(t)-1),其中R(t)是减枝后节点的错误样本数，R(Tt)是减枝之前的错误样本数，L(t)是当前节点拥有的叶节点数</code></pre><h2 id="21-PCA如何降维？"><a href="#21-PCA如何降维？" class="headerlink" title="21. PCA如何降维？"></a>21. PCA如何降维？</h2><pre><code>- 需要找到一个正交基向量w，使得数据映射到w之后保证方差最大(因为默认信号的方差比噪声的大)- 通过最大化方差可以获得基向量w- 具体步骤：对数据进行去均值化，求解协方差矩阵，进行特征值特征向量求解，取前k个最大的特征值对应的特征向量，将原数据映射</code></pre><h2 id="22-线性判别分析"><a href="#22-线性判别分析" class="headerlink" title="22. 线性判别分析"></a>22. 线性判别分析</h2><pre><code>- 是一种有监督学习，通常用于降维，核心思想是数据映射完之后不同类别之间均值差距最大化</code></pre><h2 id="23-简述K-means的具体步骤"><a href="#23-简述K-means的具体步骤" class="headerlink" title="23. 简述K-means的具体步骤"></a>23. 简述K-means的具体步骤</h2><pre><code>- 数据归一化，处理离群点- 随机选取k各中心值- 对每个点进行类别标记- 对各类点均值进行计算重新取做新的类别中心- 不断迭代直到中心点位置基本不变</code></pre><h2 id="24-k-means的优缺点"><a href="#24-k-means的优缺点" class="headerlink" title="24. k-means的优缺点"></a>24. k-means的优缺点</h2><pre><code>- 数据离群点影响较大- K值需要进行选择，对于一些特殊形状的分布没办法进行很好的类别区分    - K值的选取可以使用手肘法或者GapStatics- 数据收初始值影响大    - 针对初始值的选取Kmeans++做了改进，聚类中心互相离的越远越好</code></pre><h2 id="25-高斯混合模型核心思想是什么？如何迭代计算？"><a href="#25-高斯混合模型核心思想是什么？如何迭代计算？" class="headerlink" title="25. 高斯混合模型核心思想是什么？如何迭代计算？"></a>25. 高斯混合模型核心思想是什么？如何迭代计算？</h2><pre><code>- 高斯混合模型是一种生成模型，通过多个高斯分布权重的不同，采样选取某个高斯分布，进一步进行随机采样- 获得了相应的数据点。我们需要根据生成的数据点对模型中各个高斯分布的权重进行估计，同时对每个高斯分布- 参数进行估计，使得在相应的参数之下可以获得样本数据概率最大- 主要通过EM算法进行各个参数的估计，包含两个步骤：    - E-step，求解隐变量分布。随机初始参数之后通过随机初始参数估计每个数据    - M-step，求解在该隐变量分布下使得极大似然函数最大的参数。根据隐变量分布重新估计相应均值，再根据均值估计方差</code></pre><!-- ;EM算法推导;gbdt推导;算法题： 从右边看被遮挡的二叉树，求露出的node;只说考到的点有 apriori，KM算法，匈牙利算法，模拟退火，贪婪，蚁群对比;xgb，rf，lr优缺点场景 --><hr>]]></content>
    
    <summary type="html">
    
      对葫芦书中一些算法题进行总结
    
    </summary>
    
      <category term="Machine learning" scheme="http://WenchaoXiu.github.io/categories/Machine-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>scikit-learn学习笔记</title>
    <link href="http://WenchaoXiu.github.io/2019/04/11/ML-algrithom-usage/"/>
    <id>http://WenchaoXiu.github.io/2019/04/11/ML-algrithom-usage/</id>
    <published>2019-04-11T01:44:48.000Z</published>
    <updated>2020-02-25T03:00:09.498Z</updated>
    
    <content type="html"><![CDATA[<p class="description">机器学习算法的实践笔记</p><p><img src="./images/sklearn.jpg" alt="" style="width:100%"></p><a id="more"></a><h1 id="笔记简介"><a href="#笔记简介" class="headerlink" title="笔记简介"></a>笔记简介</h1><p>主要整理一下近期学习的机器学习算法具体的实现过程,主要使用的package有scikit-learn,xgboost</p><h1 id="sklearn各功能实现"><a href="#sklearn各功能实现" class="headerlink" title="sklearn各功能实现"></a>sklearn各功能实现</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>1.对类别数据进行离散化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为构件数学模型的时候类别特征可以取多个值，不同的值实际上代表的是不同特征属性，因此需要对类别特征进行离散化处理</span></span><br><span class="line"><span class="comment"># 1.利用pandas的get_dummies进行onehot编码</span></span><br><span class="line">newDF = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> DF.columns:</span><br><span class="line">tmp = pd.get_dummies(DF[col])</span><br><span class="line">tmp = pd.rename(columns = <span class="keyword">lambda</span> x: col+<span class="string">'_'</span>+str(x))</span><br><span class="line">newDF = pd.concat([newDF, tmp], axis=<span class="number">1</span>)</span><br><span class="line">x = newDF.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.利用sklearn的label_binarize进行onehot编码</span></span><br><span class="line"><span class="comment"># 除了上述的pd.get_dummies之外的另一种等价方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> label_binarize</span><br><span class="line">DF_col = label_binarize(DF[col], classes = np.arange(len(pd.unique(DF[col]))))</span><br><span class="line"><span class="comment"># label_binarize返回的和pd.get_dummies返回的对象类似，列数与类别数相同，且只包含01值</span></span><br><span class="line"><span class="comment"># 区别在于，label_binarize返回的是ndarray数据，pd.get_dummies返回的是DataFrame数据</span></span><br><span class="line"><span class="comment"># 因此，np.array_equal(DF_col, pd.get_dummies(DF[col]).values)返回的是True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.sklearn的OneHotEncoder</span></span><br><span class="line"><span class="comment"># 这个功能略感鸡肋(也可能是打开方式不对)给个例子，就不赘述了</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">     [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">     [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">     [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],]</span><br><span class="line">ohe = OneHotEncoder(sparse=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> ohe.fit_transform(x)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure></p><p>2.对响应变量进行转换，将类别数据转化为不同int型数字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y = DF.accept</span><br><span class="line">y_int = pd.Categorical(y).codes <span class="comment">#得到从0~n-1的n类数字，分别对应不同的类别</span></span><br><span class="line"><span class="comment"># 与上述pd.get_dummies的区别在于，get_dummies返回的是DataFrame数据，且只有01两个值</span></span><br><span class="line"><span class="comment"># 但是上述方法返回的是ndarray数据，返回的值不止01，具体的根据类别数量进行确定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">y_int = LabelEncoder().fit_transform(y_train)</span><br><span class="line"><span class="comment"># 实现了跟上面相同的功能，输入是不用类别的label，返回的是0~n-1的数字</span></span><br></pre></td></tr></table></figure></p><p>3.训练集测试集分割<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样做的目的是方便测试算法泛化能力</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=<span class="number">0.7</span>)</span><br><span class="line"><span class="comment"># PS:其中x, y是ndarray数据类型，如果是DF数据的话需要使用DF.values进行转化</span></span><br></pre></td></tr></table></figure></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>1.PCA数据降维<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca_model = PCA(n_components=<span class="number">2</span>, whiten=<span class="keyword">True</span>)</span><br><span class="line">x_pca = pca_model.fit_transform(x)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'top2 方差'</span>, pca_model.explained_variance_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'top2 方差所占比例'</span>, pca_model.explained_variance_ratio_</span><br><span class="line"><span class="comment"># 其中的n_component是选择将数据降维后，选取其中的n个特征（特征顺序按照特征值从高到低排序）</span></span><br><span class="line"><span class="comment"># pca_model.explained_variance_是对应的前两个特征的方差</span></span><br><span class="line"><span class="comment"># pca_model.explained_variance_ratio_是前两个特征的方差占总方差的比例</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.lmplot(x = <span class="string">'pc1'</span>, y=<span class="string">'pc2'</span>, data = pc_plot_data, hue=type, fit_reg=<span class="keyword">False</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_title(<span class="string">"Iris PCA 2 compotent"</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 上述代码用来绘图</span></span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/pinard/p/6243025.html" target="_blank" rel="noopener">使用教程</a></p><p>2.特征筛选<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用sklearn的SelectKBest进行特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2</span><br><span class="line">chi2_model = SelectKBest(chi2, k=<span class="number">2</span>)</span><br><span class="line">chi2_model.fit(x, y)</span><br><span class="line">selected_col = chi2_model.get_support(indices=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 之所以x和y都需要加进去是因为需要对每个特征和响应变量进行chi2检验，按照显著性排序，找到前两个特征（原特征）</span></span><br><span class="line"><span class="comment"># indices是为了返回对应的column数</span></span><br></pre></td></tr></table></figure></p><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/feature_selection.html" target="_blank" rel="noopener">官方文档</a> &amp; <a href="http://bluewhale.cc/2016-11-25/use-scikit-learn-for-feature-selection.html" target="_blank" rel="noopener">使用教程</a> &amp; <a href="http://d0evi1.com/sklearn/feature_selection/" target="_blank" rel="noopener">特征提取</a></p><p>3.原始特征变化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">poly = PolynomialFeatures(degree = <span class="number">2</span>, include_bias=<span class="keyword">True</span>, interaction_only=<span class="keyword">False</span>)</span><br><span class="line">x_poly = poly.fit_transform(x)</span><br><span class="line"><span class="comment"># 对数据特征进行变换，degree是特征的最高维数，include_bias加不加一列1，interaction_only是否只看有交互的特征</span></span><br></pre></td></tr></table></figure></p><h2 id="构建有监督模型"><a href="#构建有监督模型" class="headerlink" title="构建有监督模型"></a>构建有监督模型</h2><p>1.逻辑回归模型用于分类（Logistic Regression）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklean.linear_model <span class="keyword">import</span> LogisticRegressionCV, Lasso</span><br><span class="line">model = LinearRegeressionCV(Cs = np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>), cv = <span class="number">5</span>, n_job = <span class="number">-1</span>)</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = model.predict(x_train) <span class="comment"># 对训练集进行预测</span></span><br><span class="line">y_test_hat = model.predict(x_test) <span class="comment"># 对测试集进行预测</span></span><br><span class="line"><span class="keyword">print</span> model.C_ <span class="comment"># 获得各类别最佳超参数</span></span><br><span class="line"><span class="comment"># LinearRegeressionCV是一种自动确定正则化超参数的函数，其中Cs是一系列的正则化参数值，一般需要取不同数量级的数字</span></span><br><span class="line"><span class="comment"># cv是进行cross validation对超参数最优解进行确定，n_job=-1是用上全部线程，这里默认的正则是L2 norm</span></span><br><span class="line"><span class="comment"># PS:注意在进行多分类的时候选择的方法是one vers rest也就是一对多进行多分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意除了自带的cross-validation方法，还可以用更加普遍的方法GridSearchCV</span></span><br><span class="line">model = Lasso()</span><br><span class="line">GS_Lasso = GridSearchCV(model, param_grid=&#123;<span class="string">'alpha'</span>:np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>)&#125;, cv=<span class="number">5</span>)</span><br><span class="line">GS_Lasso.fit(x_train, y_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Lasso model最优参数: '</span>, GS_Lasso.best_params_</span><br></pre></td></tr></table></figure></p><p>2.决策树模型（DesitionTree）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对决策树的不同深度进行探究，求取对应的准确率</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">model = DecisionTreeClassifier()</span><br><span class="line">acc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line">    model.set_params(max_depth=i)</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    y_test_hat = model.predict(x_test)</span><br><span class="line">    acc.append(metrics.accuracy_score(y_test, y_test_hat))</span><br><span class="line">plt.plot(np.arange(<span class="number">1</span>,<span class="number">15</span>), acc, <span class="string">'ro'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'depth'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#决策树进行回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">reg = DecisionTreeRegressor(criterion=<span class="string">'mse'</span>, max_depth=deep)</span><br><span class="line">dt = reg.fit(x, y)</span><br></pre></td></tr></table></figure></p><p>3.随机森林模型（RandomForest）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">RF_model = RandomForestRegressor()</span><br><span class="line">RF_model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = RF_model.predict(y_train)</span><br><span class="line"><span class="comment"># 对于多值输出问题来说一般采用多值输出的方法进行模型构建，主要从两个角度：a.每个叶节点存储多个值 b.通过计算多个值的平均减少量作为split标准</span></span><br></pre></td></tr></table></figure></p><p><a href="http://sklearn.apachecn.org/cn/latest/modules/tree.html" target="_blank" rel="noopener">参考</a> &amp; <a href="https://www.cnblogs.com/pinard/p/6160412.html" target="_blank" rel="noopener">随机森林调参</a></p><p>4.bagging模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">DT_model = DecisionTreeRegressor(max_depth=<span class="number">9</span>)</span><br><span class="line">ridge_BG_model = BaggingRegressor(Pipeline([(<span class="string">'poly'</span>, PolynomialFeatures(degree=<span class="number">6</span>)), </span><br><span class="line">                                            (<span class="string">'ridge'</span>, linear_model.RidgeCV(alphas=np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>), cv=<span class="number">5</span>, fit_intercept=<span class="keyword">False</span>))])</span><br><span class="line">                                  , n_estimators=n_estimators, max_samples=max_samples)</span><br><span class="line">DT_BG_model = BaggingRegressor(DT_model, n_estimators=n_estimators, max_samples=max_samples)</span><br><span class="line"><span class="comment"># bagging是一种构建多个基分类器，对数据进行预测，并平均多个分类器的预测值的一种方法</span></span><br><span class="line"><span class="comment"># 输入需要有基分类器，基分类器的个数，以及对于样本选取的比例</span></span><br></pre></td></tr></table></figure></p><p>5.Adaboost模型<br><a href="http://www.cnblogs.com/pinard/p/6133937.html" target="_blank" rel="noopener">原理</a> &amp; <a href="https://www.cnblogs.com/pinard/p/6136914.html" target="_blank" rel="noopener">模型参数</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">base = DecisionTreeClassifier(n_estimators=<span class="number">100</span>, max_depth = <span class="number">3</span>, min_sample_split=<span class="number">4</span>, random_state=<span class="number">1</span>, oob_score=<span class="keyword">True</span>) </span><br><span class="line"><span class="comment"># 超过4个样本就进行样本的分割构建叶节点, 基分类器个数100，最大树深3，oob_score考虑带外分数</span></span><br><span class="line">AB_model = AdaBoostClassifier(base_estimator = base, learning_rate = <span class="number">0.1</span>)</span><br><span class="line">AB_model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = AB_model.predict(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确度: %.5.f'</span>%metrics.accuracy_score(y_train, y_train_hat)</span><br><span class="line"><span class="comment"># Adaboost是另一种集成模型，利用决策树模型作为基分类器，与上面的bagging的区别在于，bagging是可以并行的，各个模型的确定可以随机产生，最后平均化即可</span></span><br><span class="line"><span class="comment"># 但是对于Adaboost来说各个基分类器是串行产生的，每次新产生的分类器都与前面所有的分类器相关，具体是新的分类器是通过前面所有模型的残差和确定的</span></span><br><span class="line"><span class="comment"># 相当于不断强化基分类器与真实值的差别，因此Adaboost的基分类器需要更加泛化相比较Bagging的及模型</span></span><br><span class="line"><span class="comment"># 举个例子假如基分类器都是决策树，Bagging的深度更深，Adaboost的深度更浅</span></span><br><span class="line"><span class="comment"># 这里learning_rate实际上是fk(x)=fk−1(x)+ναkGk(x)中的ν(0&lt;ν&lt;1)，其中αk是根据分类器的错误率进行确定的模型权重</span></span><br><span class="line"><span class="comment"># Gk(x)是根据样本权重重新确定的基分类器，fk(x)是膜前获得的强分类器是k个基分类器的结合，理论上ν越小的话迭代下次数越多</span></span><br></pre></td></tr></table></figure></p><p>6.GBDT模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GBDT 每个基分类器要相对弱一点因为是提升树</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">gbdt_model = GradientBoostingClassifier(learning_rate=<span class="number">0.1</span>, max_depth=<span class="number">3</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">gbdt_model.fit(x_train, y_train)</span><br><span class="line">gbdt_y_train_hat = gbdt_model.predict(x_train)</span><br><span class="line">gbdt_y_test_hat = gbdt_model.predict(x_test)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.4f'</span>%metrics.accuracy_score(y_train, gbdt_y_train_hat)</span><br></pre></td></tr></table></figure></p><p>7.xgboost模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xgboost也是一种快速效果好的集成模型</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line">train_data = xgb.DMatrix(x_train, y_train)</span><br><span class="line">test_data = xgb.DMatrix(x_test, y_test)</span><br><span class="line">watch_list = [(test_data, <span class="string">'eval'</span>), (train_data, <span class="string">'train'</span>)]</span><br><span class="line">params = &#123;<span class="string">'eta'</span>:<span class="number">0.1</span>, <span class="string">'max_depth'</span>:<span class="number">6</span>, <span class="string">'objective'</span>:<span class="string">'multi:softmax'</span>, <span class="string">'num_class'</span>:<span class="number">3</span>&#125;</span><br><span class="line">xgb_model = xgb.train(params, train_data, num_boost_round=<span class="number">50</span>, evals=watch_list, evals_result=&#123;<span class="string">'eval_metric'</span>:<span class="string">'logloss'</span>&#125;) <span class="comment">#设置对应评估指标</span></span><br><span class="line">y_test_hat_xgb = xgb_model.predict(test_data) <span class="comment">#######test_data类型，xgb_model跟sklearn不同</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'xgb model: %.3f'</span>%(sum(y_test_hat_xgb==y_test)*<span class="number">1.0</span>/len(y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用XGBOOST的sklearn接口进行模型构建，这个方便点使用习惯和sklearn其他模型类似</span></span><br><span class="line">xgb_model = xgb.XGBClassifier(learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">100</span>, max_depth=<span class="number">2</span>, objective=<span class="string">'multi:softmax'</span>)</span><br><span class="line">xgb_model.fit(x_train, y_train)</span><br><span class="line">xgb_y_train_hat = xgb_model.predict(x_train)</span><br><span class="line">xgb_y_test_hat = xgb_model.predict(x_test)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.4f'</span>%metrics.accuracy_score(y_train, xgb_y_train_hat)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'验证集准确率: %.4f'</span>%metrics.accuracy_score(y_test, xgb_y_test_hat)</span><br></pre></td></tr></table></figure></p><p><a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html?highlight=fit#module-xgboost.sklearn" target="_blank" rel="noopener">sklearn API</a> &amp; <a href="https://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="noopener">参数解释</a> &amp; <a href="https://github.com/dmlc/xgboost/tree/master/demo#tutorials" target="_blank" rel="noopener">github使用教程</a> &amp; <a href="https://www.zhihu.com/question/41354392/answer/98658997" target="_blank" rel="noopener">GDBT和XGBOOSt区别</a> &amp; <a href="https://zhuanlan.zhihu.com/p/28663369" target="_blank" rel="noopener">Tatanic实例</a> &amp; <a href="https://zhuanlan.zhihu.com/p/31182879" target="_blank" rel="noopener"><strong>知乎教程</strong></a> &amp; <a href="https://zhuanlan.zhihu.com/p/26683576" target="_blank" rel="noopener"><strong>Ensemble模型介绍</strong></a></p><p>8.SVM模型<a href="https://www.cnblogs.com/pinard/p/6117515.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">model = svm.SVC(C=<span class="number">0.1</span>, kernel=<span class="string">'linear'</span>, decision_function_shape=<span class="string">'ovr'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">0</span>]&#125;)</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = model.predit(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'decision_function:\n'</span>, clf.decision_function(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\npredict:\n'</span>, clf.predict(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量的数目：'</span>, clf.n_support_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量的系数：'</span>, clf.dual_coef_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量: '</span>, clf.support_ <span class="comment"># 这个是对应的支持向量的索引值</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'模型精度: '</span>, model.score(x_train, y_train)</span><br><span class="line"><span class="comment"># C是惩罚系数，当C很大的时候为了保证损失函数最小对应的惩罚因子需要很小，使得模型很严格，决策边界之间的距离很小</span></span><br><span class="line"><span class="comment"># class_weight是为了方便对不平衡数据的操作，如果类别数据数量级差的太多的话会使模型准确度下降</span></span><br><span class="line"><span class="comment"># kernel可以选择不同的核函数，decision_function_shape是进行one vers rest，可以使用ovo,这样的话一对一</span></span><br><span class="line"><span class="comment"># decision_function计算每个样本到每一类的距离，选取最大的那个作为预测类别（因为在决策边界两侧），decision_function的ovr和ovo列数有差别</span></span><br><span class="line"><span class="comment"># predict就是正常的返回类别对应的数字</span></span><br><span class="line"><span class="comment"># svm的score返回的是精度类似于metrics.accuracy_score(x_train, y_train)</span></span><br><span class="line"></span><br><span class="line">weight = [<span class="number">2</span>,<span class="number">30</span>,<span class="number">2</span>,<span class="number">30</span>]</span><br><span class="line">clfs = [svm.SVC(C=<span class="number">1</span>, kernel=<span class="string">'linear'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">0</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">1</span>, kernel=<span class="string">'linear'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">1</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">0.8</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.5</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">2</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">0.8</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.5</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">3</span>]&#125;)]</span><br><span class="line"><span class="comment"># 对于不平衡数据进行权重的分配，保证结果的准确性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用SVM进行回归分析</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">print(<span class="string">'SVR - RBF'</span>)</span><br><span class="line">svr_rbf = svm.SVR(kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.2</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_rbf.fit(x, y)</span><br><span class="line">print(<span class="string">'SVR - Linear'</span>)</span><br><span class="line">svr_linear = svm.SVR(kernel=<span class="string">'linear'</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_linear.fit(x, y)</span><br><span class="line">print(<span class="string">'SVR - Polynomial'</span>)</span><br><span class="line">svr_poly = svm.SVR(kernel=<span class="string">'poly'</span>, degree=<span class="number">3</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_poly.fit(x, y)</span><br><span class="line">print(<span class="string">'Fit OK.'</span>)</span><br><span class="line"><span class="comment"># 注意这里kernel可以选择linear/rbf分别对应线性核以及高斯核，其中线性核和高斯核分别有两个比较重要的参数</span></span><br><span class="line"><span class="comment"># C和gamma，其中C上面已经解释过了，gamma是一个跟核函数相关的参数，gamma是∂2的倒数，表征高斯核的方差大小，</span></span><br><span class="line"><span class="comment"># 所以∂2的倒数表征的是高斯核的精度，gamma值越大也就数据在训练集上准确度越高，增大过拟合的风险</span></span><br><span class="line"><span class="comment"># PS:kernel还可以选择poly多项式核，配合的参数是degree</span></span><br></pre></td></tr></table></figure></p><h2 id="构建无监督模型"><a href="#构建无监督模型" class="headerlink" title="构建无监督模型"></a>构建无监督模型</h2><p>1.Kmeans聚类<a href="https://www.cnblogs.com/pinard/p/6169370.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets <span class="keyword">as</span> ds</span><br><span class="line">x, y = ds.make_blobs(<span class="number">400</span>, n_features=<span class="number">2</span>, centers=<span class="number">4</span>, cluster_std=(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">0.5</span>, <span class="number">2</span>), random_state=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 这个函数的功能是根据高斯分布进行构建随机数据，用于后续的聚类分析</span></span><br><span class="line"><span class="comment"># 其中400是产生的样本的个数，n_features是产生的数据的维度，centers是对应数据的类别，cluster_std是定义不同类别的方差</span></span><br><span class="line"><span class="comment"># 这里centers可以是一组array数据，作为中心</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">model = KMeans(n_clusters=<span class="number">4</span>, init=<span class="string">'k-means++'</span>, n_init=<span class="number">10</span>, max_iter=<span class="number">300</span>)</span><br><span class="line">model.fit(x, y)</span><br><span class="line">y_hat = model.predict(x)</span><br><span class="line">model.cluster_centers_ <span class="comment"># 输出对应的聚类中心</span></span><br><span class="line"><span class="comment"># KMeans算法主要有这几个主要参数，n_cluster是聚类类别，init是中心点初始化方法，因为KMeans初值敏感所以需要迭代多次，</span></span><br><span class="line"><span class="comment"># n_init就是控制这个的参数，当数据是非凸集的时候max_iter的设置防止算法不收敛</span></span><br></pre></td></tr></table></figure></p><p>2.AP聚类算法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AffinityPropagation</span><br><span class="line">model = AffinityPropagation(affinity=<span class="string">'euclidean'</span>)</span><br><span class="line">model.fit(x, y)</span><br><span class="line">model.cluster_centers_indices_ <span class="comment"># 返回的是中心点的索引</span></span><br><span class="line">y_hat = model.labels_ <span class="comment">#返回的是预测的数据类别</span></span><br></pre></td></tr></table></figure></p><p>3.DBSCAN算法(<a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="noopener">参考1</a>,<a href="http://scikit-learn.org/stable/auto_examples/cluster/plot_dbscan.html#sphx-glr-auto-examples-cluster-plot-dbscan-py" target="_blank" rel="noopener">参考2</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">model = DBSCAN(eps=m, min_samples=n) <span class="comment"># eps对应算法的半径, min_samples对应算法在ε半径之内包含的最小点数，用来确定核心对象</span></span><br><span class="line">model.fit(x)</span><br><span class="line">y_hat = model.labels_ <span class="comment"># 预测类别值</span></span><br><span class="line">y_coresample = model.core_sample_indices_ <span class="comment"># 预测类别中心点</span></span><br><span class="line">n_clusters_ = len(set(y_hat)) - (<span class="number">1</span> <span class="keyword">if</span> <span class="number">-1</span> <span class="keyword">in</span> y_hat <span class="keyword">else</span> <span class="number">0</span>) <span class="comment"># 注意算法会把噪音点归为-1</span></span><br><span class="line"><span class="comment"># DBSCAN对数据本身没有分布要求，不像Kmeans假设数据是高斯分布的，DBSCAN产生的聚类形状可以不为类圆形</span></span><br><span class="line"><span class="comment"># 固定ε，min_samples越大越严格；固定min_samples，ε越小越严格</span></span><br><span class="line"><span class="comment"># DBSCAN通过计算每个数据点的高局部密度点距离和本身的密度确定每个点的类别，高局部密度点距离大密度大的点为聚类中心</span></span><br><span class="line"><span class="comment"># 高局部密度点距离大密度小的点为噪声，高局部密度点距离小密度大的点为普通点，高局部密度点距离小密度大的点不好判断</span></span><br><span class="line"><span class="comment"># ps:密度就是每个点ε邻域内的点数，高局部密度点距离就是比该点密度大的点中与之距离最小的距离</span></span><br></pre></td></tr></table></figure></p><p>4.MeanShift聚类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MeanShift</span><br><span class="line">model = MeanShift(bin_seeding=<span class="keyword">True</span>, bandwidth=band_width)</span><br><span class="line"><span class="comment"># 只需要给出圆的半径就好，圆的中心根据圆圈内包含的点的中心不断更新</span></span><br></pre></td></tr></table></figure></p><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>1.模型准确率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.5f'</span>%metrics.accuracy_score(y_train, y_train_hat) <span class="comment"># 先放真实值再放预测值，类型是ndarray</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'测试集准确率: %.5f'</span>%metrics.accuracy_score(y_test, y_test_hat) <span class="comment"># 先放真实值再放预测值，类型是ndarray</span></span><br><span class="line"><span class="comment"># 这里y_train和y_train_hat都是由0、1组成的</span></span><br></pre></td></tr></table></figure></p><p>2.模型的ROC、AUC<a href="https://blog.csdn.net/YE1215172385/article/details/79443552" target="_blank" rel="noopener">micro/macro</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">micro_AUC = metrics.roc_auc_score(y_true, y_probability, average=<span class="string">'micro'</span>)</span><br><span class="line">macro_AUC = metrics.roc_auc_score(y_true, y_probability, average=<span class="string">'macro'</span>)</span><br><span class="line">fpr, tpr, threshold = metrics.roc_curve(y_true.ravel(), y_probability.ravel())</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>), dpi=<span class="number">80</span>, facecolor=<span class="string">'w'</span>)</span><br><span class="line">plt(fpr, tpr, <span class="string">'r-'</span>, lw=<span class="number">2</span>, label=<span class="string">'AUC: %.5f'</span>%micro_AUC)</span><br><span class="line">plt.xlabel(<span class="string">'FPR'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'TPR'</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>))</span><br><span class="line">plt.yticks(np.arange(<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>))</span><br><span class="line">plt.title(<span class="string">'ROC curve'</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.grid(b=<span class="keyword">True</span>, ls=<span class="string">':'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">'lower right'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对上述评估标准进行说明，首先y_true和y_probability是一个n*m的ndarray对象，n是样本数，m是响应变量的类别数</span></span><br><span class="line"><span class="comment"># 其中y_true是对应多类别的真实值，每一行只有一个1其余为0，y_probability每一行是不同类别的预测概率</span></span><br><span class="line"><span class="comment"># 在计算AUC得分的时候，如果是多分类问题，有两种计算方式，第一种对每一列绘制ROC计算AUC，即对每一类别分别计算</span></span><br><span class="line"><span class="comment"># 另一种是将n*m的矩阵按行首尾连接，形成一个n*m长的array，对其绘制ROC同时计算AUC，这两种分别是macro和micro</span></span><br><span class="line"><span class="comment"># metrics.roc_curve是用来获得在不同theshold下得到的FPR和TPR的对应值，其中.ravel()方法用来展开数据，相当于按照micro的方法绘制</span></span><br></pre></td></tr></table></figure></p><p>3.模型的MSE(Mean square error)<a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=10814010" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算模型的均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">metrics.mean_squared_error(y_True, y_hat)</span><br></pre></td></tr></table></figure></p><p>4.模型的其他评估(Mean square error) <a href="https://blog.argcv.com/articles/1036.c" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score, f1_score, fbeta_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_fscore_support, classification_report</span><br><span class="line">fbeta = fbeta_score(y_true, y_hat, beta=beta)</span><br><span class="line">precision = precision_score(y_true, y_hat)</span><br><span class="line">recall = recall_score(y_true, y_hat)</span><br><span class="line">print(<span class="string">'f1 score: \t'</span>, f1_score(y_true, y_hat))</span><br><span class="line">fbeta = fbeta_score(y_true, y_hat, beta=beta)</span><br><span class="line"><span class="comment"># precision score = tp/(tp+fp)和准确度的区别在于只关注正类，准确率是所有类别都关注</span></span><br><span class="line"><span class="comment"># recal score = tp/(tp+fn)</span></span><br><span class="line"><span class="comment"># F1 = 2*(precision*recall)/(precision+recall) F1相当于P和R调和均值，越大模型效果越好</span></span><br><span class="line"><span class="comment"># fbeta_score是P和R的调和均值，beta&lt;1 precision的权重更大，beta&gt;1 recall的权重更大</span></span><br></pre></td></tr></table></figure></p><p>5.聚类方法的评估(<a href="https://blog.csdn.net/Mr_tyting/article/details/76719062" target="_blank" rel="noopener">方法解释</a><a href="https://blog.csdn.net/sinat_26917383/article/details/70577710" target="_blank" rel="noopener">参考1</a>, <a href="http://sklearn.apachecn.org/cn/0.19.0/modules/clustering.html" target="_blank" rel="noopener">参考2</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Homogeneity：'</span>, homogeneity_score(y, y_pred))</span><br><span class="line">print(<span class="string">'completeness：'</span>, completeness_score(y, y_pred))</span><br><span class="line">print(<span class="string">'V measure：'</span>, v_measure_score(y, y_pred))</span><br><span class="line">print(<span class="string">'AMI：'</span>, adjusted_mutual_info_score(y, y_pred))</span><br><span class="line">print(<span class="string">'ARI：'</span>, adjusted_rand_score(y, y_pred))</span><br><span class="line">print(<span class="string">'Silhouette：'</span>, silhouette_score(x, y_pred), <span class="string">'\n'</span>) <span class="comment"># 轮廓系数，1-类内距离/最小类外距离，1的时候最优，真实值也不一定是1..</span></span><br><span class="line"><span class="comment"># 聚类算法在真实的应用中一般难以获取真实的数据标签，除非手动区分，所以上述评估标准比较鸡肋，不深入解释</span></span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1.欧氏距离计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> euclidean_distances</span><br><span class="line">m = euclidean_distances(data, squared=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 返回一个n*n的矩阵计算的是亮亮之间的距离</span></span><br></pre></td></tr></table></figure></p><h2 id="Pipeline构建"><a href="#Pipeline构建" class="headerlink" title="Pipeline构建"></a>Pipeline构建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pipeline的使用是为了方便对数据处理的流程化，举个简单的example:特征变换+逻辑回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line">model = Pipeline([</span><br><span class="line">(<span class="string">'poly'</span>, PolynomialFeatures(degree = <span class="number">2</span>, include_bias = <span class="keyword">True</span>)),</span><br><span class="line">(<span class="string">'LR'</span>, LogisticRegressionCV(Cs = np.logspace(<span class="number">-3</span>, <span class="number">4</span>, <span class="number">8</span>), cv = <span class="number">5</span>, fit_intercept = <span class="keyword">False</span>))</span><br><span class="line">])</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'最优参数:  '</span>, model.get_params(<span class="string">'LR'</span>)[<span class="string">'LR'</span>].C_</span><br><span class="line"><span class="comment"># model包括两步，第一步对特征进行转换，第二步对转换好的特征进行逻辑回归模型构建</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lanchunhui/article/details/50521648" target="_blank" rel="noopener">Pipeline原理解析</a></p><h2 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> best_estimator_, RandomizedSearchCV    <span class="comment"># 0.17 grid_search</span></span><br><span class="line">model = svm.SVR(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">c_can = np.logspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">gamma_can = np.logspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">svr = GridSearchCV(model, param_grid=&#123;<span class="string">'C'</span>: c_can, <span class="string">'gamma'</span>: gamma_can&#125;, cv=<span class="number">5</span>)</span><br><span class="line">svr.fit(x, y)</span><br><span class="line">print(<span class="string">'验证参数：\n'</span>, svr.best_params_)</span><br><span class="line"><span class="comment"># cross validation交叉验证对应的参数</span></span><br><span class="line"><span class="comment"># best_params_对应model的参数，对于内部的参数通过best_params_之后再提取，比如svr中的support_</span></span><br></pre></td></tr></table></figure><h2 id="分类数据进行绘图"><a href="#分类数据进行绘图" class="headerlink" title="分类数据进行绘图"></a>分类数据进行绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.对于多分类数据进行划分区域，对坐标轴中的各个点进行预测，并对预测的点给与相应的颜色，例如对x1，x2进行绘图</span></span><br><span class="line">x1_min, x1_max = x1.min(), x1.max()</span><br><span class="line">x2_min, x2_max = x2.min(), x2.max()</span><br><span class="line">x1_array = np.arange(x1_min, x1_max, <span class="number">0.02</span>)</span><br><span class="line">x2_array = np.arange(x2_min, x2_max, <span class="number">0.02</span>)</span><br><span class="line">x1_tmp, x2_tmp = np.meshgrid(x1_array, x2_array)</span><br><span class="line">x_plot = np.stack((x1_tmp.flat, x2_tmp.flat), axis=<span class="number">1</span>) <span class="comment">#x_plot是一个列为2的数据，第一列是x轴值，第二列是y轴值</span></span><br><span class="line">y_meshgrid_hat = model.predict(x_plot)</span><br><span class="line">plt.scatter(x_plot[:,<span class="number">0</span>], x_plot[:,<span class="number">1</span>], c=y_meshgrid_hat, cmap = mpl.colors.ListedColormap([<span class="string">'#77E0A0'</span>, <span class="string">'#FF8080'</span>, <span class="string">'#A0A0FF'</span>]))</span><br><span class="line">plt.scatter(data.iloc[:,<span class="number">2</span>].values, data.iloc[:,<span class="number">3</span>].values, c=pd.Categorical(data.iloc[:,<span class="number">-1</span>]).codes, cmap = mpl.colors.ListedColormap([<span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>]))</span><br><span class="line"><span class="comment"># cmap参数是对应到不同的y_meshgrid_hat的值的颜色</span></span><br><span class="line">参考: http://sklearn.apachecn.org/cn/<span class="number">0.19</span><span class="number">.0</span>/auto_examples/linear_model/plot_iris_logistic.html<span class="comment">#sphx-glr-auto-examples-linear-model-plot-iris-logistic-py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的绘图方法</span></span><br><span class="line">x1, x2 = np.mgrid[x1_min:x1_max:<span class="number">500j</span>, x2_min:x2_max:<span class="number">500j</span>]</span><br><span class="line">cm_light = mpl.colors.ListedColormap([<span class="string">'#FF8080'</span>, <span class="string">'#80FF80'</span>, <span class="string">'#8080FF'</span>, <span class="string">'#F0F080'</span>])</span><br><span class="line">cm_dark = mpl.colors.ListedColormap([<span class="string">'r'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'y'</span>])</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span></span><br><span class="line">plt.figure(facecolor=<span class="string">'w'</span>)</span><br><span class="line">plt.pcolormesh(x1, x2, y_test, cmap=cm_light)</span><br><span class="line">plt.contour(x1, x2, y_test, levels=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), colors=<span class="string">'k'</span>, linestyles=<span class="string">'--'</span>)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], s=<span class="number">20</span>, c=y, cmap=cm_dark, edgecolors=<span class="string">'k'</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.xlabel(<span class="string">'$X_1$'</span>, fontsize=<span class="number">11</span>)</span><br><span class="line">plt.ylabel(<span class="string">'$X_2$'</span>, fontsize=<span class="number">11</span>)</span><br><span class="line">plt.xlim((x1_min, x1_max))</span><br><span class="line">plt.ylim((x2_min, x2_max))</span><br><span class="line">plt.grid(b=<span class="keyword">True</span>)</span><br><span class="line">plt.tight_layout(pad=<span class="number">2.5</span>)</span><br><span class="line">plt.title(<span class="string">'SVM多分类方法：One/One or One/Other'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.单独做legend，不推荐，需要自己去看对应的类别，如果需要绘图上的调整还是用python吧</span></span><br><span class="line">patchs = [mpatches.Patch(color=<span class="string">'red'</span>, label=<span class="string">'Iris-setosa'</span>),</span><br><span class="line">          mpatches.Patch(color=<span class="string">'green'</span>, label=<span class="string">'Iris-versicolor'</span>),</span><br><span class="line">          mpatches.Patch(color=<span class="string">'blue'</span>, label=<span class="string">'Iris-virginica'</span>)]</span><br><span class="line">plt.legend(handles=patchs, fancybox=<span class="keyword">True</span>, framealpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.对预测值和真实值进行对比</span></span><br><span class="line">y_order = y_test.argsort()</span><br><span class="line">plt.plot(np.arange(len(y_order)), y_test[y_order], <span class="string">'g-'</span>, label=<span class="string">'True'</span>)</span><br><span class="line">plt.plot(np.arange(len(y_order)), y_test_hat[y_order], <span class="string">'r-'</span>, label=<span class="string">'Predicted'</span>)</span><br><span class="line"><span class="comment"># 分别绘制真实值和预测值，看两者的差别</span></span><br></pre></td></tr></table></figure><h2 id="模型保存"><a href="#模型保存" class="headerlink" title="模型保存"></a>模型保存</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'xxx.model'</span>):</span><br><span class="line">model = joblib.load(<span class="string">'xxx.model'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">joblib.dump(model, <span class="string">'xxx.model'</span>)</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li><p>对于使用sklearn过程中出现warning的情况，可以通过使用下列代码进行warning的隐藏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure></li><li><p>对于使用jupyter notbook的同学可以使用magic命令使得画图的时候直接显示图片代替 “matplotlib.pyplot.show()”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% matplotlib inline</span><br></pre></td></tr></table></figure></li></ol><h2 id="还有一些东西没来得及总计，有机会再补充"><a href="#还有一些东西没来得及总计，有机会再补充" class="headerlink" title="还有一些东西没来得及总计，有机会再补充"></a>还有一些东西没来得及总计，有机会再补充</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;机器学习算法的实践笔记&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/sklearn.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine learning" scheme="http://WenchaoXiu.github.io/categories/Machine-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据分析2</title>
    <link href="http://WenchaoXiu.github.io/2019/03/15/ML-training/"/>
    <id>http://WenchaoXiu.github.io/2019/03/15/ML-training/</id>
    <published>2019-03-15T02:45:53.000Z</published>
    <updated>2020-02-25T03:00:12.516Z</updated>
    
    <content type="html"><![CDATA[<p class="description">“Python数据分析1”与”Python数据分析2”分别是两门课的笔记，可能有相同之处</p><a id="more"></a><h1 id="jupyter-notebook技巧"><a href="#jupyter-notebook技巧" class="headerlink" title="jupyter notebook技巧"></a><font color="red">jupyter notebook技巧</font></h1><h2 id="1-安装jupyter-notbook及其扩展"><a href="#1-安装jupyter-notbook及其扩展" class="headerlink" title="1. 安装jupyter notbook及其扩展"></a>1. 安装jupyter notbook及其扩展</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter notebook <span class="comment"># 安装anaconda之后，下载jupyter notebook</span></span><br><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions <span class="comment"># jupyter notebook扩展安装</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple autopep8 <span class="comment"># 代码自动规范化包</span></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/52890101" target="_blank" rel="noopener">jupyter extension使用参考</a></p><h2 id="2-jupyter使用设置"><a href="#2-jupyter使用设置" class="headerlink" title="2. jupyter使用设置"></a>2. jupyter使用设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输入输出情况</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">'all'</span>/<span class="string">'last_expr'</span></span><br><span class="line"><span class="comment"># matplotlib画图显示</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 使用bash命令</span></span><br><span class="line">!head -n <span class="number">5</span> xx.txt</span><br><span class="line">!ls -ltrh *</span><br></pre></td></tr></table></figure><h2 id="3-pyhton2-python3-kernel共存"><a href="#3-pyhton2-python3-kernel共存" class="headerlink" title="3. pyhton2 python3 kernel共存"></a>3. pyhton2 python3 kernel共存</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 安装anaconda3</span><br><span class="line"><span class="number">2.</span> conda create -n py27 python=<span class="number">2.7</span></span><br><span class="line"><span class="number">3.</span> source activate py27</span><br><span class="line"><span class="number">4.</span> conda install -n py27 ipykernel</span><br><span class="line"><span class="number">5.</span> python -m ipykernel install --user --name py27 --display-name <span class="string">"python2"</span></span><br></pre></td></tr></table></figure><h2 id="4-本地访问远端服务器"><a href="#4-本地访问远端服务器" class="headerlink" title="4. 本地访问远端服务器"></a>4. 本地访问远端服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sever端</span></span><br><span class="line">jupyter notebook --allow-root --port=8889 --no-browser</span><br><span class="line"><span class="comment"># local端</span></span><br><span class="line">ssh -f -N -L localhost:8000:localhost:8889 xxx@xx.xx.xx.xx -p 6666</span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">http://localhost:8000</span><br></pre></td></tr></table></figure><h1 id="Python包Pandas学习笔记"><a href="#Python包Pandas学习笔记" class="headerlink" title="Python包Pandas学习笔记"></a><font color="red">Python包Pandas学习笔记</font></h1><p><strong>最近对pandas做了一个系统的学习，主要参考了这套<a href="https://github.com/guipsamora/pandas_exercises" target="_blank" rel="noopener">习题</a>，方便后续进行python数据分析</strong></p><h2 id="1-package的载入"><a href="#1-package的载入" class="headerlink" title="1 package的载入"></a>1 package的载入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="2-数据读取-“-”暂作“或”使用"><a href="#2-数据读取-“-”暂作“或”使用" class="headerlink" title="2 数据读取(“/”暂作“或”使用)"></a>2 数据读取(“/”暂作“或”使用)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \s+是利用空白符进行分割,可使用正则表达式匹配</span></span><br><span class="line"><span class="comment"># header可以制定列明对应的行数，如果没有就是None</span></span><br><span class="line"><span class="comment"># index_col就是行名对应的列数，如果没有也是None</span></span><br><span class="line"><span class="comment"># parse_dates日期型列</span></span><br><span class="line">pd.read_csv(path, sep=<span class="string">'\s+'</span>/<span class="string">'\t'</span>/<span class="string">','</span>, header=<span class="number">0</span>/<span class="keyword">None</span>, usecols=[...], </span><br><span class="line">,parse_dates=[<span class="number">0</span>]/[<span class="string">'Date'</span>], index_col=<span class="number">0</span>/<span class="keyword">None</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="3-数据输出"><a href="#3-数据输出" class="headerlink" title="3 数据输出"></a>3 数据输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># na_rep是填充的缺失值</span></span><br><span class="line"><span class="comment"># header可以给一个list用作数据输出的列名</span></span><br><span class="line"><span class="comment"># columns可以给定数字list用于选取输出特定的列</span></span><br><span class="line">pd.to_csv(path, sep=<span class="string">''</span>, na_rep=<span class="string">'NA'</span>, header=<span class="keyword">True</span>/[<span class="string">'xx'</span>,<span class="string">'xx'</span>], index=<span class="keyword">True</span>, </span><br><span class="line">columns=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>.], encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="4-创建DataFrame-Series对象"><a href="#4-创建DataFrame-Series对象" class="headerlink" title="4 创建DataFrame,Series对象"></a>4 创建DataFrame,Series对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame和Series都接受list和numpy array数据，若要转换回array可以用df.values或S.values</span></span><br><span class="line"><span class="comment"># DataFrame还可以接受dictionary对象</span></span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">5</span>), columns=list(<span class="string">'ABCDE'</span>)) <span class="comment">#列名为ABCDE</span></span><br><span class="line">S = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h2 id="5-数据类型总结"><a href="#5-数据类型总结" class="headerlink" title="5 数据类型总结"></a>5 数据类型总结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'string'</span>: list(<span class="string">'abc'</span>),</span><br><span class="line">                   <span class="string">'int64'</span>: list(range(<span class="number">1</span>, <span class="number">4</span>)),</span><br><span class="line">                   <span class="string">'uint8'</span>: np.arange(<span class="number">3</span>, <span class="number">6</span>).astype(<span class="string">'u1'</span>),</span><br><span class="line">                   <span class="string">'float64'</span>: np.arange(<span class="number">4.0</span>, <span class="number">7.0</span>),</span><br><span class="line">                   <span class="string">'bool1'</span>: [<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>],</span><br><span class="line">                   <span class="string">'bool2'</span>: [<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">                   <span class="string">'dates'</span>: pd.date_range(<span class="string">'now'</span>, periods=<span class="number">3</span>).values,</span><br><span class="line">                   <span class="string">'category'</span>: pd.Series(list(<span class="string">"ABC"</span>)).astype(<span class="string">'category'</span>)&#125;)</span><br><span class="line">S.astype(np.int64) <span class="comment"># 数据类型转化</span></span><br><span class="line">S.dtype == np.int64 <span class="comment"># 数据类型判断</span></span><br><span class="line">S.to_frame() <span class="comment"># 将Series数据转换为DataFrame数据</span></span><br><span class="line">pd.to_datetime(df.a) <span class="comment"># 将df数据a列转换为datetime类型</span></span><br><span class="line">pd.to_numeric(aDF.loc[:, <span class="string">'xxx'</span>])  <span class="comment">#转换成数字</span></span><br></pre></td></tr></table></figure><h2 id="6-查看数据"><a href="#6-查看数据" class="headerlink" title="6 查看数据"></a>6 查看数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df.head(<span class="number">10</span>) <span class="comment"># 查看数据前10行</span></span><br><span class="line">df.tail(<span class="number">10</span>) <span class="comment"># 查看数据后10行</span></span><br><span class="line">df.shape <span class="comment"># 数据对应的行列数</span></span><br><span class="line">df.info() <span class="comment"># 数据索引，类型，内存信息</span></span><br><span class="line">df.describe(include=<span class="string">'all'</span>) <span class="comment"># 对于数字型数据进行分位数统计,all代表对所有数据类型统计</span></span><br><span class="line">S.value_counts(dropna=<span class="keyword">False</span>) <span class="comment"># 对Series里面的值进行个数统计，NA也会统计</span></span><br><span class="line">df.apply(pd.Series.value_counts) <span class="comment">#返回每个值在各列中的个数，没有则用NaN代替</span></span><br><span class="line">df.index <span class="comment"># 返回数据的索引</span></span><br><span class="line">df.columns <span class="comment"># 返回数据的列名</span></span><br><span class="line">df.mean()/min()/median()/std()/count() <span class="comment"># 分别是df的列均值,最小值,中位数,标准差,非空值</span></span><br><span class="line">df.corr() <span class="comment"># 列之间的相关系数</span></span><br><span class="line">df.idxmax(<span class="number">0</span>) <span class="comment"># 每列最大数对应行的index的名</span></span><br><span class="line">df.idxmax(<span class="number">1</span>) <span class="comment"># 每行最大数对应的列名</span></span><br><span class="line">aDF.nsmallest(columns=<span class="string">'age'</span>, n=<span class="number">20</span>) <span class="comment"># 取出年龄最小的20个数据</span></span><br><span class="line">S.is_unique <span class="comment"># 确定Series数据是否是unique的, 返回bool值</span></span><br></pre></td></tr></table></figure><h2 id="7-数据的截取"><a href="#7-数据的截取" class="headerlink" title="7 数据的截取"></a>7 数据的截取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df.xxx / df[<span class="string">'xxx'</span>] <span class="comment"># 返回数据的某一列，列名为xxx，类型为Series</span></span><br><span class="line">df[[<span class="string">'xx'</span>,<span class="string">'yy'</span>]] <span class="comment"># 选取多列数据，类型为DataFrame</span></span><br><span class="line">df.iloc[<span class="number">3</span>] <span class="comment"># 选取第4行数据</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],:] <span class="comment"># 选取多行数据</span></span><br><span class="line">df.loc[[<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>],[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]] <span class="comment">#根据行index名和列名进行数据截取</span></span><br><span class="line">df.ix[..,..] <span class="comment"># ix是用行名列名以及行数列数混合赋值的情况下数据的截取</span></span><br><span class="line">df[(df.col&gt;<span class="number">0.5</span>) &amp; (df.col&lt;<span class="number">10</span>)] <span class="comment"># 筛选col大于0.5小于10的行返回</span></span><br><span class="line">aDF.loc[(aDF[<span class="string">'a'</span>]&gt;<span class="number">10</span>) &amp; (aDF[<span class="string">'b'</span>]&lt;<span class="number">100</span>), :] <span class="comment"># 也可以给条件进行筛选,&amp; | ~进行逻辑运算</span></span><br><span class="line">df.values <span class="comment"># 返回df对应的numpy array值</span></span><br><span class="line">df.values[<span class="number">10</span>][<span class="number">5</span>] <span class="comment">#求df数据11行6列的值</span></span><br><span class="line">df[df[<span class="string">'xxx'</span>].notnull(), :] = <span class="number">10</span> <span class="comment"># 对空值赋值</span></span><br><span class="line">S.str.startswith(<span class="string">'G'</span>) <span class="comment"># Seriers以G开头的字符, 返回bool值</span></span><br><span class="line">S.isin([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]) <span class="comment"># 返回bool值如果S在list['a','b','c']中, 返回true</span></span><br><span class="line">S != <span class="string">'xxx'</span> <span class="comment"># Series中不为xxx的位置, 返回bool值</span></span><br></pre></td></tr></table></figure><h2 id="8-数据清洗"><a href="#8-数据清洗" class="headerlink" title="8 数据清洗"></a>8 数据清洗</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> df[<span class="string">'a'</span>] <span class="comment">#删除数据df的a列</span></span><br><span class="line">df.drop([<span class="string">'B'</span>,<span class="string">'C'</span>],axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>) <span class="comment"># 删除数据df的B,C列, 在原数据上进行修改</span></span><br><span class="line">df.dropna(how = <span class="string">'all'</span>, axis=<span class="number">0</span>) <span class="comment"># 对行进行操作,如果一行里面全都是na那么就删除,如果要一列里面全是na就删除,那么axis=1df.loc[:, 'newcol'] = 2000 # 如果没有newcol那么就新加一列</span></span><br><span class="line">df.columns = [<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment"># 更改数据的列名</span></span><br><span class="line">df.isnull().sum() <span class="comment"># 统计各列中缺失值的个数</span></span><br><span class="line">df.notnull().sum() <span class="comment"># 统计各列中非缺失值的个数</span></span><br><span class="line">df.drop_duplicates([...], <span class="string">'first'</span>/<span class="string">'last'</span>/<span class="keyword">False</span>) </span><br><span class="line"><span class="comment"># 移除重复项, list可以是列名也可以是数字序列,first是保留重复中的第一个, last是保留重复中的最后一个, False一个不留, 只要重复都删除</span></span><br><span class="line">df.dropna(axis=<span class="number">0</span>/<span class="number">1</span>, how=<span class="string">'any'</span>/<span class="string">'all'</span>, thresh=n)</span><br><span class="line"><span class="comment"># 移除数据中的缺失行,axis0是行删除,1是列删除</span></span><br><span class="line"><span class="comment"># any是只要有一个就删除,all是所有的都是才删除</span></span><br><span class="line"><span class="comment"># thresh目的是大于n个NA才删除</span></span><br><span class="line">S.fillna(x) <span class="comment"># 对确实值进行填充,填充值为x</span></span><br><span class="line">aDF.loc[:,<span class="string">'xx'</span>].fillna(aSeires) <span class="comment"># 对数据进行填充,根据aSeires的index和aDF的index进行填充</span></span><br><span class="line">S.astype(np.float) <span class="comment"># 数据的类型转换</span></span><br><span class="line">S.replace(<span class="number">1</span>, <span class="string">'one'</span>) <span class="comment"># 将1替换为'one'</span></span><br><span class="line">S.replace([<span class="number">1</span>,<span class="number">2</span>], [<span class="string">'one'</span>,<span class="string">'two'</span>]) <span class="comment"># 将1替换为one, 2替换为two</span></span><br><span class="line">df.rename(index/columns=&#123;<span class="string">'old1'</span>:<span class="string">'new1'</span>,<span class="string">'old2'</span>:<span class="string">'new2'</span>&#125;) <span class="comment"># 修改行名列名，将old1改为new1，将old2改为new2</span></span><br><span class="line">df.set_index(<span class="string">'B'</span>) <span class="comment"># 修改index，将B所在的列作为行索引</span></span><br><span class="line">df.sort_index() <span class="comment"># 将数据按照index进行排序</span></span><br><span class="line">df.sort_values([col1, col2], ascending=[<span class="keyword">True</span>,<span class="keyword">False</span>]) <span class="comment"># 根据col1和col2的值进行排序，col1是升序，col2是降序</span></span><br><span class="line">S.argsort() <span class="comment"># 返回Series对应的值的order，S[S.argsort()]返回的是对应的从小到大的Series数值</span></span><br><span class="line">df.reset_index(drop=<span class="keyword">False</span>/<span class="keyword">True</span>, inplace=<span class="keyword">False</span>/<span class="keyword">True</span>) <span class="comment"># 数据的index换成从0开始的, drop是说是否保留原来的index, 保留的话就多一列, inplace是说是否修改原来的df</span></span><br><span class="line">data[<span class="string">'Age'</span>] = pd.cut(data[<span class="string">'Age'</span>], bins=<span class="number">6</span>, labels=np.arange(<span class="number">6</span>)) <span class="comment"># 对数值型数据进行区间分割，分割成6个bin，label用0-5表示</span></span><br><span class="line">np.tile(a, N).flatten() <span class="comment"># 对数据a进行重复</span></span><br></pre></td></tr></table></figure><h2 id="9-数据分组"><a href="#9-数据分组" class="headerlink" title="9 数据分组"></a>9 数据分组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(col).size() <span class="comment"># 按照col对数据进行分组，并计算每一组的数量, 如果是count的话每列都会计算一次分组后的数量, 比较冗余</span></span><br><span class="line">df.groupby([col1, col2]).mean() <span class="comment"># 按照col1,col2进行分组，并计算各组的均值</span></span><br><span class="line">df.groupby([col1, col2]).agg([<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>]) <span class="comment"># 按照col1col2进行分组，计算各组之间的min, max, mean</span></span><br><span class="line">df.groupby([col1, col2]).agg(&#123;<span class="string">'a'</span>:<span class="string">'min'</span>, <span class="string">'b'</span>:<span class="string">'max'</span>, <span class="string">'c'</span>:<span class="string">'mean'</span>&#125;) <span class="comment"># 按照col1col2进行分组，计算各组之间的a列的min, b列的max, c列的mean</span></span><br><span class="line">df.groupby(col1)[col2].mean() <span class="comment"># 计算按照col1分组的col2对应的均值</span></span><br><span class="line">df.pivot.table(index=col1, values=[col2, col3], aggfun=<span class="string">'mean'</span>) <span class="comment"># 以col1的值为index,以col2,col3值为列进行分组计算各元素平均值</span></span><br><span class="line">df.apply(np.mean) <span class="comment"># 计算每一列的平均值</span></span><br><span class="line">df.apply(np.max, axis=<span class="number">1</span>) <span class="comment">#计算每一行的平均值</span></span><br><span class="line">df.applymap(<span class="keyword">lambda</span> x : x.upper()) <span class="comment"># 对多列数据操作, 这里是对各列都大写</span></span><br><span class="line"><span class="keyword">for</span> name,data <span class="keyword">in</span> df.groupby(<span class="string">'col'</span>):</span><br><span class="line"><span class="keyword">print</span> name <span class="comment"># col列分类后的值</span></span><br><span class="line"><span class="keyword">print</span> data <span class="comment"># col列名称等于name对应的数据行</span></span><br><span class="line">df.groupby(<span class="string">'name'</span>).apply(ownfunc) <span class="comment"># 可以对不同组进行自定义函数操作</span></span><br></pre></td></tr></table></figure><h2 id="10-数据合并"><a href="#10-数据合并" class="headerlink" title="10 数据合并"></a>10 数据合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1.append([df2, df3])  <span class="comment"># 也可以追加两个DF</span></span><br><span class="line">pd.concat([df1.set_index(<span class="string">'a'</span>), df2.set_index(<span class="string">'a'</span>)], sort=<span class="keyword">False</span>, axis=<span class="number">1</span>, join=<span class="string">'inner'</span>) <span class="comment"># 和上述利用merge在a字段上进行内连接的效果类似,因为concat是基于index进行连接的,merge可以不基于index,指定字段</span></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>) <span class="comment">#列数相同, 行合在一起</span></span><br><span class="line">pd.concat(frames, keys=[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>], axis=<span class="number">0</span>) <span class="comment">#行数相同, 列合在一起, 每个数据的来源分别标注xyz</span></span><br><span class="line">pd.merge(df1, df2, on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>], how=<span class="string">'outer'</span>/<span class="string">'inner'</span>/<span class="string">'left'</span>/<span class="string">'right'</span>) <span class="comment"># 合并df1和df2,根据df1的key1和df2的key2, 连接方式是外链接..</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">'inner'</span>, left_index=<span class="keyword">True</span>, right_on=<span class="string">'id'</span>) <span class="comment"># 对数据进行merge,左表以index作为连接关键字,右表用id作为关键字</span></span><br><span class="line">np.vstack((a,b)) <span class="comment"># 乱入一个numpy合并用法，行合并</span></span><br><span class="line"><span class="comment"># pd.join与merge用法类似, 只不过默认是left链接, merge是inner连接</span></span><br></pre></td></tr></table></figure><div style="display: none"><br>### 2.1 div的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">users = pd.read_table(<span class="string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>, </span><br><span class="line">        sep=<span class="string">'|'</span>, index_col=<span class="string">'user_id'</span>)</span><br><span class="line">total = users.groupby([<span class="string">'occupation'</span>]).gender.count() <span class="comment"># 计算occupation的对应的人数</span></span><br><span class="line">gender = users.groupby([<span class="string">'occupation'</span>,<span class="string">'gender'</span>]).gender.count() <span class="comment"># 计算各职业各性别的人数</span></span><br><span class="line">(gender.div(total, level=<span class="string">'occupation'</span>)*<span class="number">100</span>).unstack() <span class="comment">#计算各职业的各性别的百分比</span></span><br></pre></td></tr></table></figure><br><br></div><h2 id="11-时序数据操作"><a href="#11-时序数据操作" class="headerlink" title="11 时序数据操作"></a>11 时序数据操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df.index = pd.date_range(<span class="string">'2018/1/1'</span>, period=df.shape[<span class="number">0</span>]) <span class="comment"># 添加时间序列作为行名</span></span><br><span class="line">pd.to_datetime(df.a, format=<span class="string">'%Y'</span>) <span class="comment"># 将df的a列转化成datetime类型的年</span></span><br><span class="line">pd.to_datetime(<span class="number">1490195805</span>, unit=<span class="string">'s'</span>) <span class="comment"># 对UNIX时间进行时间转换</span></span><br><span class="line">df[<span class="string">'a'</span>].to_datetime().year/month/day <span class="comment"># df的a列转换为datetime类型之后提取其中的year或者month或者day</span></span><br><span class="line">(df[<span class="string">'a'</span>].to_datetime().max() - df[<span class="string">'a'</span>].to_datetime().min()).days <span class="comment"># 计算a列中最早最晚时间差</span></span><br><span class="line">df[<span class="string">'Date'</span>].dt.dayofweek <span class="comment"># 获取每周第几天</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line">dt.datetime(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 通过datetime包定义数据时间</span></span><br><span class="line">dt.datetime.today() <span class="comment"># 返回今天对应的时间</span></span><br><span class="line"></span><br><span class="line">df.resample(<span class="string">'10AS'</span>).sum() </span><br><span class="line"><span class="comment"># downsample时序数据, 频率是每10年算各列的加和, S是index从1月1日开始, 不加S则从12月30日开始</span></span><br><span class="line"><span class="comment"># resample的各个字符含义: A-year, M-month, W-week, D-day, H-hour, T-minute, S-second</span></span><br></pre></td></tr></table></figure><p>除了downsample也可以upsample需要插值, 具体使用参考<a href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.resample.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="绘图命令"><a href="#绘图命令" class="headerlink" title="绘图命令"></a><font color="red">绘图命令</font></h1><h2 id="1-pandas内置绘图"><a href="#1-pandas内置绘图" class="headerlink" title="1. pandas内置绘图"></a>1. pandas内置绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.plot.bar() <span class="comment"># barplot, stacked=True, 堆叠</span></span><br><span class="line">df.plot.barh() <span class="comment"># 绘制水平的barplot</span></span><br><span class="line">df.plot.hist(bins = <span class="number">20</span>) <span class="comment"># 绘制直方图,单维度</span></span><br><span class="line">df.plot.box() <span class="comment"># 对每列去看一些分布outlier</span></span><br><span class="line">df.plot.area() <span class="comment"># 堆叠区域图</span></span><br><span class="line">df.plot.scatter(x=<span class="string">'a'</span>, y=<span class="string">'b'</span>) <span class="comment"># 散点图</span></span><br><span class="line">df.plot.pie(subplots=<span class="keyword">True</span>) <span class="comment"># 绘制带图例的饼图</span></span><br></pre></td></tr></table></figure><h2 id="2-matplotlib绘图的一些设置"><a href="#2-matplotlib绘图的一些设置" class="headerlink" title="2. matplotlib绘图的一些设置"></a>2. matplotlib绘图的一些设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>)) <span class="comment"># 设置画布大小</span></span><br><span class="line">plt.xticks([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>], [<span class="string">r'a'</span>,<span class="string">r'b'</span>,<span class="string">r'c'</span>]) <span class="comment"># 设置坐标轴刻度</span></span><br><span class="line">plt.xlim(<span class="number">1</span>,<span class="number">3</span>) <span class="comment"># 设置坐标位置</span></span><br><span class="line">plt.title() <span class="comment"># 标题</span></span><br><span class="line">plt.xlabel(<span class="string">'xxx'</span>, fontsize=<span class="number">18</span>) <span class="comment"># 绘制label</span></span><br><span class="line">plt.text(<span class="number">0.8</span>, <span class="number">0.9</span>, <span class="string">'xxx'</span>, color=<span class="string">'k'</span>, fontsize=<span class="number">15</span>) <span class="comment"># 进行注解</span></span><br><span class="line">plt.grid(<span class="keyword">True</span>) <span class="comment"># 网格线</span></span><br></pre></td></tr></table></figure><h2 id="3-seaborn绘图"><a href="#3-seaborn绘图" class="headerlink" title="3. seaborn绘图"></a>3. seaborn绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- sns.displot(x, kde=<span class="keyword">True</span>, bins=<span class="number">20</span>, rug=<span class="keyword">True</span>, fit=stats.gamma) <span class="comment"># histgram加密度线,样本分布情况, 拟合某些分布fit</span></span><br><span class="line">- sns.kdeplot <span class="comment"># 类似于上面的,kde是每个样本用正态分布画,如果样本多,高度就高,之后再做归一化</span></span><br><span class="line">- sns.jointplot(x,y,data) <span class="comment"># 绘制带有histgram以及散点图的图，两个变量</span></span><br><span class="line">- sns.pairplot(df) <span class="comment"># 直接绘制各个列之间的散点图以及对应的histgram，多个变量</span></span><br><span class="line">- 多图绘制<span class="number">1</span></span><br><span class="line">  g = sns.PairGrik(df) <span class="comment"># 各个列混合,产出n*n个格子</span></span><br><span class="line">  g.map_diag(sns.kdeplot) <span class="comment"># 对角线绘制</span></span><br><span class="line">  g.map_offdiag(sns.kdeplot, cmap=<span class="string">'Blues_d'</span>, n_levels=<span class="number">20</span>) <span class="comment"># 绘制对角线是kde密度图其他为等高线的图</span></span><br><span class="line">- 多图绘制<span class="number">2</span></span><br><span class="line">  g = FaceGrid(row=[..],aspect=<span class="number">1.5</span>, data=)</span><br><span class="line">  g.map(sns.boxplot, x, y, hue, hue_order=[], ...)</span><br><span class="line">- 多图绘制<span class="number">3</span></span><br><span class="line">  g = sns.PairGrid(data, x_vars=[], y_vars=[], aspect=<span class="number">0.5</span>, size=<span class="number">3.5</span>)</span><br><span class="line">  g.map(sns.violinplot, palette=<span class="string">'bright'</span>) <span class="comment"># x_vars数量*y_vars数量个子图，然后每个子图都绘制violinplot</span></span><br><span class="line">- 关联分析 sns.lmplot</span><br><span class="line">  · sns.lmplot(x, y, data) <span class="comment"># 散点图+线性回归,95%置信区间,适用于连续值</span></span><br><span class="line">- sns.residplot() <span class="comment"># 残差图</span></span><br><span class="line">- sns.barplot(x,y,hue,ci=<span class="keyword">None</span>)  <span class="comment"># 是否打开置信区间</span></span><br><span class="line">- sns.stripplot(x, y, data, jitter =<span class="keyword">True</span>) <span class="comment"># 基于x为离散数据的,类似于散点图的boxplot</span></span><br><span class="line">- sns.swarmplot(x, y, data) <span class="comment">#  蜂群图，类似于小提琴图的点版</span></span><br><span class="line">- sns.boxplot()</span><br><span class="line">- sns.violinplot(bw) <span class="comment"># 属于kde以及boxplot的组合，既看了单变量分布，也看了各变量之间的差异</span></span><br><span class="line">- sns.violinplot(split=<span class="keyword">True</span>， hue， inner=<span class="string">'stick'</span>) <span class="comment"># split将hue为两个类型的进行拼接绘制小提琴图，stick，每个样本绘制竖线</span></span><br><span class="line">- sns.countplot(x, data) <span class="comment"># 绘制离散变量数量分布，类似于value_counts()，类似于barplot但是使用的统计量是数量</span></span><br><span class="line">- sns.pointplot(x, y, hue) <span class="comment"># 查看离散变量x以及hue在离散变量y上的差别，使用均值，画点</span></span><br><span class="line">- sns.factorplot(x, y, hue, col, data, kind=<span class="string">'swarm'</span>) <span class="comment"># 是一种泛化的绘图函数</span></span><br><span class="line">- a.savefig(<span class="string">'xx'</span>) <span class="comment"># 进行图片存储 plt函数</span></span><br></pre></td></tr></table></figure><h2 id="4-一些图形实例"><a href="#4-一些图形实例" class="headerlink" title="4. 一些图形实例"></a>4. 一些图形实例</h2><h3 id="4-1-barplot"><a href="#4-1-barplot" class="headerlink" title="4.1 barplot"></a>4.1 barplot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 绘图包的载入</span></span><br><span class="line">% matplotlib inline <span class="comment"># 内嵌画图, 有这个命令就可以省去plt.show()</span></span><br><span class="line">Series.plot(kind = <span class="string">'bar'</span>) <span class="comment"># 绘制条形图</span></span><br><span class="line">plt.xlabel(<span class="string">'xxx'</span>) <span class="comment"># 加x轴label</span></span><br><span class="line">plt.ylabel(<span class="string">'yyy'</span>) <span class="comment"># 加y轴label</span></span><br><span class="line">plt.title(<span class="string">'zzz'</span>) <span class="comment"># 加标题</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p1.png" alt="p1"></p><h3 id="4-2-scatter-plot"><a href="#4-2-scatter-plot" class="headerlink" title="4.2 scatter plot"></a>4.2 scatter plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, s=size, c=<span class="string">'green'</span>) <span class="comment"># 绘制散点图, s表明点大小, c表示点的颜色, 这两个参数都可以是list</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p2.png" alt="p2"></p><h3 id="4-3-pie-chart"><a href="#4-3-pie-chart" class="headerlink" title="4.3 pie chart"></a>4.3 pie chart</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie([...], labels=[...], colors=[...], explode=(...), startangle=<span class="number">90</span>) <span class="comment"># 饼图的参数都是list, explode参数是为了让饼图不同类之间有空隙的参数</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p3.png" alt="p3"></p><h3 id="4-4-分组scatter-plot"><a href="#4-4-分组scatter-plot" class="headerlink" title="4.4 分组scatter plot"></a>4.4 分组scatter plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.lmplot(x=<span class="string">'age'</span>, y=<span class="string">'Fare'</span>, data=df, hue=<span class="string">'sex'</span>, fit_reg=<span class="keyword">False</span>) <span class="comment"># 绘制以age和Fare为xy轴的散点图, 以性别分类</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p4.png" alt="p4"></p><h3 id="4-5-histgram"><a href="#4-5-histgram" class="headerlink" title="4.5 histgram"></a>4.5 histgram</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(S, bins=np.arange(<span class="number">0</span>, <span class="number">600</span>, <span class="number">10</span>)) <span class="comment"># 绘制直方图, bin可以自己定义</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">a = sns.dstplot(S) <span class="comment"># 绘制直方图, 带一条正态拟合曲线</span></span><br><span class="line">a.set(xlabel=<span class="string">''</span>, ylabel=<span class="string">''</span>, title=<span class="string">''</span>) <span class="comment"># 设定label</span></span><br><span class="line">sns.despline() <span class="comment"># 去掉右侧上侧的边框</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p5.png" alt="p5"></p><h3 id="4-6-correlation-plot"><a href="#4-6-correlation-plot" class="headerlink" title="4.6 correlation plot"></a>4.6 correlation plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df) <span class="comment">#绘制带correlation散点图+histgram</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p6.png" alt="p6"></p><h3 id="4-7-pairwise散点图"><a href="#4-7-pairwise散点图" class="headerlink" title="4.7 pairwise散点图"></a>4.7 pairwise散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(df) <span class="comment"># 多列数据绘制散点图</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p7.png" alt="p7"></p><h3 id="4-8-分类boxplot图"><a href="#4-8-分类boxplot图" class="headerlink" title="4.8 分类boxplot图"></a>4.8 分类boxplot图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df, hue=<span class="string">''</span>) <span class="comment"># 分类box plot, hue是类别</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p8.png" alt="p8"></p><h3 id="4-9-分类boxplot点图"><a href="#4-9-分类boxplot点图" class="headerlink" title="4.9 分类boxplot点图"></a>4.9 分类boxplot点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df, hue=<span class="string">'sex'</span>, jitter=<span class="keyword">True</span>...) </span><br><span class="line"><span class="comment"># 绘制类似于boxplot的图，只不过画的是每个box里面的点, x轴是不同数据类</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p9.png" alt="p9"></p><h1 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a><font color="red">大数据知识</font></h1><h2 id="1-hadoop"><a href="#1-hadoop" class="headerlink" title="1. hadoop"></a>1. hadoop</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /input/example1 <span class="comment"># 将用于处理的文件上传到集群中，集群自动分配</span></span><br><span class="line">hadoop fs -put text* /input/example1 <span class="comment"># 查看文件是否放好</span></span><br><span class="line">hadoop fs -ls /input/example1 <span class="comment"># 集群上跑任务</span></span><br><span class="line">hadoop jar /usr/lib/hadoop-current/share/hadoop/tools/lib/hadoop-streaming-2.7.2.jar \</span><br><span class="line">  -file count_mapper.py \ <span class="comment"># 将这个文件传到集群上一会会使用</span></span><br><span class="line">  -mapper count_mapper.py \ <span class="comment"># 将这个文件充当mapper处理</span></span><br><span class="line">  -file count_reducer.py \</span><br><span class="line">  -reducer count_reducer.py \</span><br><span class="line">  -input /input/example1 \ <span class="comment"># 以终端的方式将文件一个个的传给命令</span></span><br><span class="line">  -output /output/example1 </span><br><span class="line">hadoop fs -getmerge /output/example1 result.txt <span class="comment"># 运行成功之后将结果拉下来，将hadoop执行完成的结果存在/output/</span></span><br></pre></td></tr></table></figure><h2 id="2-pyspark-基于spark"><a href="#2-pyspark-基于spark" class="headerlink" title="2. pyspark(基于spark)"></a>2. pyspark(基于spark)</h2><h3 id="2-1-初始化RDD的方法"><a href="#2-1-初始化RDD的方法" class="headerlink" title="2.1 初始化RDD的方法"></a>2.1 初始化RDD的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 第一种方式直接通过内置的数据类型进行读取</span><br><span class="line">  import pyspark</span><br><span class="line">  form pyspark import SparkContext <span class="comment"># 驱动</span></span><br><span class="line">  from pyspark import SparkConf <span class="comment"># 基本配置，内存多少，任务名称</span></span><br><span class="line">  conf = SparkConf().setAppName(<span class="string">"miniProject"</span>).setMaster(<span class="string">"local[*]"</span>) <span class="comment"># 应用名称miniProject，路径在本地</span></span><br><span class="line">  sc = SparkContext.getOrCreate(conf) <span class="comment"># 对上面的应用进行初始化，如果有的话直接取过来，没有的话就创建</span></span><br><span class="line">  my_list = [1,2,3,4,5]</span><br><span class="line">  rdd = sc.parallelize(my_list) <span class="comment"># 并行化一个RDD数据，rdd是不可以直接看见，是一个对象，看不到内容</span></span><br><span class="line">  rdd.getNumPartitions() <span class="comment"># 存了多少份</span></span><br><span class="line">  rdd.glom().collect() <span class="comment"># 查看分区状况，collect是一个比较危险的命令，会把集群上的内容取到本地以列表返回，存在当前机器的内存中，可能会瞬间爆掉</span></span><br><span class="line"></span><br><span class="line">- 第二种通过本地文件进行读取</span><br><span class="line">  rdd = sc.textFile(<span class="string">"file://"</span>+os.getcwd()+<span class="string">'/nd.txt'</span>) <span class="comment"># 一定要将"file//"+绝对路径的这个文件，注意这种读取是以每一行为一个元素的读取，每个元素作为一个item</span></span><br><span class="line">  rdd = sc.wholeTextFiles(<span class="string">"file"</span>+cwd+<span class="string">"/names"</span>) <span class="comment"># 整个文件夹的内容(多个文件)进行读取, 对/names里面所有的文本进行读取，注意~这个时候读入的内容就是以元组内容进行组织的，(文件名,文件内容)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-RDD的操作"><a href="#2-2-RDD的操作" class="headerlink" title="2.2 RDD的操作"></a>2.2 RDD的操作</h3><p><strong>Spark的transformations命令(非立即执行)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- map() <span class="comment"># 对RDD上的每个元素都进行同一操作，一进一出</span></span><br><span class="line">- flatMap() <span class="comment"># 对RDD中的item执行同一个操作之后得到一个list，然后以平铺的方式把list里所有的结果组成新的list，也就是一进多出</span></span><br><span class="line">- filter() <span class="comment"># 筛选出满足条件的item</span></span><br><span class="line">- distinct() <span class="comment"># 对RDD中item去重</span></span><br><span class="line">- sample() <span class="comment"># 从RDD中进行采样</span></span><br><span class="line">- sortBy(keyfunc=lambda (x,y):y, ascending=False <span class="comment"># 对RDD中的item进行排序</span></span><br><span class="line">- takeSample(3) <span class="comment"># 采样</span></span><br><span class="line">- map与flatmap之间的差别</span><br><span class="line">  strRDD = sc.parallelize([<span class="string">'hello world'</span>, <span class="string">'ni hao'</span>])</span><br><span class="line">  strRDD.map(lambda x: x.split(<span class="string">' '</span>)) <span class="comment"># 返回的是[['hello', 'world'], ['ni', 'hao']]</span></span><br><span class="line">  strRDD.flatMap(lambda x: x.split(<span class="string">' '</span>)) <span class="comment"># 返回的是[['hello', 'world', 'ni', 'hao']]</span></span><br><span class="line">- RDD数据的Transformation可以一个接一个的串联</span><br><span class="line">  def myfunc(x):</span><br><span class="line">    <span class="keyword">if</span> x%2==1:</span><br><span class="line">      <span class="built_in">return</span> 2*x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">return</span> x</span><br><span class="line">  numberRDD = sc.parallelize(range(1,11)) <span class="comment"># 1-10</span></span><br><span class="line">  retRDD = (numberRDD.map(myfunc).filter(lambda x: x&gt;6).distinct())</span><br><span class="line">  retRDD.collect() <span class="comment"># 返回所有的结果</span></span><br><span class="line">- RDD之间的操作</span><br><span class="line">  rdd1.union(rdd2) <span class="comment"># 并集, 类似于两个list相加</span></span><br><span class="line">  rdd1.intersection(rdd2) <span class="comment"># 交集, 类似于python中的&amp;</span></span><br><span class="line">  rdd1.substract(rdd2) <span class="comment"># 差集,类似于python中的-</span></span><br><span class="line">  rdd1.cartesian(rdd2) <span class="comment"># 笛卡尔乘积,类似于排列组合的所有元素，python中的product</span></span><br></pre></td></tr></table></figure></p><p><strong>Spark的action命令(立即执行)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- collect <span class="comment"># 危险！list形式返回</span></span><br><span class="line">- first() <span class="comment"># 返回第一个item</span></span><br><span class="line">- take(n) <span class="comment"># 返回n个item</span></span><br><span class="line">- count() <span class="comment"># 计算RDD中item的个数</span></span><br><span class="line">- top(n) <span class="comment"># 自然序排序取前n个</span></span><br><span class="line">- reduce(n) <span class="comment"># 做聚合</span></span><br></pre></td></tr></table></figure></p><p><strong>pairRDD操作</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 基本操作</span><br><span class="line">  reduceByKey() <span class="comment"># 对所有有着相同key的items执行reduce操作</span></span><br><span class="line">  groupByKey() <span class="comment"># 返回类似于(key, listOfValues)这种元组RDD，后面的value list是同一个key下面的</span></span><br><span class="line">  sortByKey() <span class="comment"># 按照key进行排序</span></span><br><span class="line">  countByKey() <span class="comment"># 按照key对item进行个数统计</span></span><br><span class="line">  countByValue() <span class="comment"># 按照value对item进行个数统计</span></span><br><span class="line"> collectAsMap() <span class="comment"># 与collect类似，返回的是k-v字典</span></span><br><span class="line">- 不同pairRDD之间进行关联</span><br><span class="line">  RDD1 = sc.parallelize([(<span class="string">'a'</span>,1), (<span class="string">'b'</span>,2), (<span class="string">'c'</span>,3)])</span><br><span class="line">  RDD1 = sc.parallelize([(<span class="string">'b'</span>,20), (<span class="string">'c'</span>,30), (<span class="string">'d'</span>,40)])</span><br><span class="line">  RDD1.join(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行连接</span></span><br><span class="line">  RDD1.leftOuterJoin(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行左连接，RDD1作为主导</span></span><br><span class="line">  RDD1.rightOuterJoin(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行左连接，RDD2作主导</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-初始化Spark-DataFrame的方法"><a href="#2-3-初始化Spark-DataFrame的方法" class="headerlink" title="2.3 初始化Spark DataFrame的方法"></a>2.3 初始化Spark DataFrame的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- 创建SparkSession类</span><br><span class="line">  from pyspark.sql import SparkSession</span><br><span class="line">  spark = SparkSession.builder.appName(<span class="string">'Python Spark SQL'</span>)\</span><br><span class="line">    .config(<span class="string">'spark.some.config.option'</span>, <span class="string">'some-value'</span>)\</span><br><span class="line">    .getOrCreate() <span class="comment"># 利用spark SQL构建一个入口</span></span><br><span class="line">- 关闭创建好的spark入口</span><br><span class="line">  spark.stop() <span class="comment"># 因为不能同时存在多个入口</span></span><br><span class="line">- 文件的读取</span><br><span class="line">  在SparkSession中可以从一个已存在的RDD或者hive表或者Spark数据源中创建一个DataFrame</span><br><span class="line">  df = spark.read.csv(<span class="string">"/path/to/your.csv"</span>) <span class="comment"># 读入csv文件</span></span><br><span class="line">- DataFrame操作</span><br><span class="line">  df.show() <span class="comment"># 展示数据</span></span><br><span class="line">  df.printSchema() <span class="comment"># 类似于Pandas里面的df.info()函数</span></span><br><span class="line">  df.describe([...]) <span class="comment"># 对list里面的各列进行统计</span></span><br><span class="line">  df.select([<span class="string">'name'</span>, <span class="string">'age'</span>]).show() <span class="comment"># 选两列</span></span><br><span class="line">  df.select(df[<span class="string">'name'</span>], df[<span class="string">'age'</span>]+1).show() <span class="comment"># 选取name这列同时age这列+1</span></span><br><span class="line">  df.filter(df[<span class="string">'age'</span>]&gt;21).show() <span class="comment"># 对数据进行filter</span></span><br><span class="line">  df.groupBy(<span class="string">'age'</span>).count().show() <span class="comment"># 对年龄分组同时统计人数，count类似于size</span></span><br><span class="line">  df.groupBy(<span class="string">'age'</span>).agg(...).show() <span class="comment"># 类似于pandas中的用法</span></span><br><span class="line">  df.select(<span class="string">'xx'</span>, df[<span class="string">'xx'</span>].cast(...).<span class="built_in">alias</span>(...)) <span class="comment"># 类型转换+重命名</span></span><br><span class="line">  df.withColumn(<span class="string">'xxx'</span>, ...) <span class="comment"># 对列进行处理同时产生新的列xxx</span></span><br><span class="line">  df.orderBy(<span class="string">'xxx'</span>, ascending=False) <span class="comment"># 对某列进行排序</span></span><br><span class="line">  df.filter(df[<span class="string">'value'</span>].isNull()).count() <span class="comment"># isNull空值处理</span></span><br><span class="line">  df.withColumn(<span class="string">'sex'</span>, lit(<span class="string">'man'</span>))) <span class="comment"># lit是用来产生独立的数据的</span></span><br><span class="line">  from pyspark.sql.functions import f <span class="comment"># 有很多内置的函数,包括udf自定义函数</span></span><br><span class="line">- 时间操作</span><br><span class="line">  df.withColumn(<span class="string">'day'</span>, dayofmonth(<span class="string">'time'</span>)) <span class="comment"># dayofmonth等函数的使用，这些函数也是内置在pyspark.sql.functions中的</span></span><br><span class="line">- 类型转换</span><br><span class="line">  RDD.toDF() <span class="comment"># RDD类型转换为spark DataFrame类型</span></span><br><span class="line">  scDF.toPandas() <span class="comment"># 转换spark DataFrame到pandas DataFrame</span></span><br><span class="line">  RDD = scDF.select(<span class="string">'col1'</span>, <span class="string">'col2'</span>).rdd.map(lambda r: (r[0], r[1])) <span class="comment"># spark DataFrame转RDD</span></span><br></pre></td></tr></table></figure><h3 id="2-4-初始化Spark-DataFrame的方法"><a href="#2-4-初始化Spark-DataFrame的方法" class="headerlink" title="2.4 初始化Spark DataFrame的方法"></a>2.4 初始化Spark DataFrame的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意DataFrame不是一个表，所以如果想用SQL的方式进行表的查询的时候需要事先构建一个表</span></span><br><span class="line">df.createOrReplaceTemView(<span class="string">'sqltable'</span>)</span><br><span class="line">sqlDF = spark.sql(<span class="string">'SELECT * FROM sqltable'</span>) <span class="comment"># 使用SQL的方式对数据进行提取，spark是自己创建的，返回的结果还是DataFrame</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      记录了Python, Numpy, Pandas, Hadoop, Spark等基本使用
    
    </summary>
    
      <category term="Data Analysis" scheme="http://WenchaoXiu.github.io/categories/Data-Analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>Python数据分析1</title>
    <link href="http://WenchaoXiu.github.io/2019/02/03/DataAnalysis/"/>
    <id>http://WenchaoXiu.github.io/2019/02/03/DataAnalysis/</id>
    <published>2019-02-03T14:31:19.000Z</published>
    <updated>2020-02-25T02:53:00.504Z</updated>
    
    <content type="html"><![CDATA[<p class="description">“Python数据分析1”与”Python数据分析2”分别是两门课的笔记，可能有相同之处</p><a id="more"></a><h1 id="jupyter-notebook使用"><a href="#jupyter-notebook使用" class="headerlink" title="jupyter notebook使用"></a>jupyter notebook使用</h1><pre><code>1. 安装jupyter notbook扩展    conda install jupyter notebook    conda install -c conda-forge jupyter_contrib_nbextensions     pip install -i https://pypi.tuna.tsinghua.edu.cn/simple autopep8     pip安装加速镜像:https://www.cnblogs.com/microman/p/6107879.html    jupyter 使用参考资料:https://zhuanlan.zhihu.com/p/33105153    jupyter extension 参考资料:https://zhuanlan.zhihu.com/p/528901012.jupyter魔法命令    %quickref # 所有magic命令     %lsmagic # 打印所有magic命令     %config ZMQInteractiveShell.ast_node_interactivity=&apos;all&apos;/&apos;last_expr&apos;    %pprint # 打印所有结果,保证每次执行都输出,默认只输出最后一个内容    %config ZMQInteractiveShell可以查看可选择的输出类型    或者执行这个命令保证多输出    from IPython.core.interactiveshell import InteractiveShell    InteractiveShell.ast_node_interactivity = &apos;all&apos;/&apos;last_expr&apos;     %%整个cell magic    %%writefile test.py # 将cell中的命令写入文件test.py    %%timeit代码计时    %%bash # 在cell内可以执行bash命令    %%writefile xx.py # 把整个cell中的内容输入到xx.py中,如果新加内容可以%%writefile -a xx.py    %line magic命令    %matplotline inline # 在jupyter内打印图片    %run utils.ipynb # 执行本地的utils.ipynb文件,进行配置    line magic和cell magic区别就在于line magic只在一行有效,cell magic在多行都有效    具体参考:https://gispark.readthedocs.io/zh_CN/latest/pystart/jupyter_magics.html3. jupyter 使用linux命令    !head -n 5 xx.txt # 直接通过jupyter行使linux命令</code></pre><h1 id="python基本知识"><a href="#python基本知识" class="headerlink" title="python基本知识"></a>python基本知识</h1><pre><code>1.运行方式    解释运行:直接py脚本运行    交互运行:jupyter输入一个输出一个2.命名规则:    常量大写，下划线隔开单词    类用驼峰命名     del xx 删除变量xx3.操作优先级：    函数调用，寻址，下标    幂运算    翻转运算符    正负号    * / %    - + 4.赋值    多重赋值:a=b=10相当于a=10,b=10    多元赋值 a,b,c = 1,2,3    交换赋值 a,b = b,a # 指针5.解包(需要拓展 参考:https://zhuanlan.zhihu.com/p/33896402?utm_source=wechat_session&amp;utm_medium=social&amp;s_r=0)    l1 = [1,2,3,4,5,&apos;6&apos;]; a,b,*c,d = l1    l1=[1,2,3,4];b=&apos;sdaad&apos;;[*l1,*b]    b,=[[3,4,5]] # 逗号解包 6.python进制及基本类型    bin() 二进制    oct() 八进制    hex() 十六进制    float(&apos;inf&apos;) 正无穷7.字符串    .format() # 字符串格式化    amount = 1234; f&apos;请转账给我{amount:,.2f}元&apos; # 字符串格式化    具体参考:https://zhuanlan.zhihu.com/p/37936007    str3.find() # 查找    str3.replace(&apos;a&apos;,&apos;b&apos;) # a替代b    str3.count(&apos;xx&apos;) # xx出现的个数8.list对象    append和extend的区别    sorted(alist, reverse=True,key=len/str.lower) # 对每个元素进行function,然后返回值排序9.元组/集合/字典    元组不能修改    只有一个元素的的元组需要加逗号,如(1,)    集合是{}包含的内容,默认返回的是不重复且排序的值    adic.get(&apos;xxx&apos;,123) # 返回key为xxx的值,如果没有的话返回123    od = OrderedDict();od[&apos;z&apos;]=&apos;x&apos;;od[&apos;a&apos;]=&apos;b&apos;;od[&apos;c&apos;]=&apos;f&apos; # 有序排列的字典10. 表达式    exec执行声明语句,如 exec(&apos;a=5&apos;)    eval执行表达式, 如 eval(&apos;a+5&apos;)    三元判断表达式, &apos;a&apos; if a&gt;50 else &apos;b&apos;    列表推导式, [i+1 for i in alist if i&gt;10], [0 if x&gt;5 else 0 for i in range(10)] # 如果只有if，放在后面，如果if/else都有的话，放在前面    列表迭代器: x = iter(alist); x.__next__()或者next(x),类似于链表    生成器:函数生成,列表表达式生成????????????????????????????????????11. python中的异常处理    基本用法:        try:            ..... # 尝试执行这里        except Exception as e:            .... # 异常的话执行这里        else:            ... # 如果没有异常就会执行这里        finally:            .... # 无论有没有错误都会执行    py2/py3之间差别        try        escept Exception as e: # py3        escept Exception, e: # py212. python函数    a,b = b,a+b,记住这个方便操作，值互换，因为python中全部都是引用，按从右向左执行，所以可以这样做    变长参数函数:def xxx(a, *args): # xxx(....),第一个参数传给a,后面有几个参数都传给args    匿名函数: 通过lambda执行,sum = lambda x,y:x+y    高阶函数        a. filter, list(filter(afunc, alist)),基于这个afunc对alist进行过滤,需要在前面加list()是python3的规则,因为是个filter的对象        b. map,映射,list(map(afunc, alist)),对alist中所有元素依次做afunc操作        c. reduce, 两两处理,相当于贪吃蛇,依次利用前一次操作结果和现在元素做同样的操作,如:reduce(add, alist),add自己定义的需要两个参数的求和函数,这要会不断求和,效果就是对alist各元素进行累加13. 文件写入    f.writelines([&apos;dawd\n&apos;,&apos;dada\n&apos;]) # 多行写入14. 目录操作    import os    os.path.abspath(&apos;.&apos;) # 当前绝对路径    os.mkdir(&apos;aaaaaa&apos;) # 新建文件夹    os.rename(&apos;file.txt&apos;, &apos;file2.txt&apos;) # 将file.txt重命名为file2.txt    [i for i in os.listdir(&apos;.&apos;) if os.path.isdir(i)] # 输出当前文件夹下所有的文件夹    [i for i in os.path.listdir(&apos;.&apos;) if os.path.isfile(i) and os.path.splitext(i)[1]==&apos;.py&apos;] # 判断是否是py文件15. 三方库    !pip install pillow # 图像相关库,安装相关库    from PIL import Image    im = Image.open(&apos;xxx.png&apos;)    print(im.format, im.size, im.mode) # 图片的一些属性    im.show() # 图片显示,弹窗显示    im.thumbnail(400, 100) # 对图像进行resize    im.save(&apos;xxx.jpg&apos;, &apos;JPEG&apos;) # 将resize的图片存成JPEG格式</code></pre><h1 id="python正则表达式"><a href="#python正则表达式" class="headerlink" title="python正则表达式"></a>python正则表达式</h1><pre><code>1.正则表达式的match与search区别    https://segmentfault.com/a/11900000067360332.贪婪匹配与非贪婪匹配的区别    https://segmentfault.com/a/1190000002640851    https://blog.csdn.net/lxcnn/article/details/47560303. 练习网站    https://alf.nu/RegexGolf 一个正则表达式练习网站    https://regexr.com/ 验证网站4. 单字符匹配    . # 匹配出点换行符之外的任意字符    \. # 匹配单个.字符    [abd] # 匹配a/b/d单个字符    \d # 匹配数字, 相当于[1,2,3,4,5,6,7,8,9]    \D # 所有非字符    \s # 空白符,空格 tab等等    \S # 所有非空格    \w # a-z,A-Z,0-9,_    \W # 除了 a-z,A-Z,0-95. 数量词用来多匹配    m{2} # 表示匹配两个m    m{2,4} # 表示匹配2/3/4个m,贪婪匹配    m* # 0个或者更多个,贪婪匹配    m+ # 1个或者更多个,贪婪匹配    m? # 0个或者1个    ^xx # 文本开头是xx进行匹配    xxx$ # 对结尾进行匹配    (re)su(lt) # group6. python中的正则表达式步骤    写一个文本pattern    进行匹配    对匹配的文本进行后续操作    例子:        import re        pattern = re.compile(r&apos;hello.*\!&apos;) # hello后面有若干个字符串直到有!        match = pattern.match(&apos;hello, xxx! how are you?&apos;) # 对文本进行匹配        if match: # 是否匹配            print match.group() # 如果匹配上了返回相应的匹配到的部分7. 使用实例    import re    re.compile(r&quot;&quot;&quot;    \d+ # 数字部分    \. # 小数点    \d # 小数部分    &quot;&quot;&quot;, re.X)    这种模式下可以写注解    re.compile(r&quot;\d+\.\d&quot;) # 与这个模式结果一样8.一些命令    match # 一次匹配结果,从头匹配,开头没有就匹配不上了    search # 所有匹配到的    findall # search返回第一个匹配的结果,findall会返回所有的结果    m=re.match()    m.string # 匹配的字符串    m.group(1,2) # 匹配1和2处字符串9. 替换和分割     split也可以使用正则表达式进行分割        p = re.compile(r&apos;\d+&apos;)        p.split(&apos;adwdwad1dawwd23dwadw&apos;) # 字符串复杂分割    sub # 用来替换        p = re.compile(r&apos;(\w+) (\w+)&apos;)        p.sub(r&apos;\2 \1&apos;, s) # 匹配字符串并且在匹配到的字符串处进行前后颠倒     subn # 和sub类似,只不过除了返回替换的远足之外,还返回相应的替换次数,可以p.subn(afunc, s), afunc可以自己定义</code></pre><h1 id="numpy的使用"><a href="#numpy的使用" class="headerlink" title="numpy的使用"></a>numpy的使用</h1><pre><code>1. 优点:向量化数据操作比for循环,速度大大加强，numpy array比list好的地方在于切片2. array属性    np.random.random((2,2)) # 0-1随机数    np.random.randint(1,10,(3,3)) # 随机整数    array.shape, array.dtype # numpy两个属性    array.astype(np.float64) # 类型转换3. array切片操作    a[0,1] # 第一个维度为0,第二个维度1,第三个维度全选,类似于a[0,1,:]    a[a&gt;2] # boolean indexing, 利用broadcasting进行判断, 之后可以作为index进行数据的提取    a[a&gt;2]=0 # 也可以对满足条件的元素进行赋值4. array数学运算    broadcasting, 对不匹配的数据在高维上进行扩展,在取最小公倍数    np.sum(array) # 统计运算    np.dot # 矩阵乘法,点乘    np.multiply  # 逐个元素乘法,对应相乘</code></pre><h1 id="Pandas的使用"><a href="#Pandas的使用" class="headerlink" title="Pandas的使用"></a>Pandas的使用</h1><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><pre><code>1. 基本概念    pd.__version__ # 查看版本    pd.Series # 可以使用不同类型,和list区别在于有index, 可以指定index2. Series构建    pd.Series([1,2,3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])    pd.Series({...}, name=&quot;xxx&quot;) # 通过对dictionary进行构建pandas, 给Series赋予名字3. 切片    aseries[[1,4,3]]; aseries[1:]; aseries[:-1]  # 数字下标切片,即使index不是数字也ok4. 运算规则    series的相加是根据index对应相加的5. 取值    数学运算也是broadcasting方式    &apos;xxx&apos; in aseries # 判断xxx是否在aseries的index中    aseries.get(&apos;xxx&apos;, 0) # 类似于字典    aseries[aseries&lt;20] # boolean index也可以    aseries.median() # 除去缺失值之后进行统计运算    aseries[&apos;xxx&apos;] = 1000 # 对aseries[&apos;xxx&apos;]重新赋值    np.square(aseries) # 对每个运算进行计算平方</code></pre><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><pre><code>1. 基本概念    一组Series集合在一起2. DataFrame的构建    - pd.DataFrame({&apos;a&apos;:[1,2,3], &apos;b&apos;:[1,4,3]}, columns = [&apos;b&apos;, &apos;a&apos;], index = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]) # 构建DF, 指定列名以及index名    - pd.DataFrame([{&apos;a&apos;:100,&apos;b&apos;:200}, {&apos;a&apos;:200, &apos;b&apos;:300}], index=[&apos;one&apos;, &apos;two&apos;]) # 按照一行一行构建DF    - pd.DataFrame({&apos;a&apos;:seriesa, &apos;b&apos;:seriesb} # 记住按照index对齐, 缺失值直接Nan填充3. 元素的提取以及增加及逻辑操作及转置    - aDF[&apos;xxx&apos;]/aDF.xxx # 取出来的是一个Series    - aDF[[&apos;xxx&apos;]] # 取出来的是一个DF    - aDF.loc([&apos;a&apos;,&apos;b&apos;],[&apos;c&apos;,&apos;d&apos;]) # 取对应的数据    - aDF.loc[:, &apos;newcol&apos;] = 2000 # 如果没有newcol那么就新加一列    - aDF.loc[(aDF[&apos;a&apos;]&gt;10) &amp; (aDF[&apos;b&apos;]&lt;100), :] # 也可以给条件进行筛选,&amp; | ~进行逻辑运算    - aDF.T # 进行转置4. 数据读入以及基本信息以及删除    - pd.read_csv(path, sep=&apos;\t&apos;, index_col=&apos;&apos;/int, usecols=[...], header=0, parse_dates=[0]/[&apos;Date&apos;]) # 读文件，第一列作为日期型，日期型处理参照: http://hshsh.me/post/2016-04-12-python-pandas-notes-01/    - aDF.to_csv(&apos;xxx.csv&apos;, sep=&apos;\t&apos;, index=True, header=True) # 写文件    - aDF.describe(include=[np.float64...]) / aDF.info() # 对数据进行统计，查看缺失值    - aDF.shape    - aDF.isnull() # 判断是是否为空    - aDF[aDF[&apos;xxx&apos;].isnull(), :] = 10 # 对空值赋值    - aDF.notnull() # 查看是否有值    - aDF.drop([&apos;one&apos;, &apos;two&apos;], axis=0) # 对index为one和two的两行进行删除, axis=1删除列5. 数据分组聚合    - aDF.groupby(&apos;name&apos;, sort=False).sum() # 对DF进行聚合操作,同时对相应聚合的列进行排序,然后计算其他值的和    - groupbyname=aDF.groupby(&apos;name&apos;); groupbyname.groups; len(groupbyname) # 得到对应的各个组别包含的index, 并且可以获取对应的group长度    - aDF.groupby(&apos;name&apos;).agg([np.sum, np.mean, np.std]) # 对不同类别的数据进行各类运算, 每个name对应三列分别是分组之后np.sum, np.mean, np.std计算    - aDF.groupby(&apos;name&apos;).agg([&apos;sum&apos;, &apos;median&apos;, &apos;mean&apos;]) # 和上面的作用相同    - aDF.groupby(&apos;name&apos;).agg([&apos;a&apos;:np.sum, &apos;b&apos;:median, &apos;c&apos;:np.mean]) # 对不同列进行不同操作    - aDF.groupby([&apos;name&apos;, &apos;year&apos;]).sum()/mean()/median()/describe() # 多组分类    - aDF.groupby([&apos;name&apos;, &apos;year&apos;]).size() # 多组分类, 每一组有多少个记录    - 提取group类别名称以及类别对应的数据行        for name,group in groupbyname:            print(name) # 类别名称            print(group) # 名称对应的数据行        groupbyname.get_group(&apos;jason&apos;) # 可以得到对应组别的数据行,DF格式6. transform/apply/filter 数据变换    transfrom可以对分组进行变换, apply对整个DF进行分类,filter对分组进行判断    - aDF[&apos;Date&apos;].dt.dayofweek # 可以得到对应的日期中的第几天    - aDF.groupby(aDF.index.year).mean() # 可以对相应的日期型的年进行分组聚合    - aDF.groupby(aDF.index.year).transform(lambda x: (x-x.mean())/x.std()) # 对每一年的数据求均值以及标准差,并对每个数据进行操作,之所以没以每年为单位进行展示主要是跟function有关,因为之前的是mean之类的    - aDF.groupby(aDF.index.year).apply(lambda x: (x-x.mean())/x.std()) # 可以起到相同的效果    - aDF.loc[:,&apos;new&apos;] = aDF[&apos;xxx&apos;].apply(afunc) # 可以对xxx这一列进行操作按照afunc进行操作,然后创建新的列    - aSer = pd.Series([1,1,2,2,2,3,3,4,5,5]); sSer.groupby(sSer).filter(lambda x:x.sum()&gt;4) # 对ser进行过滤,留下那些和大于4的类别7. 表格的拼接与合并(concat/append/merge/join)    - df1.append(df2, sort=False, ignore_index=True) # 追加在行上,同时忽略原先df1和df2的index,合并为新的index    - df1.append([df2, df3])  # 也可以追加两个DF, 参考: https://zhuanlan.zhihu.com/p/38184619    - pd.concat([df1.set_index(&apos;a&apos;), df2.set_index(&apos;a&apos;)], sort=False, axis=1, join=&apos;inner&apos;) # 和上述利用merge在a字段上进行内连接的效果类似,因为concat是基于index进行连接的,merge可以不基于index,指定字段    - pd.concat([df1, df2, df3], keys=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], axis=0, join=&apos;outer&apos;, sort=False) #列对齐的方式对行进行拼接,缺少值则补充为None,可以对拼接的每个df进行key的命名,axis=1的时候行对齐列拼接; join指定连接方式,outer表示外连接,inner表示内连接,sort是否对合并的数据进行排序    - merge # 基于某个字段进行连接,之前的append和concat都是在行上或者列上进行连接的,merge类似于SQL里面的连接,可以指定某个字段或某几个字段,体现在on上,on接list就是多个字段为key    - pd.merge(df1, df4, on=&apos;city&apos;, how=&apos;outer&apos;/&apos;inner&apos;/&apos;left&apos;/&apos;right&apos;) # 基于两个表中的city字段进行表格的连接,把其他的列进行combine到一起,不指定on的话就会找字段相同的那个进行拼接,注意concat是基于index进行拼接的    - pd.merge(df1, df2, how=&apos;inner&apos;, left_index=True, right_on=&apos;id&apos;) # 对数据进行merge,左表以index作为连接关键字,右表用id作为关键字8. Case study流程    - aDF.groupby(&apos;a&apos;).agg({&apos;xx&apos;:&apos;count&apos;, &apos;ccc&apos;:np.mean}).rename(columns={&apos;old&apos;:&apos;new&apos;}) # 查看以a为分组xx的数量,以及ccc的均值,对old进行重新的命名叫做new    - pd.to_numeric(aDF.loc[:, &apos;xxx&apos;])  #转换成数字    - pd.merge(df1, df2, how=&apos;inner&apos;, left_index=True, right_on=&apos;id&apos;) # 对数据进行merge,左表以index作为连接关键字,右表用id作为关键字    - aDF.sort_values(by=[&apos;a&apos;,&apos;b&apos;], ascending=False)  # 进行排序依据这两个字段ab,倒序排列    - !head -n 5 xx.txt # 直接通过jupyter行使linux命令    - pd.read_csv(&apos;xxx&apos;, encoding=&apos;latin-1&apos;,sep=&apos;\t&apos;) # 对数据进行编码指定    - aDF.dropna(how = &apos;all&apos;, axis=0) # 对行进行操作,如果一行里面全都是na那么就删除,如果要一列里面全是na就删除,那么axis=1    - aDF.loc[:,&apos;xx&apos;].fillna(aSeires) # 对数据进行填充,根据aSeires的index和aDF的index进行填充    - aDF.plot(grid=True) # 对折线图绘制,同时加上网格    - pd.DataFrame({&apos;xx&apos;:aDF[&apos;xx&apos;].bfill(), &apos;yy&apos;:aDF[&apos;yy&apos;].bfill(), }) # 对数据填充,backfill,对前面空值用后面有值处进行填充    - aDF[aDF.index &gt;= aDF.xx.first_valid_index()] # 找到xx列最初非nan值的行,然后取出这行之后的所有行    - aDF.resample(&apos;M&apos;).last() # reample是对数据进行重新采样，一月份为单位，类似于groupby统计一个月的数据，.last是统计这个月所在group的最后一个记录8. 链家Case study流程    - pd.to_datetime() # 日期类型转换    - df.drop(droplist, inplace=True, axis=1) # 删除一些列    - aDF.describe(include=&apos;all&apos;) # 字符串变量也会同时统计    - aDF.sort_values(by = &apos;xxx&apos;).tail() # 找出更新最晚的20套,但是有可能同一天超过20套    - 如果对数据进行处理发现转换未果可能是因为数据有缺失,做异常处理,缺失值作为Nan    - aDF.nsmallest(columns=&apos;age&apos;, n=20) # 取出年龄最小的20个数据    - groupby().agg() 之后一般会使用reset_index() 对数据进行归置然后再进行操作,ascending=False    - adf.value_counts(normalize=True) # 默认是按照value进行排序的    - aDF.apply(lambda x: &apos;xxx&apos; in x) # 筛选出xxx在某列的值中与否,返回Ture, False，正则表达式的字符串匹配    - 可以定义正则表达式对文本信息进行提取        def get_info(s, pattern, n):            result = re.search(pattern, s)            if result:                return result.group(n)            else:                return &apos;&apos;    - .astype(int) # 转换pd类型    - help(pd.Series.value_counts) # 打印帮助文档</code></pre><h1 id="python绘图"><a href="#python绘图" class="headerlink" title="python绘图"></a>python绘图</h1><pre><code>1. pandas 绘图    - pd.date_range(&apos;2018/12/28&apos;, periods=10) # 产生日期格式, 以2018/12/28为起始产生以天为单位的日期时间list    - pandas绘图需要把横坐标作为index,之后再画图    - 折线图绘制需要注意各列幅度，否则数值不明显    - df.plot.bar() # barplot, stacked=True, 堆叠    - df.plot.barh() # 绘制水平的barplot    - df.plot.hist(bins = 20) # 绘制直方图,单维度    - df.plot.box() # 对每列去看一些分布outlier    - df.plot.area # 堆叠区域图    - df.plot.scatter(x=&apos;a&apos;, y=&apos;b&apos;) # 散点图    - df.plot.pie(subplots=True) # 绘制带图例的饼图2. matplotlib 绘图    - plt.rcParams[&apos;figure.figsize&apos;] = (12,8) / plt.figure(figsize=(12,8)) # 设置画布大小    - ax = plt.plot(x,y,color=&apos;green&apos;, linewidth=&apos;-&apos;, marker=&apos;./*/x&apos;, label=r&apos;$y=cos{x}$&apos;/r&apos;$y=sin{x}$&apos;/r&apos;$y=\sqrt{x}$&apos;) # 绘图    - ax.spines[&apos;right&apos;].set_color(&apos;none&apos;) # 去掉右边的边框    - ax.xaxis.set_ticks_position(&apos;bottem&apos;) # ??????????????    - plt.xticks([2,4,6], [r&apos;a&apos;,r&apos;b&apos;,r&apos;c&apos;]) # 设置坐标轴刻度    - ax.spines[&apos;bottem&apos;].set_position(&apos;data&apos;, 0)  # 设置坐标轴从0开始    - plt.xlim(1,3) # 设置坐标位置    - plt.title() # 标题    - plt.xlabel(r&apos;xxx&apos;, fontsize=18, labelpad=12.5) # 绘制label, r值的是不转义的,$$值的是markdown格式    - plt.text(0.8, 0.9, r&apos;$$&apos;, color=&apos;k&apos;, fontsize=15) # 进行注解    - plt.scatter([8], [8], 50, color=&apos;m&apos;) # 在某个位置,点有多大,颜色是什么    - plt.annotate(r&apos;$xxx$&apos;, xy=(8,8), xytext=(8.2, 8.2), fontsize=16, color=&apos;m&apos;, arrowprops=dict(arrowstyle=&apos;-&gt;&apos;, connectionstyle=&apos;arc3, rad=0.1&apos;, color=&apos;m&apos;)) # 对某个点进行注解, 进行加箭头等等    - plt.grid(True) # 网格线     - plt.plot(x, y) # xy应为np array,如果是pandas那么可以通过values进行取值转换3. matplotlib 绘图case    - 文件解压        x = zipfile.ZipFile(xxx, &apos;r&apos;) # 解压文件夹        x.extractall(&apos;xxxdir&apos;) # 解压到某个文件夹下        x.close() # 记得关闭    - matplotlib.rc(&apos;figure&apos;, figsize=(14,7)) # 设置一下图片尺寸    - matplotlib.rc(&apos;font&apos;, size=14) # 设置字体    - matplotlib.rc(&apos;axes.spines&apos;, top=False, right=False) # 设置边线    - matplotlib.rc(&apos;axes&apos;, grid=False) # 设置网格    - matplotlib.rc(&apos;axes&apos;, facecolor=&apos;white&apos;) # 设置颜色    - fig,ax含义        fig,ax = plt.subplots() # 创建绘图对象之后对ax进行操作，相当于先fig=plt.figure()再ax=fig.add_subplot(1,1,1)        https://blog.csdn.net/htuhxf/article/details/82986440    - ax.fill_between(x, low, upper, alpha=) # 对回归进行置信度绘制    - ax2 = ax1.twinx() # 共享同一个x轴    - ax2.spines[&apos;right&apos;].set_visible(True) # 对右侧坐标轴进行设置,得到相应的图    - 图的使用        关联分析:散点图,曲线图,置信区间曲线图,双坐标曲线图        分布分析:堆叠直方图, 密度图        组间分析:柱状图(带errorbar),boxplot,这个需要多看看,4. seaborn 绘图    - 引入seaborn的同时也要引入matplotlib因为,是底层    - 颜色设置        sns.set(color_codes=True) # 一些集成的颜色        https://seaborn.pydata.org/tutorial/color_palettes.html    - sns.displot(x, kde=True, bins=20, rug=True, fit=stats.gamma) # histgram加密度线,样本分布情况, 拟合某些分布fit    - sns.kdeplot # 类似于上面的,kde是每个样本用正态分布画,如果样本多,高度就高,之后再做归一化    - sns.jointplot(x,y,data) # 绘制带有histgram以及散点图的图，两个变量    - sns.pairplot(df) # 直接绘制各个列之间的散点图以及对应的histgram，多个变量    - scatter plot的密度版        with sns.axes_style(&apos;ticks&apos;):            sns.jointplot(x,y,data, kind=&apos;hex&apos;/&apos;kde&apos;,color=&apos;m&apos;) #相当于对点很多的时候,六角箱图就能体现出点的多少,kde是等高线,密度联合分布    - 多图绘制1        g = sns.PairGrik(df) # 各个列混合,产出n*n个格子        g.map_diag(sns.kdeplot) # 对角线绘制        g.map_offdiag(sns.kdeplot, cmap=&apos;Blues_d&apos;, n_levels=20) # 绘制对角线是kde密度图其他为等高线的图    - 多图绘制2        g = FaceGrid(row=[..],aspect=1.5, data=)        g.map(sns.boxplot, x, y, hue, hue_order=[], ...)    - 多图绘制3        g = sns.PairGrid(data, x_vars=[], y_vars=[], aspect=0.5, size=3.5)        g.map(sns.violinplot, palette=&apos;bright&apos;) # x_vars数量*y_vars数量个子图，然后每个子图都绘制violinplot    - 关联分析 sns.lmplot        · sns.lmplot(x, y, data) # 散点图+线性回归,95%置信区间,适用于连续值        · sns.lmplot(x, y, data, x_jitter=0.08) # 左右抖动, 点如果离得近,会把点左右抖动开,适用于离散值        · sns.lmplot(x, y, data, x_estimator=np.mean, ci=95, scatter_kws={&apos;s&apos;:80}, order=2, robust=True) # 对于离散值还可以这样操作,先求均值和95置信区间,之后再进行拟合, scatter_kws对点进行操作,order是说对数据点进行二次方的分布,而不是线性分布,robust打开的作用是踢除异常点,然后再进行绘制图        · sns.lmplot(x, y, data, x_estimator=np.mean, ci=95, scatter_kws={&apos;s&apos;:80}, order=1, robust=True, logistic=True) # 相当于是说对二值化的数据进行logistic回归拟合,sigmoid拟合        · sns.lmplot(x, y, data, hue, col, row, col_wrap, aspect=0.5) # 散点图.线性回归,95%置信区间,适用于连续值,hue进行分组类似于pandas里面的groupby, hue变量一定是个离散变量, col也可以加一个变量,可以把图分成多列,row可以多行,如果row,col以及hue都指定,那么相当于在pandas里面groupby三个内容,col_wrap用于之指定每个col中的绘图数量    - sns.residplot() # 残差图    - sns.barplot(x,y,hue,ci=None)  # 是否打开置信区间    - sns.stripplot(x, y, data, jitter =True) # 基于x为离散数据的,类似于散点图的boxplot    - sns.swarmplot(x, y, data) #  蜂群图，类似于小提琴图的点版    - sns.boxplot()    - sns.violinplot(bw) # 属于kde以及boxplot的组合，既看了单变量分布，也看了各变量之间的差异    - sns.violinplot(split=True， hue， inner=&apos;stick&apos;) # split将hue为两个类型的进行拼接绘制小提琴图，stick，每个样本绘制竖线    - sns.countplot(x, data) # 绘制离散变量数量分布，类似于value_counts()，类似于barplot但是使用的统计量是数量    - sns.pointplot(x, y, hue) # 查看离散变量x以及hue在离散变量y上的差别，使用均值，画点    - sns.factorplot(x, y, hue, col, data, kind=&apos;swarm&apos;) # 是一种泛化的绘图函数    - a.savefig(&apos;xx&apos;) # 进行图片存储 plt函数</code></pre><h1 id="大数据基本知识"><a href="#大数据基本知识" class="headerlink" title="大数据基本知识"></a>大数据基本知识</h1><pre><code>- 基本软件    hadoop HDFS（hadoop distributed file systems）# 存储    Map-reduce # 计算框架，用于进行数据分析，思想    Hive # 数据库，类似于mysql    strom # 时延小实时的，吞吐量小    Flink # 吞吐量大- 重点学习，批处理，    hadoop的HDFS的相关知识和操作命令，Hadoop map-reduce的计算核心思想，    spark的RDD(弹性分布式数据集)核心，transformation和action，基于DataFrame的操作，Spark SQL</code></pre><h1 id="Hadoop数据"><a href="#Hadoop数据" class="headerlink" title="Hadoop数据"></a>Hadoop数据</h1><pre><code>- hadoop介绍    namenode # 存储相应的datanode的信息    datanode # 存储数据，有冗余的存储，多个block，通常每个64M    MapReduce  # 在每个DataNode上做操作(map),最后比较DataNode上比较好的数据(reduce)- hadoop集群命令    hadoop fs -ls / # 显示集群/下的所有信息    hadoop fs -lsr / # 递归显示所有文件夹和子文件夹    hadoop fs -mkdir /user/hadoop # 创建/user/hadoop文件夹    hadoop fs -put a.txt /user/hadoop # 把a.txt放到集群上的/user/hadoop文件夹下    hadoop fs -get /user/hadoop/a.txt / # 把集群上的a.txt拉到本地上来    hadoop fs -cp src dst # 在集群上复制文件src和dst都是集群上的文件夹    hadoop fs -mv src dst # 在集群上进行文件移动    hadoop fs -cat /user/hadoop/a.txt # 查看集群上的文件    hadoop fs -rm /user/hadoop/a.txt # 删除集群上文件    hadoop fs -rmr /user/hadoop/ # 删除集群该目录上的所有文件    hadoop fs -copyFromLocal localsrc dst # 与hadoop fs -put的功能类似    hadoop fs -moveFromLocal localsrc dst # 将本地文件上传到hdfs并且删除本地文件</code></pre><h1 id="map-reducer"><a href="#map-reducer" class="headerlink" title="map-reducer"></a>map-reducer</h1><pre><code>可以利用bash shell命令进行本地测试- 介绍以词频统计来说，因为hdfs只能一行一行的进行读取，所以可以利用两个脚本分别作为mapper和reducer来进行词频统计，map用于将文本中每一个词都进行输出，以键值对这种形式，当然因为每次只统计单个词所以，输出的词频都为1。经历了mapper以后之后会经历sort排序，这个是内部完成的。最后会进行reducer步骤，当然也要通过一个python脚本进行执行，这个python脚本读取的也是上一行的标准输出，每次读一个键值对，因为键值对已经排好序了，所以直接基于排序进行逐行读取统计，如果遇到新词就把原来的词进行输出，同时当前的词进行更新。这样就完成了map-sort-reduce的脚本。-至于具体执行    # 本地测试结果    head -n 200 text1.txt|python count_mapper.py|sort|python count_reducer.py     # 创建文件夹，如果存在删除，hadoop fs -rmr /input/example1    hadoop fs -mkdir /input/example1     # 将用于处理的文件上传到集群中，集群自动分配    hadoop fs -put text* /input/example1    # 查看文件是否放好    hadoop fs -ls /input/example1    # 集群上跑任务    hadoop jar /usr/lib/hadoop-current/share/hadoop/tools/lib/hadoop-streaming-2.7.2.jar \    -file count_mapper.py \ # 将这个文件传到集群上一会会使用    -mapper count_mapper.py \ # 将这个文件充当mapper处理    -file count_reducer.py \    -reducer count_reducer.py \    -input /input/example1 \ # 以终端的方式将文件一个个的传给命令    -output /output/example1     # 运行成功之后将结果拉下来    hadoop fs -getmerge /output/example1 result.txt # 将hadoop执行完成的结果存在/output/example1这里面，然后将里面的子文件全部都合并，存到本地命名为result.txt文件</code></pre><h1 id="spark核心概念与操作"><a href="#spark核心概念与操作" class="headerlink" title="spark核心概念与操作"></a>spark核心概念与操作</h1><pre><code>1. 优点    可以实现map-reduce，支持数据挖掘，图运算，流式计算(实时)，SQL的多种框架(批量造特征)    基于内存，试用于迭代多次的运算    能与Hadoop的HDFS文件系统相结合，能运行在YARN上2. 一些概念    RDD时如何完成transformation和action的、高版本的Spark的DataFrame的操作    SparkContext(驱动程序)，ClusterManager(集全资源管理器)和Excutor(任务执行进程)    所有的spark上的操作都会转化为，RDD弹性分布式的数据集上的突然transformation和action    RDD可以类似于numpy的array或者pandas的series或者python的list3. 初始化RDD的方法    - 第一种方式直接通过内置的数据类型进行读取        import pyspark        form pyspark import SparkContext # 驱动        from pyspark import SparkConf # 基本配置，内存多少，任务名称        conf = SparkConf().setAppName(&quot;miniProject&quot;).setMaster(&quot;local[*]&quot;) # 应用名称miniProject，路径在本地        sc = SparkContext.getOrCreate(conf) # 对上面的应用进行初始化，如果有的话直接取过来，没有的话就创建        my_list = [1,2,3,4,5]        rdd = sc.parallelize(my_list) # 并行化一个RDD数据，rdd是不可以直接看见，是一个对象，看不到内容，因为数据被分发到各个位置。注意python的list或者numpy array或者pandas的Series/DataFrame都可以转化成RDD        rdd.getNumPartitions() # 存了多少份        rdd.glom().collect() # 查看分区状况，collect是一个比较危险的命令，会把集群上的内容取到本地以列表返回，存在当前机器的内存中，可能会瞬间爆掉    - 第二种通过本地文件进行读取        # 存储在本地服务器的文件进行读取(假设本地读取的文件为:&quot;/name/example1.txt&quot;)            # 单个文件进行读取            import os            cwd = os.getcwd()            rdd = sc.textFile(&quot;file://&quot;+os.getcwd()+&apos;/nd.txt&apos;) # 一定要将&quot;file//&quot;+绝对路径的这个文件，注意这种读取是以每一行为一个元素的读取，每个元素作为一个item            rdd.first() # 对读入文件进行查看，第一行            # 整个文件夹的内容(多个文件)进行读取            rdd = sc.wholeTextFiles(&quot;file&quot;+cwd+&quot;/names&quot;) # 对/names里面所有的文本进行读取，注意~这个时候读入的内容就是以元组内容进行组织的，(文件名,文件内容)            rdd.first() # 第一个元素就是文件名+文件内容            rdd.count() # 统计RDD文件的行数    - 其余初始化方式        HDFS上的文件        Hive中的数据库与表        Spark SQL得到的结果4. RDD的transformations和actions    - map() 对RDD上的每个元素都进行同一操作，一进一出    - flatMap() 对RDD中的item执行同一个操作之后得到一个list，然后以平铺的方式把list里所有的结果组成新的list，也就是一进多出    - filter() 筛选出满足条件的item    - distinct() 对RDD中item去重    - sample() 从RDD中进行采样    - sortBy() 对RDD中的item进行排序    - collect() 如果直接获取相应的结果可以使用rdd.collect()对结果组织成list进行获取    - 例子        numberRDD = sc.parallelize(range(1, 11))        print numberRDD.collect()        squaresRDD = numberRDD.map(lambda x:x**2) # 对所有数据进行平方，可以自己定义个函数        print squaresRDD.collect()        filteredRDD = numberRDD.filter(lambda x:x%2==0) # 对所有数据进行筛选，返回True对应的元素    - map与flatmap之间的差别        strRDD = sc.parallelize([&apos;hello world&apos;, &apos;ni hao&apos;])        strRDD.map(lambda x: x.split(&apos; &apos;)) # 返回的是[[&apos;hello&apos;, &apos;world&apos;], [&apos;ni&apos;, &apos;hao&apos;]]        strRDD.flatMap(lambda x: x.split(&apos; &apos;)) # 返回的是[[&apos;hello&apos;, &apos;world&apos;, &apos;ni&apos;, &apos;hao&apos;]]    - RDD数据的Transformation可以一个接一个的串联        def myfunc(x):            if x%2==1:                return 2*x            else:                return x        numberRDD = sc.parallelize(range(1,11)) # 1-10        retRDD = (numberRDD.map(myfunc).filter(lambda x: x&gt;6).distinct())        retRDD.collect() # 返回所有的结果    - RDD之间的操作        rdd1.union(rdd2) # 并集, 类似于两个list相加        rdd1.intersection(rdd2) # 交集, 类似于python中的&amp;        rdd1.substract(rdd2) # 差集,类似于python中的-        rdd1.cartesian(rdd2) # 笛卡尔乘积,类似于排列组合的所有元素，python中的product5. Spark的核心是惰性计算，各种transformation不会立即生效，不像pandas的操作一样，他会重新组织你的transformation，这样可以避免一系列的中间结果。6. Spark的唤醒机制，就是各种action命令    - collect # 危险！list形式返回    - first() # 返回第一个item    - take(n) # 返回n个item    - count() # 计算RDD中item的个数    - top(n) # 自然序排序取前n个    - reduce(n) # 做聚合    - 例子        rdd = sc.parallelize(range(1,11))        rdd.reduce(lambda x,y : x+y) # 注意！这个会立即执行，类似于python高阶函数reduce    sc.stop() # 停止sparkContext7. Spark中的cache()命令，如果一遍一遍计算的话，需要开销，所以可以通过cache命令将他们存储在内存中    - 例子        import numpy as np        numberRDD = sc.parallelize(np.linspace(1.0, 10.0, 10))        squareRDD = numberRDD.map(lambda x: x**2)        squareRDD.cache() # 表明如果squareRDD这个对象第一次action了之后，就直接将其写入缓存，将中间结果存一下，这样后面计算的时候不用再激活，就不会很耗时        avg = squareRDD.reduce(lambda x,y:x+y)/squareRDD.count() # 计算平均值，如果不写cache的话会导致action执行两次，会比较耗时8. 复杂结构的transformation和action    - 介绍        基本的存储结构，用来进行统计词频，主要是以(key,value)进行组织的，把这种形式叫做pair RDDS        记住依然以list形式进行组织，只不过list的每个元素长成(key,value)这种形式        针对这种数据结构定义了一些transformation和action        reduceByKey() # 对所有有着相同key的items执行reduce操作        groupByKey() # 返回类似于(key, listOfValues)这种元组RDD，后面的value list是同一个key下面的        sortByKey() # 按照key进行排序        countByKey() # 按照key对item进行个数统计        collectAsMap() # 与collect类似，返回的是k-v字典    - 例子        rdd = sc.parallelize([&apos;ni hao&apos;, &apos;wo bu hao&apos;, &apos;na ni ne&apos;])            retRDD = (rdd.flatmap(lambda x:x.split(&apos; &apos;))                .map(lambda x:x.lower())                .map(lambda x:(x,1))                .reduceByKey(lambda x,y:x+y)) # 类似于groupby+aggregate        retRDD.collect() # 对上述词频统计的结果进行返回        retRDD.collectAsMap() # 对词频统计结果以字典形式进行返回        retRDD.sortBy(keyfunc = lambda (k,v):v, ascending=False).take(2) # 找到词频统计中次数最高的两个    - 不同pairRDD之间进行关联        RDD1 = sc.parallelize([(&apos;a&apos;,1), (&apos;b&apos;,2), (&apos;c&apos;,3)])        RDD1 = sc.parallelize([(&apos;b&apos;,20), (&apos;c&apos;,30), (&apos;d&apos;,40)])        RDD1.join(RDD2).collect() # 对两个pairRDD之间利用key进行连接        RDD1.leftOuterJoin(RDD2).collect() # 对两个pairRDD之间利用key进行左连接，RDD1作为主导        RDD1.rightOuterJoin(RDD2).collect() # 对两个pairRDD之间利用key进行左连接，RDD2作主导        - cogroup            x = sc.parallelize([(&apos;a&apos;,1), (&apos;b&apos;,2), (&apos;c&apos;,3)])            y = sc.parallelize([(&apos;b&apos;,20), (&apos;c&apos;,30), (&apos;d&apos;,40)])            x.cogroup(y).collect() # 以key进行联合，有多少个key接结合多少，类似于outerjoin，以(key,(v1,v2...))返回            x.cogroup(y).map(lambda (x,(y,z)):(x,(list(y),list(z)))).collect() # 因为直接collect返回的是对象不是具体的内容，所以需要自己进行转换</code></pre><h1 id="Spark-DataFrame"><a href="#Spark-DataFrame" class="headerlink" title="Spark DataFrame"></a>Spark DataFrame</h1><pre><code>- 介绍    spark SQL上可以构建类似于Pandas DataFrame的结构    Spark SQL的功能入口点是SparkSession类，如果要创建一个SparkSession，使用SparkSession.builder()即可- 创建SparkSession类    from pyspark.sql import SparkSession    spark = SparkSession.builder.appName(&apos;Python Spark SQL&apos;).config(&apos;spark.some.config.option&apos;, &apos;some-value&apos;).getOrCreate() # 利用spark SQL构建一个入口- 创建DataFrame类    在SparkSession中可以从一个已存在的RDD或者hive表或者Spark数据源中创建一个DataFrame    df = spark.read.json(&quot;data/people.json&quot;) # jason格式就是类似于字典的形式    df.show() # 展示数据- DataFrame操作    df.printSchema() # 类似于Pandas里面的df.info()函数    df.select(&apos;name&apos;).show() # 选一类    df.select([&apos;name&apos;, &apos;age&apos;]).show() # 选两类    df.select(df[&apos;name&apos;], df[&apos;age&apos;]+1).show() # 选取name这列同时age这列+1    df.filter(df[&apos;age&apos;]&gt;21).show() # 对数据进行filter    df.groupBy(&apos;age&apos;).count().show() # 对年龄分组同时统计人数，count类似于size- Spark SQL    注意DataFrame不是一个表，所以如果想用SQL的方式进行表的查询的时候需要事先构建一个表    df.createOrReplaceTemView(&apos;people&apos;)    sqlDF = spark.sql(&apos;SELECT * FROM people&apos;) # 使用SQL的方式对数据进行提取，spark是自己创建的，返回的结果还是DataFrame    sqlDF.show()    sqlDF.rdd # 就是一个pyspark.rdd.RDD对象，因此可以通过sqlDF.rdd.first()对rdd对象进行访问- rdd构建spark DataFrame    sparkDF = spark.createDataFrame(sc.parallelize([1,2,3,4])) # 构建spark DataFrame对象    sparkDF.createOrReplaceTemView(&apos;people&apos;) # 从spark DataFrame对象构建SQL的表- StructField和StructType</code></pre><h1 id="一些参考资料"><a href="#一些参考资料" class="headerlink" title="一些参考资料"></a>一些参考资料</h1><p><a href="https://spark.apache.org/docs/2.1.0/api/python/pyspark.html" target="_blank" rel="noopener">pyspark package</a></p><p><a href="https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.DataFrameReader" target="_blank" rel="noopener">pyspark sql module(DataFrame)</a></p><p><a href="https://zhuanlan.zhihu.com/p/34901683" target="_blank" rel="noopener">pyspark dataframe基础1</a><br><a href="https://blog.csdn.net/sinat_26917383/article/details/80500349#_30" target="_blank" rel="noopener">pyspark dataframe基础2</a></p><p><a href="https://cloud.tencent.com/developer/article/1366850" target="_blank" rel="noopener">Python机器学习</a></p><p><a href="http://blog.sanyuehua.net/2017/11/01/Hadoop-HDFS/" target="_blank" rel="noopener">HDFS常用命令</a></p><p><a href="https://stackoverflow.com/questions/40478018/pyspark-dataframe-convert-multiple-columns-to-float" target="_blank" rel="noopener">pyspark列类型状换</a></p><p><a href="https://stackoverflow.com/questions/48832493/how-to-set-display-precision-in-pyspark-dataframe-show" target="_blank" rel="noopener">pyspark 小数据位数保留</a></p><p><a href="https://blog.csdn.net/cymy001/article/details/78483723" target="_blank" rel="noopener">pyspark RDD数据基本使用介绍</a></p><p><a href="https://stackoverflow.com/questions/30949202/spark-dataframe-timestamptype-how-to-get-year-month-day-values-from-field" target="_blank" rel="noopener">pyspark DataFrame年月日提取</a></p><p><a href="https://blog.csdn.net/sunkun2013/article/details/73250874" target="_blank" rel="noopener">数据科学速查表</a></p><p><a href="https://regexr.com/" target="_blank" rel="noopener">正则表达式练习网站</a></p><p><a href="https://okai.brown.edu/zh/chapter1.html" target="_blank" rel="noopener">一个机器学习互动网站</a></p><p><a href="http://xianbai.me/learn-md/article/syntax/paragraphs-and-line-breaks.html" target="_blank" rel="noopener">markdown使用</a></p><p><a href="http://www.runoob.com/python/python-object.html" target="_blank" rel="noopener">python面向对象编程1</a><br><a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html" target="_blank" rel="noopener">python面向对象编程2</a></p><p><a href="https://foofish.net/iterators-vs-generators.html" target="_blank" rel="noopener">python高阶知识(可迭代对象,迭代器,生成器)</a></p><p><a href="https://www.linqingmaoer.cn/?p=201" target="_blank" rel="noopener">conda使用</a></p><p><a href="https://zhuanlan.zhihu.com/p/26488074" target="_blank" rel="noopener">通过修改对象的<strong>eq</strong>方法改变==的比较方式</a></p><p><a href="https://zhuanlan.zhihu.com/p/25197792" target="_blank" rel="noopener">机器学习基础数学知识</a></p><!-- linux free用来查看内存JData相关    https://jdata.jd.com/html/detail.html?id=8    https://jdata.jd.com/html/detail.html?id=1    https://github.com/daoliker/JData    https://github.com/hecongqing/2017-jdata-competition学员笔记    - https://shimo.im/docs/di4oZVafbL47taey/read --><hr>]]></content>
    
    <summary type="html">
    
      记录了Python, Numpy, Pandas, Hadoop, Spark等基本使用
    
    </summary>
    
      <category term="Data Analysis" scheme="http://WenchaoXiu.github.io/categories/Data-Analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>Python学习笔记</title>
    <link href="http://WenchaoXiu.github.io/2018/10/01/PythonStudy/"/>
    <id>http://WenchaoXiu.github.io/2018/10/01/PythonStudy/</id>
    <published>2018-10-01T13:50:50.000Z</published>
    <updated>2020-02-25T02:58:52.186Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h2 id="conda环境以及包管理"><a href="#conda环境以及包管理" class="headerlink" title="conda环境以及包管理"></a>conda环境以及包管理</h2><pre><code>conda list # 查看所在环境的安装的包conda upgrade --all # 对包进行更新spyder # 启动anaconda中的IDEconda install numpy pandas # 在某个环境下能够安装某些Python包conda install numpy=1.10 # 安装特定版本的包conda remove &lt; package_name &gt; # 删除包conda env list # 列出当前机器上创建的虚拟环境conda create -n env1 python=2.7 # 创建一个名为env1的环境然后在其中安装python2.7conda create -n env1 numpy # 创建一个名为env1的环境然后在其中安装numpysource activate env1 # 进入env1虚拟环境，在window上不用加sourcesource deactivate # 离开环境conda install -n py27 ipykernel # 在虚拟环境py27下安装ipykernelpython -m ipykernel install --user --name py27 --display-name &quot;python2&quot; # 在py27环境内安装ipykernel并在菜单里命名为python2conda env remove -n py27 # 移除py27的虚拟环境conda install jupyter notebook # 在conda环境中安装jupyter notebook%matplotlib # jupyter notebook中已交互式方式实现matplotlib的绘图%matplotlib inline # 不跳出，直接内嵌在web中</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code>\用于一行执行太长，换行的使用三个单引号或者三个双引号多行注释</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>print(type(变量)) # 确定变量类型命名规则：驼峰命名法，下划线命名法import keywordprint(keyword.kwlist) # 打印相应的关键字</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>// # 运算取整/ # 正常除% # 取余** # 幂运算and,or,not # 逻辑运算符运算符优先级：幂运算，算术运算，比较运算，逻辑运算</code></pre><h2 id="数据类型（强类型）"><a href="#数据类型（强类型）" class="headerlink" title="数据类型（强类型）"></a>数据类型（强类型）</h2><pre><code>类型    number        int        float        complex    boolean    String    List    Tuple    Dictionary类型转换    int(a)    str(a)    eval(x) ？？？    tuple(x)    list(x)    chr(x) # 整数转换为字符</code></pre><h2 id="输入输出操作"><a href="#输入输出操作" class="headerlink" title="输入输出操作"></a>输入输出操作</h2><pre><code>f=open(&quot;xxx.txt&quot;,&apos;r&apos;) # 这里f是一个句柄，有上限print(,end=&apos;&apos;) # 不换行f.readlines() # 读取并存储为listf.readline() # 逐行读取with # 打开文件，不用关心closewith open() as f: # f是个句柄</code></pre><h2 id="CSV处理"><a href="#CSV处理" class="headerlink" title="CSV处理"></a>CSV处理</h2><pre><code>import csvf = open(&quot;xxx.csv&quot;)reader = csv.reader(f) # 映射到list类型reader[2][4]with open(&quot;&quot;,&apos;w&apos;,newline=&apos;&apos;) as f:    writer = csv.writer(f)    for row in data: # data 是个list        writer.writerow(row)csv.Dictreader() # 转化成字典writer = csv.DictWriter(f, header); writer.writeheader() # 写好头行writer.writerows(datas) # datas是一个字典全部写进去</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code>列表中的元素可以类型不同列表修改    append/insert/+/extend    lista.insert(1,[213,13,31,1341]) # 指定位置    lista.extend(listb) # 类似于+对lista进行修改    del lista[1] # 删除具体位置的元素    lista.remove(&quot;xxx&quot;) # 删除第一个匹配的元素xxx    lista.remove([&quot;xxx&quot;,&quot;yyy&quot;]) # 删除第一个匹配的list[&quot;xxx&quot;,&quot;yyy&quot;]    list.pop() # 删除指定位置的元素切片    步长[::2]    [-1::-2] # 最后一个数字开始向前隔一个取元素in/not in 排序    lista.sort(reverse=True) # 对列表排序倒序    lista.reverse() # 把列表倒过来count    lista.count(1) # 统计某个元素在列表中出现的个数，没有返回0索引    lista.index(&quot;xxx&quot;) # 返回某数的索引range    range(0,-10,-1) # 获得0,-1...,-9</code></pre><h2 id="列表推倒式"><a href="#列表推倒式" class="headerlink" title="列表推倒式"></a>列表推倒式</h2><pre><code>[i for i in range(30) if 1%2==0] # 取0-29之间偶数[function(i) for i in range(30) if 1%2==0] # function可以自己定义[ x**2 if x%2 ==0 else x**3 for x in range(10)] # 两个条件</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>str.islower() # 判断字符串是否由小写字母组成&quot;{}:{}&quot;.format(&quot;x&quot;,&quot;y&quot;) # 字符串格式化&quot;{1}:{0}&quot;.format(&quot;x&quot;,&quot;y&quot;) # 可以给定对应的参数&quot;{0:.3}&quot;.format(1/3) # 对精度进行控制的时候可以加一个冒号后面加精度&quot;{0:7}{1:7}&quot;.format(&quot;xxx&quot;,&quot;dddd&quot;) # 对于字符串来说用多长位置对其进行保留在冒号后面，对应参数是放在前面的print(s.dir()) # 字符串方法</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><pre><code>顺序存储相同不可添加修改删除() # 空元祖a = 1,2,3 # 可省略小括号</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><pre><code>无序存储，不重复，可以不同类型s = {1,2,3,&quot;3&quot;}set(&quot;hello&quot;) # 直接把每个字符当做元素set() # 创建一个集合s.add() # 添加元素s.update() # 添加一个列表，集合，也可以添加多个remove() # 删除元素，不存在会抛异常discard() # 删除元素pop() # 随机删除clear() # 清空集合intersection或者&amp;对集合求交union或者|对集合求并集difference(-)对集合求差集对称差集^ # 对称差集就是</code></pre><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><pre><code>key重复的时候后面的会被覆盖adic.get(&apos;xx&apos;) # 如果不存在xx对应的值，那么会返回Noneadic.get(&apos;xx&apos;, &apos;100&apos;) # 如果不存在xx对应的值，那么会返回100keys(),values(),iteritems() # 遍历key，value，key/valueitems() # 返回时一个tuplefor k,v in adic.items() # 遍历adic.clear() # 清空字典</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>global # 全局变量,命名的时候可以在命名之前加g_方便说明识别全局变量变量要在调用之前声明，不用定义之前声明list和dictionary不需要加global声明在函数内可改如果返回值是元组或者列表，可以用多个变量进行接收如果返回4个，但是只接收3个，最后一个要使用_作为占位符</code></pre><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><pre><code>lambda [参数列表]:表达式例如: sum = lambda x,y:x+y # 可以有多个参数,返回只能有一个式子可以作为一个函数的参数赋给另外一个参数当然普通函数也可以作为参数传入a = [{&apos;name&apos;:&apos;ss&apos;,&apos;age&apos;:10},{&apos;name&apos;:&apos;yy&apos;,&apos;age&apos;:7},{&apos;name&apos;:&apos;zz&apos;,&apos;age&apos;:15}] # 将匿名函数作为参数传入第三方函数的参数a.sort(key=lambda x:x[&apos;age&apos;]) # sort方法需要传入一个key，这个key可以作为排序依据，lambda可以提取每个元素，并对元素排列a.sort(key=lambda x:x[&apos;age&apos;]， reverse=True) # 降序</code></pre><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><pre><code>类名一般是大驼峰惯例构造方法__init__类属性和实例属性(self.xx)self.__name # 私有属性，不能够在外部访问私有方法，只能类内部进行调用,__进行声明，内部调用的时候用self.__xxx()</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>异常发生之后后面的代码都不会执行程序主动raise Exception(&apos;test&apos;)可以抛出异常try except捕获多个异常 except (aaa,bbb) as err:</code></pre><h2 id="包模块"><a href="#包模块" class="headerlink" title="包模块"></a>包模块</h2><pre><code>包是一个文件夹模块是不同的python文件import package.module.func()import package1.module1, package2.module1 # 多个模块调用import package1.module1 as p1m1 # 对模块进行重命名使用from package.module import func1 # 调用某个包某个模块的某个函数import sys;sys.path # 搜索模块路径，包含当前文件夹package.module.__file__ # 可以确定当前的模块所在的路径__init__.py  #在包被加载的时候，会被执行。在一个包下面可以有也可以没有__init__.pyfrom package import * # 引用包下面所有的模块都加载，自动搜索是不会发生的，    需要我们在__init__.py下进行定义才可以实现,定义的内容是__all__=[&quot;module1&quot;,&quot;module2&quot;],    将package下的module1和module2都加载进来    如果想直接加载某个函数，在__init__.py里面加入from .module1 import func1, __all__=[&quot;func1&quot;]    这样修改完之后，可以直接from package import *，然后直接调用func1即可，不用带package.module    restart kernel如果想要直接引用包,如：import package,这样的话，需要一定要有__init__.py，否则会在打印package.__file__的时候报错。注意import package和from package import *效果相同</code></pre><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><pre><code>if __main__==&apos;__main__&apos;: # 这个py文件以python命令调用的时候被执行，模块导入的方式是不能执行的使用场景就是自己进行测试时使用，当第三方调用时不会执行</code></pre><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><pre><code>c = list(zip(a,b))c = set(zip(a,b))c = dict(zip(a,b))list(zip(*c)) # 解压</code></pre><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><pre><code>enumerate(list/set, start=0) # 遍历元素，start指定从哪个数字作为开始下标</code></pre><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><pre><code>import random #引入random.random() # 0-1random.uniform(1,10) # 包含1，10的浮点数random.randint(1,10)  # 包含1，10的整数random.randrange(0,20,3) # 0-20能被3整除的数random.choice([1,2,3]) # 随机取元素random.choice(&quot;qwdwq&quot;) # 随机取元素random.shuffle([12,3,1,4,2,3]) # 混洗random.sample([1,2,3,4,5], 3) # 从前面的list中选3个</code></pre><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><pre><code>import mathdir(math) # 所有的math的功能</code></pre><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><pre><code>字典的继承类set dict list tuple 作为keyfrom collection import Counter # 导入cnt = Counter()for i in [1,1,2,2,2,3]:    cnt[i] += 1print cnt如果用key的话会报错先做第一次初始化才行cnt2 = Counter(alist)  #可以统计每个元素出现的次数（字符串，set,list,）Counter(cat=4,dogs=8,abc=-1) # 初始化counter次数，或者用dictionary构建Counter({&apos;cat&apos;:4,&apos;dogs&apos;:8,&apos;abc&apos;:-1})Counter返回一个字典，如果缺失的话会返回0del cnt2[&apos;xx&apos;].values()list(cnt),set(cnt),dict(cnt) # 前两个只返回keycnt.most_common()[0] # 对出现次数排序cnt.clear()cnt1+cnt2 # 对于key相同的value做加法，如果为0则不保留cnt1-cnt2 # 对于key相同的value做减法&amp; # 求key相同value的最小值| # 求key相同value的最大值</code></pre><hr>]]></content>
    
    <summary type="html">
    
      Python基本语法总结
    
    </summary>
    
      <category term="Python" scheme="http://WenchaoXiu.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基本练习题</title>
    <link href="http://WenchaoXiu.github.io/2018/09/01/JavaPractice/"/>
    <id>http://WenchaoXiu.github.io/2018/09/01/JavaPractice/</id>
    <published>2018-09-01T09:09:27.000Z</published>
    <updated>2019-07-03T15:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="基本习题"><a href="#基本习题" class="headerlink" title="基本习题"></a>基本习题</h1><h2 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一</span></span><br><span class="line"><span class="comment">对兔子，假如兔子都不死，问每个月的兔子总数为多少？*/</span></span><br><span class="line"></span><br><span class="line">System.out.println(rabbitNumber(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rabbitNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line">arr.add(arr.get(i-<span class="number">1</span>)+arr.get(i-<span class="number">2</span>));<span class="comment">//获得元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr.get(arr.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 判断101-200之间有多少个素数，并输出所有素数。 </span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">101</span>; i&lt;<span class="number">201</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime(i)) &#123;</span><br><span class="line">count ++;</span><br><span class="line">arr.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"101-200之间的质数是:"</span>+arr);</span><br><span class="line">System.out.println(<span class="string">"101-200之间的质数个数是:"</span>+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题3"><a href="#练习题3" class="headerlink" title="练习题3"></a>练习题3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/* 打印出所有的"水仙花数"，所谓"水仙花数"</span></span><br><span class="line"><span class="comment"> * 是指一个三位数，其各位数字立方和等于该数本身。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">100</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSpecial(i))</span><br><span class="line">arr.add(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"水仙花数是: "</span>+arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpecial</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n100,n10,n1;</span><br><span class="line">n100 = i/<span class="number">100</span>;</span><br><span class="line">n10 = i%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">n1 = i%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = (<span class="keyword">int</span>) (Math.pow(n1, <span class="number">3</span>)+Math.pow(n10, <span class="number">3</span>)+Math.pow(n100,<span class="number">3</span>));</span><br><span class="line"><span class="keyword">if</span> (tmp==i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题4"><a href="#练习题4" class="headerlink" title="练习题4"></a>练习题4</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。 </span></span><br><span class="line">System.out.println(<span class="string">"请输入正数:"</span>);</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">String out = String.format(<span class="string">"%d="</span>, n);</span><br><span class="line">ArrayList&lt;Integer&gt; tmp = fisrtFactor(n);</span><br><span class="line">ArrayList&lt;Integer&gt; factor = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">if</span> (tmp.size()==<span class="number">0</span>)</span><br><span class="line">System.out.println(n+<span class="string">" 是质数"</span>);</span><br><span class="line"><span class="keyword">while</span> (tmp.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">factor.add(tmp.get(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> last = tmp.get(<span class="number">1</span>);</span><br><span class="line">tmp = fisrtFactor(tmp.get(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (tmp.size()==<span class="number">0</span>) &#123;</span><br><span class="line">factor.add(last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(tmp);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;factor.size();i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line">out += String.format(<span class="string">"%d"</span>, factor.get(i));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">out += String.format(<span class="string">"*%d"</span>, factor.get(i));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">fisrtFactor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n%i==<span class="number">0</span>) &#123;</span><br><span class="line">arr.add(i);</span><br><span class="line">arr.add(n/i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题5"><a href="#练习题5" class="headerlink" title="练习题5"></a>练习题5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*利用条件运算符的嵌套来完成此题：</span></span><br><span class="line"><span class="comment"> * 学习成绩&gt;=90分的同学用A表示，</span></span><br><span class="line"><span class="comment"> * 60-89分之间的用B表示，60分以下C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(Grade(<span class="number">95</span>));</span><br><span class="line">System.out.println(Grade(<span class="number">87</span>));</span><br><span class="line">System.out.println(Grade(<span class="number">57</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Grade</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">String grade;</span><br><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">90</span>) &#123;</span><br><span class="line">grade = <span class="string">"A"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">grade = <span class="string">"B"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">grade = <span class="string">"C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> grade;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题6"><a href="#练习题6" class="headerlink" title="练习题6"></a>练习题6</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入两个正数:"</span>);</span><br><span class="line"><span class="keyword">int</span> a = in.nextInt();</span><br><span class="line"><span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">System.out.println(<span class="string">"最小公约数"</span>+zdgys(a,b));</span><br><span class="line">System.out.println(<span class="string">"最小公倍数"</span>+zxgbs(a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zdgys</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">m = a/b;</span><br><span class="line">n = a%b;</span><br><span class="line">a = b;</span><br><span class="line">b = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zxgbs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> yueshu = zdgys(a, b);</span><br><span class="line"><span class="keyword">return</span> a/yueshu*b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题7"><a href="#练习题7" class="headerlink" title="练习题7"></a>练习题7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*题目：输入一行字符，分别统计出其中英文</span></span><br><span class="line"><span class="comment"> * 字母、空格、数字和其它字符的个数。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str = in.nextLine();</span><br><span class="line">statistic(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statistic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> letterCount = <span class="number">0</span>,spaceCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> numberCount = <span class="number">0</span>,otherCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] chrArr = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> i : chrArr) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(i)) &#123;</span><br><span class="line">letterCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Character.isSpaceChar(i)) &#123;</span><br><span class="line">spaceCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(i)) &#123;</span><br><span class="line">numberCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">otherCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Letter is : "</span>+letterCount);</span><br><span class="line">System.out.println(<span class="string">"Space is : "</span>+spaceCount);</span><br><span class="line">System.out.println(<span class="string">"Number is : "</span>+numberCount);</span><br><span class="line">System.out.println(<span class="string">"Other is : "</span>+otherCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题8"><a href="#练习题8" class="headerlink" title="练习题8"></a>练习题8</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*题目：一球从100米高度自由落下，</span></span><br><span class="line"><span class="comment"> * 每次落地后反跳回原高度的一半；</span></span><br><span class="line"><span class="comment"> * 再落下，求它在 第10次落地时，</span></span><br><span class="line"><span class="comment"> * 共经过多少米？第10次反弹多高？ </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;Integer&gt; leng = ballJump(<span class="number">100</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> total = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> i:leng) &#123;</span><br><span class="line">total += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"总共经过多少："</span></span><br><span class="line">+ <span class="string">""</span>+total);</span><br><span class="line">System.out.println(<span class="string">"反弹多高："</span>+leng.get(leng.size()-<span class="number">1</span>)/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">ballJump</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">0</span>) </span><br><span class="line">arr.add(height);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">height /= <span class="number">2.0</span>;</span><br><span class="line">arr.add(<span class="number">2</span>*height);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题9"><a href="#练习题9" class="headerlink" title="练习题9"></a>练习题9</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/* 题目：有1、2、3、4个数字，</span></span><br><span class="line"><span class="comment"> * 能组成多少个互不相同且无重复数字的三位数？都是多少？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rankCombination();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rankCombination</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++) &#123;</span><br><span class="line">System.out.println(String.format(<span class="string">"%d %d %d"</span>, i, j, k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题10"><a href="#练习题10" class="headerlink" title="练习题10"></a>练习题10</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/* 一个整数，它加上100和加上268后都</span></span><br><span class="line"><span class="comment"> * 是一个完全平方数，请问该数是多少？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> i=<span class="number">0.0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line"><span class="keyword">double</span> x = i+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> y = i+<span class="number">268</span>;</span><br><span class="line"><span class="keyword">if</span> (isSquare(x) &amp;&amp; isSquare(y))</span><br><span class="line">System.out.println((<span class="keyword">int</span>) i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> i=<span class="number">0.0</span>;i&lt;(x/<span class="number">2</span>);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i*i==x)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题11"><a href="#练习题11" class="headerlink" title="练习题11"></a>练习题11</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/* 题目：输入某年某月某日，判断这一天是这一年的第几天？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">whichDay();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whichDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String intmp = in.nextLine().trim();</span><br><span class="line">String[] date = intmp.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="keyword">int</span> year = Integer.parseInt(date[<span class="number">0</span>]); <span class="comment">//string 转化 int</span></span><br><span class="line"><span class="keyword">int</span> month = Integer.parseInt(date[<span class="number">1</span>]); <span class="comment">//string 转化 int</span></span><br><span class="line"><span class="keyword">int</span> day = Integer.parseInt(date[<span class="number">2</span>]); <span class="comment">//string 转化 int</span></span><br><span class="line"><span class="keyword">int</span> two = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">two = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] ls = &#123;<span class="number">31</span>,two,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> daySum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;month-<span class="number">1</span>;i++) &#123;</span><br><span class="line">daySum += ls[i];</span><br><span class="line">&#125;</span><br><span class="line">daySum += day;</span><br><span class="line">System.out.printf(<span class="string">"是第%d天"</span>, daySum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题12"><a href="#练习题12" class="headerlink" title="练习题12"></a>练习题12</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac12</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/* 输入三个整数x,y,z，请把这三个数由小到大输出。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">printSort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">System.out.println(<span class="string">"请输入三个数,以逗号隔开:"</span>);</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String[] inStr = in.nextLine().trim().split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">for</span> (String i : inStr) &#123;</span><br><span class="line">arr.add(Integer.parseInt(i));</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(arr); <span class="comment">//对Arraylist进行排序</span></span><br><span class="line">System.out.println(<span class="string">"排序结果:"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:arr) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题13"><a href="#练习题13" class="headerlink" title="练习题13"></a>练习题13</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出9*9口诀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">multipleTable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">multipleTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] ls = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : ls) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : ls) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d*%d=%d\t"</span>, i,j,i*j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题14"><a href="#练习题14" class="headerlink" title="练习题14"></a>练习题14</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prac14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 题目：求1+2!+3!+...+20!的和 </span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">21</span>; i++) &#123;</span><br><span class="line">sum += factorial(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n*factorial(n-<span class="number">1</span>); <span class="comment">//递归求解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="1-查找重复数字"><a href="#1-查找重复数字" class="headerlink" title="1.查找重复数字"></a>1.查找重复数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。</span></span><br><span class="line"><span class="comment">请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;，那么对应的输出是第一个重复的数字2。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">解题思路:由于题目的特殊性，即：长度为n的数组所有数字都在0~n-1范围内，使得可以将所有数字分配到对应为数字值所在的位置(numbers[i])。</span></span><br><span class="line"><span class="comment">因此使用类似hash查找的方式，不断替换位置与值不相等的数字，若此过程中发现需要替换的值在期待位置已经存在相同的值那么即为重复数字并保留，否则返回false。</span></span><br><span class="line"><span class="comment">还有一种情况即数组长度为0，那么无重复返回false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i!=numbers[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    swap(numbers, i, numbers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = numbers[i];</span><br><span class="line">        numbers[i] = numbers[j];</span><br><span class="line">        numbers[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2.二维数组中的查找"></a>2.二维数组中的查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</span></span><br><span class="line"><span class="comment">请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二维数组: [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span></span><br><span class="line"><span class="comment">整数: 7</span></span><br><span class="line"><span class="comment">返回: true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路:按照题目的说明，在某个位置左/上方数字都比这个位置的值小，右/上方数字都比这个位置的值大。因此按照这个大小关系，</span></span><br><span class="line"><span class="comment">如果要搜寻某个值是否在二维数组中，只要拿这个数和当前位置的数字进行比较，如果target小则在左上找，如果target大则在右上</span></span><br><span class="line"><span class="comment">方找。但是这种寻找方式会产生两种选择(以小为例：上、左)，所以，初始位置应该设置在最右上角，这样寻找起来就会只有一种选择</span></span><br><span class="line"><span class="comment">（如果target小则往左也就是column-1，如果target大则往下也就是row+1）。最终如果找到返回ture，如果column&lt;0或者</span></span><br><span class="line"><span class="comment">row==array.length则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array==<span class="keyword">null</span> || array.length==<span class="number">0</span> || (array.length==<span class="number">1</span> &amp;&amp; array[<span class="number">0</span>].length==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> col = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (run)&#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; array[row][col])&#123;</span><br><span class="line">                    col -= <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">                    row += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> (col==-<span class="number">1</span> || row==array.length)&#123;</span><br><span class="line">                    run = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决思路:递归即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; back = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            back.addAll(printListFromTailToHead(listNode.next));<span class="comment">//不是一个元素所以要addAll</span></span><br><span class="line">            back.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-斐波那契数列"><a href="#4-斐波那契数列" class="headerlink" title="4.斐波那契数列"></a>4.斐波那契数列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述：</span></span><br><span class="line"><span class="comment">大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</span></span><br><span class="line"><span class="comment">矩形覆盖也是相同的原理，因为矩形要么横着放，要么竖着放，f(n)=f(n-2)(横着放)+f(n-1)(竖着放)，一样的递推公式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">斐波那契数列只依赖前两个值，因此，不断存储1-n的斐波那契数列，最后输出最后一个，时间复杂度低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题：我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</span></span><br><span class="line"><span class="comment">思路：矩形覆盖也是相同的原理，因为矩形要么横着放，要么竖着放，f(n)=f(n-2)(横着放)+f(n-1)(竖着放)，一样的递推公式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span></span><br><span class="line"><span class="comment">思路：一样的递推公式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arr.add(<span class="number">1</span>);</span><br><span class="line">        arr.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        arr.size();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr.size()&lt;n)&#123;</span><br><span class="line">                tmp = arr.get(arr.size()-<span class="number">2</span>)+arr.get(arr.size()-<span class="number">1</span>);</span><br><span class="line">                arr.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.get(arr.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      这部分主要通过一些练习题对Java进行自学
    
    </summary>
    
      <category term="Java" scheme="http://WenchaoXiu.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基本操作</title>
    <link href="http://WenchaoXiu.github.io/2018/08/03/JavaBasic/"/>
    <id>http://WenchaoXiu.github.io/2018/08/03/JavaBasic/</id>
    <published>2018-08-03T09:01:18.000Z</published>
    <updated>2019-07-03T09:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串比较："><a href="#字符串比较：" class="headerlink" title="字符串比较："></a>字符串比较：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"qdaw"</span></span><br><span class="line">str.compareTo(anotherString)</span><br><span class="line">str.compareToIgnoreCase(anotherString)</span><br></pre></td></tr></table></figure><h2 id="字符串最后一个匹配索引"><a href="#字符串最后一个匹配索引" class="headerlink" title="字符串最后一个匹配索引"></a>字符串最后一个匹配索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"dada"</span></span><br><span class="line">str.lastIndexOf(<span class="string">"a"</span>) <span class="comment">//返回-1或者对应的index</span></span><br><span class="line">str.indexOf(<span class="string">"a"</span>) <span class="comment">//返回-1或者对应的index</span></span><br></pre></td></tr></table></figure><h2 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.substring(<span class="number">0</span>, pos) <span class="comment">//左闭右开</span></span><br><span class="line">s.substring(<span class="number">3</span>) <span class="comment">//index 3到最后</span></span><br></pre></td></tr></table></figure><h2 id="字符串的反转"><a href="#字符串的反转" class="headerlink" title="字符串的反转"></a>字符串的反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span></span><br><span class="line">String rev = <span class="keyword">new</span> StringBuffer(str).reverse().toString()</span><br></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] temp：</span><br><span class="line">String str = <span class="string">"add.adw.wadw"</span></span><br><span class="line">String delimer = <span class="string">"\\."</span></span><br><span class="line">temp = str.split(delimer) <span class="comment">//利用.对字符串分割</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"daw,wdad,wdadwa"</span>;</span><br><span class="line">StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(str, <span class="string">","</span>);</span><br><span class="line"><span class="keyword">while</span> (st2.hasMoreElements())&#123;</span><br><span class="line">System.out.println(st2.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abcd"</span>;</span><br><span class="line">String strUp = str.toUpperCase();</span><br><span class="line">String strLow = str.toLowerCase();</span><br></pre></td></tr></table></figure><h2 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%n 换行符，%s 字符串，%c 字符</span><br><span class="line">%d 十进制整数，%x <span class="number">16</span>进制整数，%o <span class="number">8</span>进制整数</span><br><span class="line">%f 浮点数，%b 布尔类型</span><br></pre></td></tr></table></figure><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">Array.sort(arr); <span class="comment">//没有返回值，arr直接就是排好序的</span></span><br></pre></td></tr></table></figure><h2 id="数组查找"><a href="#数组查找" class="headerlink" title="数组查找"></a>数组查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,-<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Array.binarySearch(arr, <span class="number">3</span>); <span class="comment">//binarySearch需要先对数组排序,返回对应的位置或者负数</span></span><br></pre></td></tr></table></figure><h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">arrayList.add(<span class="string">"A"</span>);</span><br><span class="line">arrayList.add(<span class="string">"B"</span>);</span><br><span class="line">Collections.reverse(arrayList); <span class="comment">// 对元素反转</span></span><br></pre></td></tr></table></figure><h2 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> min = (<span class="keyword">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">   <span class="keyword">int</span> max = (<span class="keyword">int</span>) Collections.max(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">"A"</span>, <span class="string">"E"</span>, <span class="string">"I"</span> &#125;;</span><br><span class="line">   String b[] = &#123; <span class="string">"O"</span>, <span class="string">"U"</span> &#125;;</span><br><span class="line">   List list = <span class="keyword">new</span> ArrayList(Arrays.asList(a));</span><br><span class="line">   list.addAll(Arrays.asList(b));</span><br><span class="line">   Object[] c = list.toArray();</span><br><span class="line">   System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">Array.fill(arr, <span class="number">100</span>); <span class="comment">//数组进行填充，所有元素都为100</span></span><br><span class="line">Array.fill(arr, <span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>); <span class="comment">//在index3，4，5上填充50</span></span><br></pre></td></tr></table></figure><h2 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a>数组删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; objArray = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">objArray.add(<span class="number">0</span>,<span class="string">"第 0 个元素"</span>);</span><br><span class="line">   objArray.add(<span class="number">1</span>,<span class="string">"第 1 个元素"</span>);</span><br><span class="line">   objArray.add(<span class="number">2</span>,<span class="string">"第 2 个元素"</span>);</span><br><span class="line">   objArray.remove(<span class="number">1</span>); <span class="comment">//通过index进行删除</span></span><br><span class="line">   objArray.remove(<span class="string">"第 0 个元素"</span>) <span class="comment">//通过内容删除</span></span><br></pre></td></tr></table></figure><h2 id="数组添加元素"><a href="#数组添加元素" class="headerlink" title="数组添加元素"></a>数组添加元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="number">2</span>, <span class="string">"Item3"</span>) <span class="comment">//在数组的第三个位置添加"Item3"</span></span><br></pre></td></tr></table></figure><h2 id="数组求差集-交集-以及是否含有某个元素"><a href="#数组求差集-交集-以及是否含有某个元素" class="headerlink" title="数组求差集,交集,以及是否含有某个元素"></a>数组求差集,交集,以及是否含有某个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList objArray = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   ArrayList objArray2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">   objArray2.add(<span class="number">0</span>,<span class="string">"common1"</span>);</span><br><span class="line">   objArray2.add(<span class="number">1</span>,<span class="string">"common2"</span>);</span><br><span class="line">   objArray2.add(<span class="number">2</span>,<span class="string">"notcommon"</span>);</span><br><span class="line">   objArray2.add(<span class="number">3</span>,<span class="string">"notcommon1"</span>);</span><br><span class="line">   objArray.add(<span class="number">0</span>,<span class="string">"common1"</span>);</span><br><span class="line">   objArray.add(<span class="number">1</span>,<span class="string">"common2"</span>);</span><br><span class="line">   objArray.add(<span class="number">2</span>,<span class="string">"notcommon2"</span>);</span><br><span class="line">   System.out.println(<span class="string">"array1 的元素"</span> +objArray);</span><br><span class="line">   System.out.println(<span class="string">"array2 的元素"</span> +objArray2);</span><br><span class="line">   objArray.removeAll(objArray2); <span class="comment">// 数组差集，结果为objArray</span></span><br><span class="line">   objArray.retainAll(objArray2); <span class="comment">// 数组求交集</span></span><br><span class="line">   objArray.contains(<span class="string">"common2"</span>); <span class="comment">// 数组是否包含某个元素</span></span><br></pre></td></tr></table></figure><h2 id="数组求并集"><a href="#数组求并集" class="headerlink" title="数组求并集"></a>数组求并集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] str1 = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">String[] str2 = &#123;<span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>&#125;;</span><br><span class="line">Hashset&lt;String&gt; set = <span class="keyword">new</span> Hashset&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String i : str1)&#123;</span><br><span class="line">set.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String i : str2)&#123;</span><br><span class="line">set.add(i);</span><br><span class="line">&#125;</span><br><span class="line">String[] ret = &#123;&#125;;</span><br><span class="line">set.toArray(ret); <span class="comment">// ret即为利用Hashset获取的两个数组的并集</span></span><br></pre></td></tr></table></figure><h2 id="判断数组是否相等"><a href="#判断数组是否相等" class="headerlink" title="判断数组是否相等"></a>判断数组是否相等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ary = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>[] ary1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>[] ary2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">   Arrays.equals(ary, ary1); <span class="comment">//判断两个数组是否相等</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      对Java基本的操作进行总结
    
    </summary>
    
      <category term="Java" scheme="http://WenchaoXiu.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="http://WenchaoXiu.github.io/2018/07/12/firstblog_hexo/"/>
    <id>http://WenchaoXiu.github.io/2018/07/12/firstblog_hexo/</id>
    <published>2018-07-12T08:07:52.000Z</published>
    <updated>2020-02-25T06:20:30.250Z</updated>
    
    <content type="html"><![CDATA[<p class="description">记录一下如何使用hexo进行博客撰写</p><a id="more"></a><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug -p 5000</span><br></pre></td></tr></table></figure><h2 id="网上更新"><a href="#网上更新" class="headerlink" title="网上更新"></a>网上更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post md_name</span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将图片放入~/blog/public/images文件夹下，width可以用来调整图片长宽比例</span></span><br><span class="line">&lt;div style=<span class="string">"width: 300px; margin: auto"</span>&gt;![Git区域](/images/git_learning/gitzone.png)&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">图片插入参考文章</a></p><p>更多<a href="http://moxfive.xyz/2015/12/21/common-hexo-commands/" target="_blank" rel="noopener">hexo命令</a><br>更多内容参见<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">blog</a><br>对于markdown的使用可以参考这篇<a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%B8%8B%E7%9A%84Markdown%E8%AF%AD%E6%B3%95%28GFM%29%E5%86%99%E5%8D%9A%E5%AE%A2.html" target="_blank" rel="noopener">blog</a></p><hr>]]></content>
    
    <summary type="html">
    
      这里主要记录搭建blog时使用的命令
    
    </summary>
    
      <category term="Website" scheme="http://WenchaoXiu.github.io/categories/Website/"/>
    
    
  </entry>
  
</feed>
