<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenchaoXiu</title>
  
  <subtitle>just try blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WenchaoXiu.github.io/"/>
  <updated>2019-05-13T04:09:36.000Z</updated>
  <id>http://WenchaoXiu.github.io/</id>
  
  <author>
    <name>WenchaoXiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://WenchaoXiu.github.io/2019/05/13/Leetcode/"/>
    <id>http://WenchaoXiu.github.io/2019/05/13/Leetcode/</id>
    <published>2019-05-13T03:17:06.000Z</published>
    <updated>2019-05-13T04:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="leetcode习题"><a href="#leetcode习题" class="headerlink" title="leetcode习题"></a>leetcode习题</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p><p>给定一个整型数组 nums 和一个目标值 target ，请找出数组中和为 target 的两个整数，并返回这两个数的数组下标。<br>假设：<br>1）每个输入只对应一个答案；<br>2）不允许重复使用数组中的数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">return</span> [adic[v],k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[target-v] = k</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Example:<br>Given nums = [0,1,2,2,3,0,4,2], val = 2,<br>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.<br>Note that the order of those five elements can be arbitrary.<br>It doesn’t matter what values are set beyond the returned length.</p><p>给定一个数组 nums 和一个值 val ，请在原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>要求：<br>1）原地操作的意思是不允许开辟额外的数组空间，空间复杂度必须为O(1)；<br>2）数组中元素的顺序是可以改变的，也不需要考虑超出新长度后面的元素。</p><p><strong>解题思路1：</strong><br>本题难点在于不允许使用额外的数组空间，因此考虑使用两个下标指针 i，j（初始都指向数组头部）：<br>当 nums[j] 等于 val（需移除的元素），忽略当前这个元素，j++；<br>当 nums[j] 不等于 val（需保留的元素），用 nums[j] 的值覆盖 nums[i] 的值，i++，j++。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            <span class="keyword">if</span> nums[start]==val:</span><br><span class="line">                nums[start] = nums[end]</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        nums = nums[:start]</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure></p><p><strong>解题思路2：</strong><br>另一种思路仍是采用两个指针，一个从头向后扫，另一个从尾向前扫，遇到和 val 相等的值就和数组尾部的元素交换或覆盖。（假如需要移除的元素很少时，这种思路需要赋值的次数更少）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 保留与val不同的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i!=val:</span><br><span class="line">                nums[count] = i</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        nums = nums[:count] <span class="comment"># 注意这里count其实多加了1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p><h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</p><p>Example1:<br>Input: [1,3,5,6], 5<br>Output: 2</p><p>Example2:<br>Input: [1,3,5,6], 2<br>Output: 1</p><p>Example3:<br>Input: [1,3,5,6], 7<br>Output: 4</p><p>Example4:<br>Input: [1,3,5,6], 0<br>Output: 0<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p><p><strong>解题思路：</strong><br>因为数组是有序的，所以直观的想法是考察nums中相邻元素与target的关系，如果target在相邻元素范围内，进一步判断是否与左边的数相等，进而判断插入或所在位置，当然除此之外还需要考虑target在nums最大最小值之外的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先判断两头</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]&gt;=target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># 在判断中间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (target&gt;=nums[i]) <span class="keyword">and</span> (target&lt;=nums[i+<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> target==nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53.Maximum Subarray"></a>53.Maximum Subarray</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p><p>Follow up:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>解题思路：</strong><br>利用动态规划思想，我们假设f(n)为末尾下标为n的最优子序列的和，那么f(n-1)即为末尾下标为n-1的最优子序列和，A(n)为nums数组中下标为n的元素，我们来考察三者的关系，即为：f(n)=max( f(n-1)+A(n), A(n) )，解释一下，因为我们之前已经给过定义f(n)是以n为末尾的子序列，那么他只可能有两种情况，要么是f(n-1)所在的子序列加上A(n)作为f(n)，要么就是只有A(n)这一个元素(因为A(n)时一定要存在的)，所以我们只需要判断一下，哪种序列和最大，就保留这个最大值，作为以n为末尾的子序列的最大值。这样我们遍历整个数组，把每个结果存起来，最后比较出最大值，即为整体子序列的最大值(其下标所在位置即为最优子序列末尾下表位置)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = [] <span class="comment"># 存储从0~len(nums)-1为末尾下标的最优子序列值</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                before = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                after = max(before+v,v)</span><br><span class="line">                before = after</span><br><span class="line">            alist.append(before)</span><br><span class="line">        <span class="keyword">return</span> max(alist)</span><br></pre></td></tr></table></figure><h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66.Plus One"></a>66.Plus One</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.<br>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.<br>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p>Example 1:<br>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p><p>Example 2:<br>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 借助类型转换</span></span><br><span class="line">        before = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            before += str(i)</span><br><span class="line">        after = str(int(before)+<span class="number">1</span>)</span><br><span class="line">        ret = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> after]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>Note:<br>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:<br>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>Output: [1,2,2,3,5,6]</p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。</p><p>说明:<br>初始时， nums1 和 nums2 的元素数量分别为 m 和 n。<br>假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p><strong>解题思路：</strong><br>通过双指针进行操作，因为nums1数组长度为m+n且nums1和nums2都是有序的，所以，我们分别把m和n作为nums1和nums2的指针(即指向末尾)，对两个数组遍历，终止条件是其中一个数组下标为0(即只要有一个数组遍历完就结束)，将指针所指的元素进行比较，将较大的数放在num1的末尾，同时较大数所在数组的指针减1，以此类推。最后如果m下标所在数组没有遍历完，则说明剩下的数字都比nums2的最小数字小，nums1数组不应做任何操作，如果nums2所在数组没有遍历完，那么说明nums2剩下的数字都比num1最小值小，此时需要把nums2剩下数字填充到nums1最前面相应位置即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>]&gt;=nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure><h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.Pascal’s Triangle"></a>118.Pascal’s Triangle</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br>Note: In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:<br>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>注意：在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p><p><strong>解题思路：</strong><br>官方的图片其实很清楚的解释了原理，即从第三行开始，每一组两边的数都是1，中间的数都是由上一层相邻元素相加获得的，因此如果想要获取当前行数组，只需要上一层数组即可，有点像斐波那契数列的感觉，因为题目要求输出所有行因此需要把每行保存起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,numRows+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before = alist[<span class="number">-1</span>]</span><br><span class="line">                after = [<span class="number">1</span>]+[before[j]+before[j+<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]+[<span class="number">1</span>]</span><br><span class="line">                alist.append(after)</span><br><span class="line">            <span class="keyword">print</span> alist</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121.Best Time to Buy and Sell Stock"></a>121.Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p><p>Example1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p><p>Example2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p><p><strong>解题思路：</strong><br>动态规划，f(n) = max(f(n-1), A[n]-min(A[:n-1]))<br>当前天收入=max(前一天受益，当前天价值-之前所有天最小值)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_profit = <span class="number">0</span> <span class="comment"># max of f(n)</span></span><br><span class="line">            min_num = prices[<span class="number">0</span>] <span class="comment"># min(A[:n-1])</span></span><br><span class="line">            before = <span class="number">0</span> <span class="comment"># f(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">                cur = prices[i+<span class="number">1</span>] <span class="comment"># A[n]</span></span><br><span class="line">                after = max(before, cur-min_num) <span class="comment"># f(n)</span></span><br><span class="line">                <span class="keyword">print</span> after</span><br><span class="line">                before = after</span><br><span class="line">                min_num = cur <span class="keyword">if</span> cur&lt;min_num <span class="keyword">else</span> min_num <span class="comment"># update min value</span></span><br><span class="line">                max_profit = before <span class="keyword">if</span> before&gt;max_profit <span class="keyword">else</span> max_profit</span><br><span class="line">            <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p><h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119.Pascal’s Triangle II"></a>119.Pascal’s Triangle II</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.<br>Note that the row index starts from 0.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p><strong>解题思路:</strong><br>当前层可以通过上一层得到，因此每次保留上一层数即可，得到当前层之后，将当前层替换成before即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> rowIndex==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            before = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(rowIndex - <span class="number">1</span>):</span><br><span class="line">                mid = [before[i]+before[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]</span><br><span class="line">                after = [<span class="number">1</span>] + mid + [<span class="number">1</span>]</span><br><span class="line">                before = after</span><br><span class="line">            <span class="keyword">return</span> before</span><br></pre></td></tr></table></figure></p><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p><strong>解题思路：</strong><br>与股票买卖1相比，主要的差别在于可以多次买卖，换句话说也就是“股票买卖1”问题每个数字只能进行一次操作，但是该问题每个数字可以进行多次操作(买与卖)。因此，每天先买入(不会亏)，查看下一天，如果会亏就把当天的卖了，就相当于赚了0元，如果下一天会赚那么就直接卖掉，再买入下一天的股票，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i]&lt;prices[i+<span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p><h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>Example 1:<br>Given nums = [1,1,2],<br>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.<br>It doesn’t matter what you leave beyond the returned length.<br>Example 2:<br>Given nums = [0,0,1,1,1,2,2,3,3,4],</p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>解题思路：</strong><br>通过两个下标index和i完成，index下标从0开始，i从1开始，i是用来遍历数组的，当遇到重复值就跳过，index不增加，如果遇到的是非重复值，index下标加1并对原数组进行修改，将值改为i对应的值，直至遍历完整个数组，最后得到的元素组的前index+1个元素就是不重复元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index控制不重复数字，i对列表变进行遍历</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        nums = nums[:index+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h2><p><strong>解题思路：</strong><br>如果序列长度大于1可以对序列进行拆分，排序，再进行合并<br>当拆分为只有单个元素的list之后默认就是排好序的<br>这样每次迭代的子部分相当于排好序的list，只需对两个排好序的list进行merge即可<br>将这种思想进行扩展即可<br><a href="https://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="noopener">归并排序思路</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mid = len(nums)/<span class="number">2</span></span><br><span class="line">left = mergesort(nums[:mid])</span><br><span class="line">right = mergesort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">ret = []</span><br><span class="line">i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;len(left) <span class="keyword">and</span> j&lt;len(right):</span><br><span class="line"><span class="keyword">if</span> left[i]&lt;=right[j]:</span><br><span class="line">ret.append(left[i])</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ret.append(right[j])</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i==len(left):</span><br><span class="line">ret += right[j:]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ret += left[i:]</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%mergeSort(test)</span><br></pre></td></tr></table></figure><h2 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2.桶排序"></a>2.桶排序</h2><p><strong>解题思路:</strong><br>桶排序是一种计数排序，也就是说，建立最小值到最大值之间的list，<br>计算每个数字在nums中出现的次数，填写在在相应list的位置，<br>最后遍历整个list输出值不为出代表的nums中的数字即可<br>(不适用于范围太大元素个数少的list)<br><a href="https://www.cnblogs.com/king-ding/p/bucketsort.html" target="_blank" rel="noopener">桶排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">max_num = max(nums)</span><br><span class="line">min_num = min(nums)</span><br><span class="line">init_list = [<span class="number">0</span>]*(max_num-min_num+<span class="number">1</span>)</span><br><span class="line">ret_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">init_list[i-min_num] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(init_list):</span><br><span class="line"><span class="keyword">if</span> v!=<span class="number">0</span>:</span><br><span class="line">ret_list += [k+min_num]*v</span><br><span class="line"><span class="keyword">return</span> ret_list</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure></p><h2 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h2><p><strong>解题思路:</strong><br>选择第一个位置作为一个标定，之后遍历后面的list，找出比这个数大的，放在右边，<br>找出比这个数小的放在左边，进一步迭代排序左边和右边子list，即可获得排序后的结果<br>(有一点二分的思想)<br><a href="http://yshblog.com/blog/170" target="_blank" rel="noopener">快排思路1</a><br><a href="https://blog.csdn.net/razor87/article/details/71155518" target="_blank" rel="noopener">快排思路2</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">left = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=nums[<span class="number">0</span>]]</span><br><span class="line">right = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;nums[<span class="number">0</span>]]</span><br><span class="line">ret = quickSort(left)+[nums[<span class="number">0</span>]]+quickSort(right)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure></p><h2 id="4-基数排序"><a href="#4-基数排序" class="headerlink" title="4.基数排序"></a>4.基数排序</h2><p><strong>解题思路:</strong><br>基数排序主要是这样实现的，首先找出所有数字的最大值，通过最大值得到最大数的位数，<br>建立一个空值的list，分别代表0-9十个数。然后通过对nums中的元素的个位数进行提取，进而排序，<br>放到相应的空值list的位置处，之后将遍历完的数组进行合并，作为一次排序的结果，以此类推，<br>直到所有位数都排完，即可得到排序后的数组<br><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">基数排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jishuSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">k = int(math.ceil(math.log(max(nums), <span class="number">10</span>)))</span><br><span class="line">alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">alist[(v/<span class="number">10</span>**i)%<span class="number">10</span>].append(v)</span><br><span class="line">nums = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> alist:</span><br><span class="line">nums.extend(j)</span><br><span class="line">alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">test = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">123</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%jishuSort(test)</span><br></pre></td></tr></table></figure></p><h2 id="5-二叉树排序"><a href="#5-二叉树排序" class="headerlink" title="5.二叉树排序"></a>5.二叉树排序</h2><p><strong>解题思路：</strong><br>二叉树排序主要有几个步骤，构建节点，通过插值构建二叉树，对构建好的二叉树进行遍历<br><a href="https://blog.csdn.net/Rex_WUST/article/details/83274507" target="_blank" rel="noopener">二叉树排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.value = value</span><br><span class="line">self.left = <span class="keyword">None</span></span><br><span class="line">self.right = <span class="keyword">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.left = Tree(value)</span><br><span class="line"><span class="keyword">return</span> self.left</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.right = Tree(value)</span><br><span class="line"><span class="keyword">return</span> self.right</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertValue</span><span class="params">(node, value)</span>:</span></span><br><span class="line"><span class="keyword">if</span> node.value&gt;value:</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">insertValue(node.left, value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">node.leftInsert(value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">insertValue(node.right, value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">node.rightInsert(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOrder</span><span class="params">(node)</span>:</span></span><br><span class="line"><span class="keyword">if</span> node.value:</span><br><span class="line"><span class="keyword">if</span> node.left:</span><br><span class="line">leftOrder(node.left)</span><br><span class="line">alist.append(node.show()) <span class="comment"># alist是全局变量</span></span><br><span class="line"><span class="keyword">if</span> node.right:</span><br><span class="line">leftOrder(node.right)</span><br><span class="line"></span><br><span class="line">alist = []</span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">root = Tree(nums[<span class="number">0</span>])</span><br><span class="line">tree = root</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">insertValue(tree, i)</span><br><span class="line">leftOrder(tree)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%nums</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%alist</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      面试算法
    
    </summary>
    
      <category term="Algorithm" scheme="http://WenchaoXiu.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>ML_training</title>
    <link href="http://WenchaoXiu.github.io/2019/05/12/ML-training/"/>
    <id>http://WenchaoXiu.github.io/2019/05/12/ML-training/</id>
    <published>2019-05-12T02:45:53.000Z</published>
    <updated>2019-05-12T03:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="jupyter-notebook技巧"><a href="#jupyter-notebook技巧" class="headerlink" title="jupyter notebook技巧"></a><font color="red">jupyter notebook技巧</font></h1><h2 id="1-安装jupyter-notbook及其扩展"><a href="#1-安装jupyter-notbook及其扩展" class="headerlink" title="1. 安装jupyter notbook及其扩展"></a>1. 安装jupyter notbook及其扩展</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter notebook <span class="comment"># 安装anaconda之后，下载jupyter notebook</span></span><br><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions <span class="comment"># jupyter notebook扩展安装</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple autopep8 <span class="comment"># 代码自动规范化包</span></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/52890101" target="_blank" rel="noopener">jupyter extension使用参考</a></p><h2 id="2-jupyter使用设置"><a href="#2-jupyter使用设置" class="headerlink" title="2. jupyter使用设置"></a>2. jupyter使用设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置输入输出情况</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">'all'</span>/<span class="string">'last_expr'</span></span><br><span class="line"><span class="comment"># matplotlib画图显示</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># 使用bash命令</span></span><br><span class="line">!head -n <span class="number">5</span> xx.txt</span><br><span class="line">!ls -ltrh *</span><br></pre></td></tr></table></figure><h2 id="3-pyhton2-python3-kernel共存"><a href="#3-pyhton2-python3-kernel共存" class="headerlink" title="3. pyhton2 python3 kernel共存"></a>3. pyhton2 python3 kernel共存</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 安装anaconda3</span><br><span class="line"><span class="number">2.</span> conda create -n py27 python=<span class="number">2.7</span></span><br><span class="line"><span class="number">3.</span> source activate py27</span><br><span class="line"><span class="number">4.</span> conda install -n py27 ipykernel</span><br><span class="line"><span class="number">5.</span> python -m ipykernel install --user --name py27 --display-name <span class="string">"python2"</span></span><br></pre></td></tr></table></figure><h2 id="4-本地访问远端服务器"><a href="#4-本地访问远端服务器" class="headerlink" title="4. 本地访问远端服务器"></a>4. 本地访问远端服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sever端</span></span><br><span class="line">jupyter notebook --allow-root --port=8889 --no-browser</span><br><span class="line"><span class="comment"># local端</span></span><br><span class="line">ssh -f -N -L localhost:8000:localhost:8889 xxx@xx.xx.xx.xx -p 6666</span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">http://localhost:8000</span><br></pre></td></tr></table></figure><h1 id="Python包Pandas学习笔记"><a href="#Python包Pandas学习笔记" class="headerlink" title="Python包Pandas学习笔记"></a><font color="red">Python包Pandas学习笔记</font></h1><p><strong>最近对pandas做了一个系统的学习，主要参考了这套<a href="https://github.com/guipsamora/pandas_exercises" target="_blank" rel="noopener">习题</a>，方便后续进行python数据分析</strong></p><h2 id="1-package的载入"><a href="#1-package的载入" class="headerlink" title="1 package的载入"></a>1 package的载入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h2 id="2-数据读取-“-”暂作“或”使用"><a href="#2-数据读取-“-”暂作“或”使用" class="headerlink" title="2 数据读取(“/”暂作“或”使用)"></a>2 数据读取(“/”暂作“或”使用)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \s+是利用空白符进行分割,可使用正则表达式匹配</span></span><br><span class="line"><span class="comment"># header可以制定列明对应的行数，如果没有就是None</span></span><br><span class="line"><span class="comment"># index_col就是行名对应的列数，如果没有也是None</span></span><br><span class="line"><span class="comment"># parse_dates日期型列</span></span><br><span class="line">pd.read_csv(path, sep=<span class="string">'\s+'</span>/<span class="string">'\t'</span>/<span class="string">','</span>, header=<span class="number">0</span>/<span class="keyword">None</span>, usecols=[...], </span><br><span class="line">,parse_dates=[<span class="number">0</span>]/[<span class="string">'Date'</span>], index_col=<span class="number">0</span>/<span class="keyword">None</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="3-数据输出"><a href="#3-数据输出" class="headerlink" title="3 数据输出"></a>3 数据输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># na_rep是填充的缺失值</span></span><br><span class="line"><span class="comment"># header可以给一个list用作数据输出的列名</span></span><br><span class="line"><span class="comment"># columns可以给定数字list用于选取输出特定的列</span></span><br><span class="line">pd.to_csv(path, sep=<span class="string">''</span>, na_rep=<span class="string">'NA'</span>, header=<span class="keyword">True</span>/[<span class="string">'xx'</span>,<span class="string">'xx'</span>], index=<span class="keyword">True</span>, </span><br><span class="line">columns=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>.], encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h2 id="4-创建DataFrame-Series对象"><a href="#4-创建DataFrame-Series对象" class="headerlink" title="4 创建DataFrame,Series对象"></a>4 创建DataFrame,Series对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame和Series都接受list和numpy array数据，若要转换回array可以用df.values或S.values</span></span><br><span class="line"><span class="comment"># DataFrame还可以接受dictionary对象</span></span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">5</span>), columns=list(<span class="string">'ABCDE'</span>)) <span class="comment">#列名为ABCDE</span></span><br><span class="line">S = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h2 id="5-数据类型总结"><a href="#5-数据类型总结" class="headerlink" title="5 数据类型总结"></a>5 数据类型总结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'string'</span>: list(<span class="string">'abc'</span>),</span><br><span class="line">                   <span class="string">'int64'</span>: list(range(<span class="number">1</span>, <span class="number">4</span>)),</span><br><span class="line">                   <span class="string">'uint8'</span>: np.arange(<span class="number">3</span>, <span class="number">6</span>).astype(<span class="string">'u1'</span>),</span><br><span class="line">                   <span class="string">'float64'</span>: np.arange(<span class="number">4.0</span>, <span class="number">7.0</span>),</span><br><span class="line">                   <span class="string">'bool1'</span>: [<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>],</span><br><span class="line">                   <span class="string">'bool2'</span>: [<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>],</span><br><span class="line">                   <span class="string">'dates'</span>: pd.date_range(<span class="string">'now'</span>, periods=<span class="number">3</span>).values,</span><br><span class="line">                   <span class="string">'category'</span>: pd.Series(list(<span class="string">"ABC"</span>)).astype(<span class="string">'category'</span>)&#125;)</span><br><span class="line">S.astype(np.int64) <span class="comment"># 数据类型转化</span></span><br><span class="line">S.dtype == np.int64 <span class="comment"># 数据类型判断</span></span><br><span class="line">S.to_frame() <span class="comment"># 将Series数据转换为DataFrame数据</span></span><br><span class="line">pd.to_datetime(df.a) <span class="comment"># 将df数据a列转换为datetime类型</span></span><br><span class="line">pd.to_numeric(aDF.loc[:, <span class="string">'xxx'</span>])  <span class="comment">#转换成数字</span></span><br></pre></td></tr></table></figure><h2 id="6-查看数据"><a href="#6-查看数据" class="headerlink" title="6 查看数据"></a>6 查看数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df.head(<span class="number">10</span>) <span class="comment"># 查看数据前10行</span></span><br><span class="line">df.tail(<span class="number">10</span>) <span class="comment"># 查看数据后10行</span></span><br><span class="line">df.shape <span class="comment"># 数据对应的行列数</span></span><br><span class="line">df.info() <span class="comment"># 数据索引，类型，内存信息</span></span><br><span class="line">df.describe(include=<span class="string">'all'</span>) <span class="comment"># 对于数字型数据进行分位数统计,all代表对所有数据类型统计</span></span><br><span class="line">S.value_counts(dropna=<span class="keyword">False</span>) <span class="comment"># 对Series里面的值进行个数统计，NA也会统计</span></span><br><span class="line">df.apply(pd.Series.value_counts) <span class="comment">#返回每个值在各列中的个数，没有则用NaN代替</span></span><br><span class="line">df.index <span class="comment"># 返回数据的索引</span></span><br><span class="line">df.columns <span class="comment"># 返回数据的列名</span></span><br><span class="line">df.mean()/min()/median()/std()/count() <span class="comment"># 分别是df的列均值,最小值,中位数,标准差,非空值</span></span><br><span class="line">df.corr() <span class="comment"># 列之间的相关系数</span></span><br><span class="line">df.idxmax(<span class="number">0</span>) <span class="comment"># 每列最大数对应行的index的名</span></span><br><span class="line">df.idxmax(<span class="number">1</span>) <span class="comment"># 每行最大数对应的列名</span></span><br><span class="line">aDF.nsmallest(columns=<span class="string">'age'</span>, n=<span class="number">20</span>) <span class="comment"># 取出年龄最小的20个数据</span></span><br><span class="line">S.is_unique <span class="comment"># 确定Series数据是否是unique的, 返回bool值</span></span><br></pre></td></tr></table></figure><h2 id="7-数据的截取"><a href="#7-数据的截取" class="headerlink" title="7 数据的截取"></a>7 数据的截取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df.xxx / df[<span class="string">'xxx'</span>] <span class="comment"># 返回数据的某一列，列名为xxx，类型为Series</span></span><br><span class="line">df[[<span class="string">'xx'</span>,<span class="string">'yy'</span>]] <span class="comment"># 选取多列数据，类型为DataFrame</span></span><br><span class="line">df.iloc[<span class="number">3</span>] <span class="comment"># 选取第4行数据</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],:] <span class="comment"># 选取多行数据</span></span><br><span class="line">df.loc[[<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>],[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]] <span class="comment">#根据行index名和列名进行数据截取</span></span><br><span class="line">df.ix[..,..] <span class="comment"># ix是用行名列名以及行数列数混合赋值的情况下数据的截取</span></span><br><span class="line">df[(df.col&gt;<span class="number">0.5</span>) &amp; (df.col&lt;<span class="number">10</span>)] <span class="comment"># 筛选col大于0.5小于10的行返回</span></span><br><span class="line">aDF.loc[(aDF[<span class="string">'a'</span>]&gt;<span class="number">10</span>) &amp; (aDF[<span class="string">'b'</span>]&lt;<span class="number">100</span>), :] <span class="comment"># 也可以给条件进行筛选,&amp; | ~进行逻辑运算</span></span><br><span class="line">df.values <span class="comment"># 返回df对应的numpy array值</span></span><br><span class="line">df.values[<span class="number">10</span>][<span class="number">5</span>] <span class="comment">#求df数据11行6列的值</span></span><br><span class="line">df[df[<span class="string">'xxx'</span>].notnull(), :] = <span class="number">10</span> <span class="comment"># 对空值赋值</span></span><br><span class="line">S.str.startswith(<span class="string">'G'</span>) <span class="comment"># Seriers以G开头的字符, 返回bool值</span></span><br><span class="line">S.isin([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]) <span class="comment"># 返回bool值如果S在list['a','b','c']中, 返回true</span></span><br><span class="line">S != <span class="string">'xxx'</span> <span class="comment"># Series中不为xxx的位置, 返回bool值</span></span><br></pre></td></tr></table></figure><h2 id="8-数据清洗"><a href="#8-数据清洗" class="headerlink" title="8 数据清洗"></a>8 数据清洗</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> df[<span class="string">'a'</span>] <span class="comment">#删除数据df的a列</span></span><br><span class="line">df.drop([<span class="string">'B'</span>,<span class="string">'C'</span>],axis=<span class="number">1</span>,inplace=<span class="keyword">True</span>) <span class="comment"># 删除数据df的B,C列, 在原数据上进行修改</span></span><br><span class="line">df.dropna(how = <span class="string">'all'</span>, axis=<span class="number">0</span>) <span class="comment"># 对行进行操作,如果一行里面全都是na那么就删除,如果要一列里面全是na就删除,那么axis=1df.loc[:, 'newcol'] = 2000 # 如果没有newcol那么就新加一列</span></span><br><span class="line">df.columns = [<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment"># 更改数据的列名</span></span><br><span class="line">df.isnull().sum() <span class="comment"># 统计各列中缺失值的个数</span></span><br><span class="line">df.notnull().sum() <span class="comment"># 统计各列中非缺失值的个数</span></span><br><span class="line">df.drop_duplicates([...], <span class="string">'first'</span>/<span class="string">'last'</span>/<span class="keyword">False</span>) </span><br><span class="line"><span class="comment"># 移除重复项, list可以是列名也可以是数字序列,first是保留重复中的第一个, last是保留重复中的最后一个, False一个不留, 只要重复都删除</span></span><br><span class="line">df.dropna(axis=<span class="number">0</span>/<span class="number">1</span>, how=<span class="string">'any'</span>/<span class="string">'all'</span>, thresh=n)</span><br><span class="line"><span class="comment"># 移除数据中的缺失行,axis0是行删除,1是列删除</span></span><br><span class="line"><span class="comment"># any是只要有一个就删除,all是所有的都是才删除</span></span><br><span class="line"><span class="comment"># thresh目的是大于n个NA才删除</span></span><br><span class="line">S.fillna(x) <span class="comment"># 对确实值进行填充,填充值为x</span></span><br><span class="line">aDF.loc[:,<span class="string">'xx'</span>].fillna(aSeires) <span class="comment"># 对数据进行填充,根据aSeires的index和aDF的index进行填充</span></span><br><span class="line">S.astype(np.float) <span class="comment"># 数据的类型转换</span></span><br><span class="line">S.replace(<span class="number">1</span>, <span class="string">'one'</span>) <span class="comment"># 将1替换为'one'</span></span><br><span class="line">S.replace([<span class="number">1</span>,<span class="number">2</span>], [<span class="string">'one'</span>,<span class="string">'two'</span>]) <span class="comment"># 将1替换为one, 2替换为two</span></span><br><span class="line">df.rename(index/columns=&#123;<span class="string">'old1'</span>:<span class="string">'new1'</span>,<span class="string">'old2'</span>:<span class="string">'new2'</span>&#125;) <span class="comment"># 修改行名列名，将old1改为new1，将old2改为new2</span></span><br><span class="line">df.set_index(<span class="string">'B'</span>) <span class="comment"># 修改index，将B所在的列作为行索引</span></span><br><span class="line">df.sort_index() <span class="comment"># 将数据按照index进行排序</span></span><br><span class="line">df.sort_values([col1, col2], ascending=[<span class="keyword">True</span>,<span class="keyword">False</span>]) <span class="comment"># 根据col1和col2的值进行排序，col1是升序，col2是降序</span></span><br><span class="line">S.argsort() <span class="comment"># 返回Series对应的值的order，S[S.argsort()]返回的是对应的从小到大的Series数值</span></span><br><span class="line">df.reset_index(drop=<span class="keyword">False</span>/<span class="keyword">True</span>, inplace=<span class="keyword">False</span>/<span class="keyword">True</span>) <span class="comment"># 数据的index换成从0开始的, drop是说是否保留原来的index, 保留的话就多一列, inplace是说是否修改原来的df</span></span><br><span class="line">data[<span class="string">'Age'</span>] = pd.cut(data[<span class="string">'Age'</span>], bins=<span class="number">6</span>, labels=np.arange(<span class="number">6</span>)) <span class="comment"># 对数值型数据进行区间分割，分割成6个bin，label用0-5表示</span></span><br><span class="line">np.tile(a, N).flatten() <span class="comment"># 对数据a进行重复</span></span><br></pre></td></tr></table></figure><h2 id="9-数据分组"><a href="#9-数据分组" class="headerlink" title="9 数据分组"></a>9 数据分组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(col).size() <span class="comment"># 按照col对数据进行分组，并计算每一组的数量, 如果是count的话每列都会计算一次分组后的数量, 比较冗余</span></span><br><span class="line">df.groupby([col1, col2]).mean() <span class="comment"># 按照col1,col2进行分组，并计算各组的均值</span></span><br><span class="line">df.groupby([col1, col2]).agg([<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>]) <span class="comment"># 按照col1col2进行分组，计算各组之间的min, max, mean</span></span><br><span class="line">df.groupby([col1, col2]).agg(&#123;<span class="string">'a'</span>:<span class="string">'min'</span>, <span class="string">'b'</span>:<span class="string">'max'</span>, <span class="string">'c'</span>:<span class="string">'mean'</span>&#125;) <span class="comment"># 按照col1col2进行分组，计算各组之间的a列的min, b列的max, c列的mean</span></span><br><span class="line">df.groupby(col1)[col2].mean() <span class="comment"># 计算按照col1分组的col2对应的均值</span></span><br><span class="line">df.pivot.table(index=col1, values=[col2, col3], aggfun=<span class="string">'mean'</span>) <span class="comment"># 以col1的值为index,以col2,col3值为列进行分组计算各元素平均值</span></span><br><span class="line">df.apply(np.mean) <span class="comment"># 计算每一列的平均值</span></span><br><span class="line">df.apply(np.max, axis=<span class="number">1</span>) <span class="comment">#计算每一行的平均值</span></span><br><span class="line">df.applymap(<span class="keyword">lambda</span> x : x.upper()) <span class="comment"># 对多列数据操作, 这里是对各列都大写</span></span><br><span class="line"><span class="keyword">for</span> name,data <span class="keyword">in</span> df.groupby(<span class="string">'col'</span>):</span><br><span class="line"><span class="keyword">print</span> name <span class="comment"># col列分类后的值</span></span><br><span class="line"><span class="keyword">print</span> data <span class="comment"># col列名称等于name对应的数据行</span></span><br><span class="line">df.groupby(<span class="string">'name'</span>).apply(ownfunc) <span class="comment"># 可以对不同组进行自定义函数操作</span></span><br></pre></td></tr></table></figure><h2 id="10-数据合并"><a href="#10-数据合并" class="headerlink" title="10 数据合并"></a>10 数据合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df1.append([df2, df3])  <span class="comment"># 也可以追加两个DF</span></span><br><span class="line">pd.concat([df1.set_index(<span class="string">'a'</span>), df2.set_index(<span class="string">'a'</span>)], sort=<span class="keyword">False</span>, axis=<span class="number">1</span>, join=<span class="string">'inner'</span>) <span class="comment"># 和上述利用merge在a字段上进行内连接的效果类似,因为concat是基于index进行连接的,merge可以不基于index,指定字段</span></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>) <span class="comment">#列数相同, 行合在一起</span></span><br><span class="line">pd.concat(frames, keys=[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>], axis=<span class="number">0</span>) <span class="comment">#行数相同, 列合在一起, 每个数据的来源分别标注xyz</span></span><br><span class="line">pd.merge(df1, df2, on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>], how=<span class="string">'outer'</span>/<span class="string">'inner'</span>/<span class="string">'left'</span>/<span class="string">'right'</span>) <span class="comment"># 合并df1和df2,根据df1的key1和df2的key2, 连接方式是外链接..</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">'inner'</span>, left_index=<span class="keyword">True</span>, right_on=<span class="string">'id'</span>) <span class="comment"># 对数据进行merge,左表以index作为连接关键字,右表用id作为关键字</span></span><br><span class="line">np.vstack((a,b)) <span class="comment"># 乱入一个numpy合并用法，行合并</span></span><br><span class="line"><span class="comment"># pd.join与merge用法类似, 只不过默认是left链接, merge是inner连接</span></span><br></pre></td></tr></table></figure><div style="display: none"><br>### 2.1 div的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">users = pd.read_table(<span class="string">'https://raw.githubusercontent.com/justmarkham/DAT8/master/data/u.user'</span>, </span><br><span class="line">        sep=<span class="string">'|'</span>, index_col=<span class="string">'user_id'</span>)</span><br><span class="line">total = users.groupby([<span class="string">'occupation'</span>]).gender.count() <span class="comment"># 计算occupation的对应的人数</span></span><br><span class="line">gender = users.groupby([<span class="string">'occupation'</span>,<span class="string">'gender'</span>]).gender.count() <span class="comment"># 计算各职业各性别的人数</span></span><br><span class="line">(gender.div(total, level=<span class="string">'occupation'</span>)*<span class="number">100</span>).unstack() <span class="comment">#计算各职业的各性别的百分比</span></span><br></pre></td></tr></table></figure><br><br></div><h2 id="11-时序数据操作"><a href="#11-时序数据操作" class="headerlink" title="11 时序数据操作"></a>11 时序数据操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df.index = pd.date_range(<span class="string">'2018/1/1'</span>, period=df.shape[<span class="number">0</span>]) <span class="comment"># 添加时间序列作为行名</span></span><br><span class="line">pd.to_datetime(df.a, format=<span class="string">'%Y'</span>) <span class="comment"># 将df的a列转化成datetime类型的年</span></span><br><span class="line">pd.to_datetime(<span class="number">1490195805</span>, unit=<span class="string">'s'</span>) <span class="comment"># 对UNIX时间进行时间转换</span></span><br><span class="line">df[<span class="string">'a'</span>].to_datetime().year/month/day <span class="comment"># df的a列转换为datetime类型之后提取其中的year或者month或者day</span></span><br><span class="line">(df[<span class="string">'a'</span>].to_datetime().max() - df[<span class="string">'a'</span>].to_datetime().min()).days <span class="comment"># 计算a列中最早最晚时间差</span></span><br><span class="line">df[<span class="string">'Date'</span>].dt.dayofweek <span class="comment"># 获取每周第几天</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line">dt.datetime(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 通过datetime包定义数据时间</span></span><br><span class="line">dt.datetime.today() <span class="comment"># 返回今天对应的时间</span></span><br><span class="line"></span><br><span class="line">df.resample(<span class="string">'10AS'</span>).sum() </span><br><span class="line"><span class="comment"># downsample时序数据, 频率是每10年算各列的加和, S是index从1月1日开始, 不加S则从12月30日开始</span></span><br><span class="line"><span class="comment"># resample的各个字符含义: A-year, M-month, W-week, D-day, H-hour, T-minute, S-second</span></span><br></pre></td></tr></table></figure><p>除了downsample也可以upsample需要插值, 具体使用参考<a href="https://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.resample.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="绘图命令"><a href="#绘图命令" class="headerlink" title="绘图命令"></a><font color="red">绘图命令</font></h1><h2 id="1-pandas内置绘图"><a href="#1-pandas内置绘图" class="headerlink" title="1. pandas内置绘图"></a>1. pandas内置绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.plot.bar() <span class="comment"># barplot, stacked=True, 堆叠</span></span><br><span class="line">df.plot.barh() <span class="comment"># 绘制水平的barplot</span></span><br><span class="line">df.plot.hist(bins = <span class="number">20</span>) <span class="comment"># 绘制直方图,单维度</span></span><br><span class="line">df.plot.box() <span class="comment"># 对每列去看一些分布outlier</span></span><br><span class="line">df.plot.area() <span class="comment"># 堆叠区域图</span></span><br><span class="line">df.plot.scatter(x=<span class="string">'a'</span>, y=<span class="string">'b'</span>) <span class="comment"># 散点图</span></span><br><span class="line">df.plot.pie(subplots=<span class="keyword">True</span>) <span class="comment"># 绘制带图例的饼图</span></span><br></pre></td></tr></table></figure><h2 id="2-matplotlib绘图的一些设置"><a href="#2-matplotlib绘图的一些设置" class="headerlink" title="2. matplotlib绘图的一些设置"></a>2. matplotlib绘图的一些设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>)) <span class="comment"># 设置画布大小</span></span><br><span class="line">plt.xticks([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>], [<span class="string">r'a'</span>,<span class="string">r'b'</span>,<span class="string">r'c'</span>]) <span class="comment"># 设置坐标轴刻度</span></span><br><span class="line">plt.xlim(<span class="number">1</span>,<span class="number">3</span>) <span class="comment"># 设置坐标位置</span></span><br><span class="line">plt.title() <span class="comment"># 标题</span></span><br><span class="line">plt.xlabel(<span class="string">'xxx'</span>, fontsize=<span class="number">18</span>) <span class="comment"># 绘制label</span></span><br><span class="line">plt.text(<span class="number">0.8</span>, <span class="number">0.9</span>, <span class="string">'xxx'</span>, color=<span class="string">'k'</span>, fontsize=<span class="number">15</span>) <span class="comment"># 进行注解</span></span><br><span class="line">plt.grid(<span class="keyword">True</span>) <span class="comment"># 网格线</span></span><br></pre></td></tr></table></figure><h2 id="3-seaborn绘图"><a href="#3-seaborn绘图" class="headerlink" title="3. seaborn绘图"></a>3. seaborn绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- sns.displot(x, kde=<span class="keyword">True</span>, bins=<span class="number">20</span>, rug=<span class="keyword">True</span>, fit=stats.gamma) <span class="comment"># histgram加密度线,样本分布情况, 拟合某些分布fit</span></span><br><span class="line">- sns.kdeplot <span class="comment"># 类似于上面的,kde是每个样本用正态分布画,如果样本多,高度就高,之后再做归一化</span></span><br><span class="line">- sns.jointplot(x,y,data) <span class="comment"># 绘制带有histgram以及散点图的图，两个变量</span></span><br><span class="line">- sns.pairplot(df) <span class="comment"># 直接绘制各个列之间的散点图以及对应的histgram，多个变量</span></span><br><span class="line">- 多图绘制<span class="number">1</span></span><br><span class="line">  g = sns.PairGrik(df) <span class="comment"># 各个列混合,产出n*n个格子</span></span><br><span class="line">  g.map_diag(sns.kdeplot) <span class="comment"># 对角线绘制</span></span><br><span class="line">  g.map_offdiag(sns.kdeplot, cmap=<span class="string">'Blues_d'</span>, n_levels=<span class="number">20</span>) <span class="comment"># 绘制对角线是kde密度图其他为等高线的图</span></span><br><span class="line">- 多图绘制<span class="number">2</span></span><br><span class="line">  g = FaceGrid(row=[..],aspect=<span class="number">1.5</span>, data=)</span><br><span class="line">  g.map(sns.boxplot, x, y, hue, hue_order=[], ...)</span><br><span class="line">- 多图绘制<span class="number">3</span></span><br><span class="line">  g = sns.PairGrid(data, x_vars=[], y_vars=[], aspect=<span class="number">0.5</span>, size=<span class="number">3.5</span>)</span><br><span class="line">  g.map(sns.violinplot, palette=<span class="string">'bright'</span>) <span class="comment"># x_vars数量*y_vars数量个子图，然后每个子图都绘制violinplot</span></span><br><span class="line">- 关联分析 sns.lmplot</span><br><span class="line">  · sns.lmplot(x, y, data) <span class="comment"># 散点图+线性回归,95%置信区间,适用于连续值</span></span><br><span class="line">- sns.residplot() <span class="comment"># 残差图</span></span><br><span class="line">- sns.barplot(x,y,hue,ci=<span class="keyword">None</span>)  <span class="comment"># 是否打开置信区间</span></span><br><span class="line">- sns.stripplot(x, y, data, jitter =<span class="keyword">True</span>) <span class="comment"># 基于x为离散数据的,类似于散点图的boxplot</span></span><br><span class="line">- sns.swarmplot(x, y, data) <span class="comment">#  蜂群图，类似于小提琴图的点版</span></span><br><span class="line">- sns.boxplot()</span><br><span class="line">- sns.violinplot(bw) <span class="comment"># 属于kde以及boxplot的组合，既看了单变量分布，也看了各变量之间的差异</span></span><br><span class="line">- sns.violinplot(split=<span class="keyword">True</span>， hue， inner=<span class="string">'stick'</span>) <span class="comment"># split将hue为两个类型的进行拼接绘制小提琴图，stick，每个样本绘制竖线</span></span><br><span class="line">- sns.countplot(x, data) <span class="comment"># 绘制离散变量数量分布，类似于value_counts()，类似于barplot但是使用的统计量是数量</span></span><br><span class="line">- sns.pointplot(x, y, hue) <span class="comment"># 查看离散变量x以及hue在离散变量y上的差别，使用均值，画点</span></span><br><span class="line">- sns.factorplot(x, y, hue, col, data, kind=<span class="string">'swarm'</span>) <span class="comment"># 是一种泛化的绘图函数</span></span><br><span class="line">- a.savefig(<span class="string">'xx'</span>) <span class="comment"># 进行图片存储 plt函数</span></span><br></pre></td></tr></table></figure><h2 id="4-一些图形实例"><a href="#4-一些图形实例" class="headerlink" title="4. 一些图形实例"></a>4. 一些图形实例</h2><h3 id="4-1-barplot"><a href="#4-1-barplot" class="headerlink" title="4.1 barplot"></a>4.1 barplot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 绘图包的载入</span></span><br><span class="line">% matplotlib inline <span class="comment"># 内嵌画图, 有这个命令就可以省去plt.show()</span></span><br><span class="line">Series.plot(kind = <span class="string">'bar'</span>) <span class="comment"># 绘制条形图</span></span><br><span class="line">plt.xlabel(<span class="string">'xxx'</span>) <span class="comment"># 加x轴label</span></span><br><span class="line">plt.ylabel(<span class="string">'yyy'</span>) <span class="comment"># 加y轴label</span></span><br><span class="line">plt.title(<span class="string">'zzz'</span>) <span class="comment"># 加标题</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p1.png" alt="p1"></p><h3 id="4-2-scatter-plot"><a href="#4-2-scatter-plot" class="headerlink" title="4.2 scatter plot"></a>4.2 scatter plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, s=size, c=<span class="string">'green'</span>) <span class="comment"># 绘制散点图, s表明点大小, c表示点的颜色, 这两个参数都可以是list</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p2.png" alt="p2"></p><h3 id="4-3-pie-chart"><a href="#4-3-pie-chart" class="headerlink" title="4.3 pie chart"></a>4.3 pie chart</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie([...], labels=[...], colors=[...], explode=(...), startangle=<span class="number">90</span>) <span class="comment"># 饼图的参数都是list, explode参数是为了让饼图不同类之间有空隙的参数</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p3.png" alt="p3"></p><h3 id="4-4-分组scatter-plot"><a href="#4-4-分组scatter-plot" class="headerlink" title="4.4 分组scatter plot"></a>4.4 分组scatter plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.lmplot(x=<span class="string">'age'</span>, y=<span class="string">'Fare'</span>, data=df, hue=<span class="string">'sex'</span>, fit_reg=<span class="keyword">False</span>) <span class="comment"># 绘制以age和Fare为xy轴的散点图, 以性别分类</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p4.png" alt="p4"></p><h3 id="4-5-histgram"><a href="#4-5-histgram" class="headerlink" title="4.5 histgram"></a>4.5 histgram</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(S, bins=np.arange(<span class="number">0</span>, <span class="number">600</span>, <span class="number">10</span>)) <span class="comment"># 绘制直方图, bin可以自己定义</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">a = sns.dstplot(S) <span class="comment"># 绘制直方图, 带一条正态拟合曲线</span></span><br><span class="line">a.set(xlabel=<span class="string">''</span>, ylabel=<span class="string">''</span>, title=<span class="string">''</span>) <span class="comment"># 设定label</span></span><br><span class="line">sns.despline() <span class="comment"># 去掉右侧上侧的边框</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p5.png" alt="p5"></p><h3 id="4-6-correlation-plot"><a href="#4-6-correlation-plot" class="headerlink" title="4.6 correlation plot"></a>4.6 correlation plot</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df) <span class="comment">#绘制带correlation散点图+histgram</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p6.png" alt="p6"></p><h3 id="4-7-pairwise散点图"><a href="#4-7-pairwise散点图" class="headerlink" title="4.7 pairwise散点图"></a>4.7 pairwise散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(df) <span class="comment"># 多列数据绘制散点图</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p7.png" alt="p7"></p><h3 id="4-8-分类boxplot图"><a href="#4-8-分类boxplot图" class="headerlink" title="4.8 分类boxplot图"></a>4.8 分类boxplot图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df, hue=<span class="string">''</span>) <span class="comment"># 分类box plot, hue是类别</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p8.png" alt="p8"></p><h3 id="4-9-分类boxplot点图"><a href="#4-9-分类boxplot点图" class="headerlink" title="4.9 分类boxplot点图"></a>4.9 分类boxplot点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x=<span class="string">''</span>, y=<span class="string">''</span>, data=df, hue=<span class="string">'sex'</span>, jitter=<span class="keyword">True</span>...) </span><br><span class="line"><span class="comment"># 绘制类似于boxplot的图，只不过画的是每个box里面的点, x轴是不同数据类</span></span><br></pre></td></tr></table></figure><p><img src="/images/pandas_commands/p9.png" alt="p9"></p><h1 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a><font color="red">大数据知识</font></h1><h2 id="1-hadoop"><a href="#1-hadoop" class="headerlink" title="1. hadoop"></a>1. hadoop</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir /input/example1 <span class="comment"># 将用于处理的文件上传到集群中，集群自动分配</span></span><br><span class="line">hadoop fs -put text* /input/example1 <span class="comment"># 查看文件是否放好</span></span><br><span class="line">hadoop fs -ls /input/example1 <span class="comment"># 集群上跑任务</span></span><br><span class="line">hadoop jar /usr/lib/hadoop-current/share/hadoop/tools/lib/hadoop-streaming-2.7.2.jar \</span><br><span class="line">  -file count_mapper.py \ <span class="comment"># 将这个文件传到集群上一会会使用</span></span><br><span class="line">  -mapper count_mapper.py \ <span class="comment"># 将这个文件充当mapper处理</span></span><br><span class="line">  -file count_reducer.py \</span><br><span class="line">  -reducer count_reducer.py \</span><br><span class="line">  -input /input/example1 \ <span class="comment"># 以终端的方式将文件一个个的传给命令</span></span><br><span class="line">  -output /output/example1 </span><br><span class="line">hadoop fs -getmerge /output/example1 result.txt <span class="comment"># 运行成功之后将结果拉下来，将hadoop执行完成的结果存在/output/</span></span><br></pre></td></tr></table></figure><h2 id="2-pyspark-基于spark"><a href="#2-pyspark-基于spark" class="headerlink" title="2. pyspark(基于spark)"></a>2. pyspark(基于spark)</h2><h3 id="2-1-初始化RDD的方法"><a href="#2-1-初始化RDD的方法" class="headerlink" title="2.1 初始化RDD的方法"></a>2.1 初始化RDD的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 第一种方式直接通过内置的数据类型进行读取</span><br><span class="line">  import pyspark</span><br><span class="line">  form pyspark import SparkContext <span class="comment"># 驱动</span></span><br><span class="line">  from pyspark import SparkConf <span class="comment"># 基本配置，内存多少，任务名称</span></span><br><span class="line">  conf = SparkConf().setAppName(<span class="string">"miniProject"</span>).setMaster(<span class="string">"local[*]"</span>) <span class="comment"># 应用名称miniProject，路径在本地</span></span><br><span class="line">  sc = SparkContext.getOrCreate(conf) <span class="comment"># 对上面的应用进行初始化，如果有的话直接取过来，没有的话就创建</span></span><br><span class="line">  my_list = [1,2,3,4,5]</span><br><span class="line">  rdd = sc.parallelize(my_list) <span class="comment"># 并行化一个RDD数据，rdd是不可以直接看见，是一个对象，看不到内容</span></span><br><span class="line">  rdd.getNumPartitions() <span class="comment"># 存了多少份</span></span><br><span class="line">  rdd.glom().collect() <span class="comment"># 查看分区状况，collect是一个比较危险的命令，会把集群上的内容取到本地以列表返回，存在当前机器的内存中，可能会瞬间爆掉</span></span><br><span class="line"></span><br><span class="line">- 第二种通过本地文件进行读取</span><br><span class="line">  rdd = sc.textFile(<span class="string">"file://"</span>+os.getcwd()+<span class="string">'/nd.txt'</span>) <span class="comment"># 一定要将"file//"+绝对路径的这个文件，注意这种读取是以每一行为一个元素的读取，每个元素作为一个item</span></span><br><span class="line">  rdd = sc.wholeTextFiles(<span class="string">"file"</span>+cwd+<span class="string">"/names"</span>) <span class="comment"># 整个文件夹的内容(多个文件)进行读取, 对/names里面所有的文本进行读取，注意~这个时候读入的内容就是以元组内容进行组织的，(文件名,文件内容)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-RDD的操作"><a href="#2-2-RDD的操作" class="headerlink" title="2.2 RDD的操作"></a>2.2 RDD的操作</h3><p><strong>Spark的transformations命令(非立即执行)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- map() <span class="comment"># 对RDD上的每个元素都进行同一操作，一进一出</span></span><br><span class="line">- flatMap() <span class="comment"># 对RDD中的item执行同一个操作之后得到一个list，然后以平铺的方式把list里所有的结果组成新的list，也就是一进多出</span></span><br><span class="line">- filter() <span class="comment"># 筛选出满足条件的item</span></span><br><span class="line">- distinct() <span class="comment"># 对RDD中item去重</span></span><br><span class="line">- sample() <span class="comment"># 从RDD中进行采样</span></span><br><span class="line">- sortBy(keyfunc=lambda (x,y):y, ascending=False <span class="comment"># 对RDD中的item进行排序</span></span><br><span class="line">- takeSample(3) <span class="comment"># 采样</span></span><br><span class="line">- map与flatmap之间的差别</span><br><span class="line">  strRDD = sc.parallelize([<span class="string">'hello world'</span>, <span class="string">'ni hao'</span>])</span><br><span class="line">  strRDD.map(lambda x: x.split(<span class="string">' '</span>)) <span class="comment"># 返回的是[['hello', 'world'], ['ni', 'hao']]</span></span><br><span class="line">  strRDD.flatMap(lambda x: x.split(<span class="string">' '</span>)) <span class="comment"># 返回的是[['hello', 'world', 'ni', 'hao']]</span></span><br><span class="line">- RDD数据的Transformation可以一个接一个的串联</span><br><span class="line">  def myfunc(x):</span><br><span class="line">    <span class="keyword">if</span> x%2==1:</span><br><span class="line">      <span class="built_in">return</span> 2*x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">return</span> x</span><br><span class="line">  numberRDD = sc.parallelize(range(1,11)) <span class="comment"># 1-10</span></span><br><span class="line">  retRDD = (numberRDD.map(myfunc).filter(lambda x: x&gt;6).distinct())</span><br><span class="line">  retRDD.collect() <span class="comment"># 返回所有的结果</span></span><br><span class="line">- RDD之间的操作</span><br><span class="line">  rdd1.union(rdd2) <span class="comment"># 并集, 类似于两个list相加</span></span><br><span class="line">  rdd1.intersection(rdd2) <span class="comment"># 交集, 类似于python中的&amp;</span></span><br><span class="line">  rdd1.substract(rdd2) <span class="comment"># 差集,类似于python中的-</span></span><br><span class="line">  rdd1.cartesian(rdd2) <span class="comment"># 笛卡尔乘积,类似于排列组合的所有元素，python中的product</span></span><br></pre></td></tr></table></figure></p><p><strong>Spark的action命令(立即执行)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- collect <span class="comment"># 危险！list形式返回</span></span><br><span class="line">- first() <span class="comment"># 返回第一个item</span></span><br><span class="line">- take(n) <span class="comment"># 返回n个item</span></span><br><span class="line">- count() <span class="comment"># 计算RDD中item的个数</span></span><br><span class="line">- top(n) <span class="comment"># 自然序排序取前n个</span></span><br><span class="line">- reduce(n) <span class="comment"># 做聚合</span></span><br></pre></td></tr></table></figure></p><p><strong>pairRDD操作</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 基本操作</span><br><span class="line">  reduceByKey() <span class="comment"># 对所有有着相同key的items执行reduce操作</span></span><br><span class="line">  groupByKey() <span class="comment"># 返回类似于(key, listOfValues)这种元组RDD，后面的value list是同一个key下面的</span></span><br><span class="line">  sortByKey() <span class="comment"># 按照key进行排序</span></span><br><span class="line">  countByKey() <span class="comment"># 按照key对item进行个数统计</span></span><br><span class="line">  countByValue() <span class="comment"># 按照value对item进行个数统计</span></span><br><span class="line"> collectAsMap() <span class="comment"># 与collect类似，返回的是k-v字典</span></span><br><span class="line">- 不同pairRDD之间进行关联</span><br><span class="line">  RDD1 = sc.parallelize([(<span class="string">'a'</span>,1), (<span class="string">'b'</span>,2), (<span class="string">'c'</span>,3)])</span><br><span class="line">  RDD1 = sc.parallelize([(<span class="string">'b'</span>,20), (<span class="string">'c'</span>,30), (<span class="string">'d'</span>,40)])</span><br><span class="line">  RDD1.join(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行连接</span></span><br><span class="line">  RDD1.leftOuterJoin(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行左连接，RDD1作为主导</span></span><br><span class="line">  RDD1.rightOuterJoin(RDD2).collect() <span class="comment"># 对两个pairRDD之间利用key进行左连接，RDD2作主导</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-初始化Spark-DataFrame的方法"><a href="#2-3-初始化Spark-DataFrame的方法" class="headerlink" title="2.3 初始化Spark DataFrame的方法"></a>2.3 初始化Spark DataFrame的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- 创建SparkSession类</span><br><span class="line">  from pyspark.sql import SparkSession</span><br><span class="line">  spark = SparkSession.builder.appName(<span class="string">'Python Spark SQL'</span>)\</span><br><span class="line">    .config(<span class="string">'spark.some.config.option'</span>, <span class="string">'some-value'</span>)\</span><br><span class="line">    .getOrCreate() <span class="comment"># 利用spark SQL构建一个入口</span></span><br><span class="line">- 文件的读取</span><br><span class="line">  在SparkSession中可以从一个已存在的RDD或者hive表或者Spark数据源中创建一个DataFrame</span><br><span class="line">  df = spark.read.csv(<span class="string">"/path/to/your.csv"</span>) <span class="comment"># 读入csv文件</span></span><br><span class="line">- DataFrame操作</span><br><span class="line">  df.show() <span class="comment"># 展示数据</span></span><br><span class="line">  df.printSchema() <span class="comment"># 类似于Pandas里面的df.info()函数</span></span><br><span class="line">  df.describe([...]) <span class="comment"># 对list里面的各列进行统计</span></span><br><span class="line">  df.select([<span class="string">'name'</span>, <span class="string">'age'</span>]).show() <span class="comment"># 选两列</span></span><br><span class="line">  df.select(df[<span class="string">'name'</span>], df[<span class="string">'age'</span>]+1).show() <span class="comment"># 选取name这列同时age这列+1</span></span><br><span class="line">  df.filter(df[<span class="string">'age'</span>]&gt;21).show() <span class="comment"># 对数据进行filter</span></span><br><span class="line">  df.groupBy(<span class="string">'age'</span>).count().show() <span class="comment"># 对年龄分组同时统计人数，count类似于size</span></span><br><span class="line">  df.groupBy(<span class="string">'age'</span>).agg(...).show() <span class="comment"># 类似于pandas中的用法</span></span><br><span class="line">  df.select(<span class="string">'xx'</span>, df[<span class="string">'xx'</span>].cast(...).<span class="built_in">alias</span>(...)) <span class="comment"># 类型转换+重命名</span></span><br><span class="line">  df.withColumn(<span class="string">'xxx'</span>, ...) <span class="comment"># 对列进行处理同时产生新的列xxx</span></span><br><span class="line">  df.orderBy(<span class="string">'xxx'</span>, ascending=False) <span class="comment"># 对某列进行排序</span></span><br><span class="line">  df.filter(df[<span class="string">'value'</span>].isNull()).count() <span class="comment"># isNull空值处理</span></span><br><span class="line">  df.withColumn(<span class="string">'sex'</span>, lit(<span class="string">'man'</span>))) <span class="comment"># lit是用来产生独立的数据的</span></span><br><span class="line">  from pyspark.sql.functions import f <span class="comment"># 有很多内置的函数,包括udf自定义函数</span></span><br><span class="line">- 时间操作</span><br><span class="line">  df.withColumn(<span class="string">'day'</span>, dayofmonth(<span class="string">'time'</span>)) <span class="comment"># dayofmonth等函数的使用，这些函数也是内置在pyspark.sql.functions中的</span></span><br><span class="line">- 类型转换</span><br><span class="line">  RDD.toDF() <span class="comment"># RDD类型转换为spark DataFrame类型</span></span><br><span class="line">  scDF.toPandas() <span class="comment"># 转换spark DataFrame到pandas DataFrame</span></span><br><span class="line">  RDD = scDF.select(<span class="string">'col1'</span>, <span class="string">'col2'</span>).rdd.map(lambda r: (r[0], r[1])) <span class="comment"># spark DataFrame转RDD</span></span><br></pre></td></tr></table></figure><h3 id="2-4-初始化Spark-DataFrame的方法"><a href="#2-4-初始化Spark-DataFrame的方法" class="headerlink" title="2.4 初始化Spark DataFrame的方法"></a>2.4 初始化Spark DataFrame的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意DataFrame不是一个表，所以如果想用SQL的方式进行表的查询的时候需要事先构建一个表</span></span><br><span class="line">df.createOrReplaceTemView(<span class="string">'sqltable'</span>)</span><br><span class="line">sqlDF = spark.sql(<span class="string">'SELECT * FROM sqltable'</span>) <span class="comment"># 使用SQL的方式对数据进行提取，spark是自己创建的，返回的结果还是DataFrame</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      小象机器学习训练营知识点总结
    
    </summary>
    
      <category term="数据分析,工具应用" scheme="http://WenchaoXiu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习各类算法实践</title>
    <link href="http://WenchaoXiu.github.io/2018/07/17/ML-algrithom-usage/"/>
    <id>http://WenchaoXiu.github.io/2018/07/17/ML-algrithom-usage/</id>
    <published>2018-07-17T01:44:48.000Z</published>
    <updated>2018-08-02T03:49:09.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description">机器学习算法的实践笔记</p><p><img src="./images/sklearn.jpg" alt="" style="width:100%"></p><a id="more"></a><h1 id="笔记简介"><a href="#笔记简介" class="headerlink" title="笔记简介"></a>笔记简介</h1><p>主要整理一下近期学习的机器学习算法具体的实现过程,主要使用的package有scikit-learn,xgboost</p><h1 id="sklearn各功能实现"><a href="#sklearn各功能实现" class="headerlink" title="sklearn各功能实现"></a>sklearn各功能实现</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>1.对类别数据进行离散化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为构件数学模型的时候类别特征可以取多个值，不同的值实际上代表的是不同特征属性，因此需要对类别特征进行离散化处理</span></span><br><span class="line"><span class="comment"># 1.利用pandas的get_dummies进行onehot编码</span></span><br><span class="line">newDF = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> DF.columns:</span><br><span class="line">tmp = pd.get_dummies(DF[col])</span><br><span class="line">tmp = pd.rename(columns = <span class="keyword">lambda</span> x: col+<span class="string">'_'</span>+str(x))</span><br><span class="line">newDF = pd.concat([newDF, tmp], axis=<span class="number">1</span>)</span><br><span class="line">x = newDF.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.利用sklearn的label_binarize进行onehot编码</span></span><br><span class="line"><span class="comment"># 除了上述的pd.get_dummies之外的另一种等价方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> label_binarize</span><br><span class="line">DF_col = label_binarize(DF[col], classes = np.arange(len(pd.unique(DF[col]))))</span><br><span class="line"><span class="comment"># label_binarize返回的和pd.get_dummies返回的对象类似，列数与类别数相同，且只包含01值</span></span><br><span class="line"><span class="comment"># 区别在于，label_binarize返回的是ndarray数据，pd.get_dummies返回的是DataFrame数据</span></span><br><span class="line"><span class="comment"># 因此，np.array_equal(DF_col, pd.get_dummies(DF[col]).values)返回的是True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.sklearn的OneHotEncoder</span></span><br><span class="line"><span class="comment"># 这个功能略感鸡肋(也可能是打开方式不对)给个例子，就不赘述了</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">     [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">     [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">     [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],]</span><br><span class="line">ohe = OneHotEncoder(sparse=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> ohe.fit_transform(x)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure></p><p>2.对响应变量进行转换，将类别数据转化为不同int型数字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y = DF.accept</span><br><span class="line">y_int = pd.Categorical(y).codes <span class="comment">#得到从0~n-1的n类数字，分别对应不同的类别</span></span><br><span class="line"><span class="comment"># 与上述pd.get_dummies的区别在于，get_dummies返回的是DataFrame数据，且只有01两个值</span></span><br><span class="line"><span class="comment"># 但是上述方法返回的是ndarray数据，返回的值不止01，具体的根据类别数量进行确定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">y_int = LabelEncoder().fit_transform(y_train)</span><br><span class="line"><span class="comment"># 实现了跟上面相同的功能，输入是不用类别的label，返回的是0~n-1的数字</span></span><br></pre></td></tr></table></figure></p><p>3.训练集测试集分割<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样做的目的是方便测试算法泛化能力</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=<span class="number">0.7</span>)</span><br><span class="line"><span class="comment"># PS:其中x, y是ndarray数据类型，如果是DF数据的话需要使用DF.values进行转化</span></span><br></pre></td></tr></table></figure></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>1.PCA数据降维<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca_model = PCA(n_components=<span class="number">2</span>, whiten=<span class="keyword">True</span>)</span><br><span class="line">x_pca = pca_model.fit_transform(x)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'top2 方差'</span>, pca_model.explained_variance_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'top2 方差所占比例'</span>, pca_model.explained_variance_ratio_</span><br><span class="line"><span class="comment"># 其中的n_component是选择将数据降维后，选取其中的n个特征（特征顺序按照特征值从高到低排序）</span></span><br><span class="line"><span class="comment"># pca_model.explained_variance_是对应的前两个特征的方差</span></span><br><span class="line"><span class="comment"># pca_model.explained_variance_ratio_是前两个特征的方差占总方差的比例</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.lmplot(x = <span class="string">'pc1'</span>, y=<span class="string">'pc2'</span>, data = pc_plot_data, hue=type, fit_reg=<span class="keyword">False</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_title(<span class="string">"Iris PCA 2 compotent"</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 上述代码用来绘图</span></span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/pinard/p/6243025.html" target="_blank" rel="noopener">使用教程</a></p><p>2.特征筛选<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用sklearn的SelectKBest进行特征选择</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2</span><br><span class="line">chi2_model = SelectKBest(chi2, k=<span class="number">2</span>)</span><br><span class="line">chi2_model.fit(x, y)</span><br><span class="line">selected_col = chi2_model.get_support(indices=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 之所以x和y都需要加进去是因为需要对每个特征和响应变量进行chi2检验，按照显著性排序，找到前两个特征（原特征）</span></span><br><span class="line"><span class="comment"># indices是为了返回对应的column数</span></span><br></pre></td></tr></table></figure></p><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/feature_selection.html" target="_blank" rel="noopener">官方文档</a> &amp; <a href="http://bluewhale.cc/2016-11-25/use-scikit-learn-for-feature-selection.html" target="_blank" rel="noopener">使用教程</a> &amp; <a href="http://d0evi1.com/sklearn/feature_selection/" target="_blank" rel="noopener">特征提取</a></p><p>3.原始特征变化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">poly = PolynomialFeatures(degree = <span class="number">2</span>, include_bias=<span class="keyword">True</span>, interaction_only=<span class="keyword">False</span>)</span><br><span class="line">x_poly = poly.fit_transform(x)</span><br><span class="line"><span class="comment"># 对数据特征进行变换，degree是特征的最高维数，include_bias加不加一列1，interaction_only是否只看有交互的特征</span></span><br></pre></td></tr></table></figure></p><h2 id="构建有监督模型"><a href="#构建有监督模型" class="headerlink" title="构建有监督模型"></a>构建有监督模型</h2><p>1.逻辑回归模型用于分类（Logistic Regression）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklean.linear_model <span class="keyword">import</span> LogisticRegressionCV, Lasso</span><br><span class="line">model = LinearRegeressionCV(Cs = np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>), cv = <span class="number">5</span>, n_job = <span class="number">-1</span>)</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = model.predict(x_train) <span class="comment"># 对训练集进行预测</span></span><br><span class="line">y_test_hat = model.predict(x_test) <span class="comment"># 对测试集进行预测</span></span><br><span class="line"><span class="keyword">print</span> model.C_ <span class="comment"># 获得各类别最佳超参数</span></span><br><span class="line"><span class="comment"># LinearRegeressionCV是一种自动确定正则化超参数的函数，其中Cs是一系列的正则化参数值，一般需要取不同数量级的数字</span></span><br><span class="line"><span class="comment"># cv是进行cross validation对超参数最优解进行确定，n_job=-1是用上全部线程，这里默认的正则是L2 norm</span></span><br><span class="line"><span class="comment"># PS:注意在进行多分类的时候选择的方法是one vers rest也就是一对多进行多分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意除了自带的cross-validation方法，还可以用更加普遍的方法GridSearchCV</span></span><br><span class="line">model = Lasso()</span><br><span class="line">GS_Lasso = GridSearchCV(model, param_grid=&#123;<span class="string">'alpha'</span>:np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>)&#125;, cv=<span class="number">5</span>)</span><br><span class="line">GS_Lasso.fit(x_train, y_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Lasso model最优参数: '</span>, GS_Lasso.best_params_</span><br></pre></td></tr></table></figure></p><p>2.决策树模型（DesitionTree）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对决策树的不同深度进行探究，求取对应的准确率</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">model = DecisionTreeClassifier()</span><br><span class="line">acc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line">    model.set_params(max_depth=i)</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    y_test_hat = model.predict(x_test)</span><br><span class="line">    acc.append(metrics.accuracy_score(y_test, y_test_hat))</span><br><span class="line">plt.plot(np.arange(<span class="number">1</span>,<span class="number">15</span>), acc, <span class="string">'ro'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'depth'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#决策树进行回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">reg = DecisionTreeRegressor(criterion=<span class="string">'mse'</span>, max_depth=deep)</span><br><span class="line">dt = reg.fit(x, y)</span><br></pre></td></tr></table></figure></p><p>3.随机森林模型（RandomForest）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">RF_model = RandomForestRegressor()</span><br><span class="line">RF_model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = RF_model.predict(y_train)</span><br><span class="line"><span class="comment"># 对于多值输出问题来说一般采用多值输出的方法进行模型构建，主要从两个角度：a.每个叶节点存储多个值 b.通过计算多个值的平均减少量作为split标准</span></span><br></pre></td></tr></table></figure></p><p><a href="http://sklearn.apachecn.org/cn/latest/modules/tree.html" target="_blank" rel="noopener">参考</a> &amp; <a href="https://www.cnblogs.com/pinard/p/6160412.html" target="_blank" rel="noopener">随机森林调参</a></p><p>4.bagging模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">DT_model = DecisionTreeRegressor(max_depth=<span class="number">9</span>)</span><br><span class="line">ridge_BG_model = BaggingRegressor(Pipeline([(<span class="string">'poly'</span>, PolynomialFeatures(degree=<span class="number">6</span>)), </span><br><span class="line">                                            (<span class="string">'ridge'</span>, linear_model.RidgeCV(alphas=np.logspace(<span class="number">-3</span>,<span class="number">4</span>,<span class="number">8</span>), cv=<span class="number">5</span>, fit_intercept=<span class="keyword">False</span>))])</span><br><span class="line">                                  , n_estimators=n_estimators, max_samples=max_samples)</span><br><span class="line">DT_BG_model = BaggingRegressor(DT_model, n_estimators=n_estimators, max_samples=max_samples)</span><br><span class="line"><span class="comment"># bagging是一种构建多个基分类器，对数据进行预测，并平均多个分类器的预测值的一种方法</span></span><br><span class="line"><span class="comment"># 输入需要有基分类器，基分类器的个数，以及对于样本选取的比例</span></span><br></pre></td></tr></table></figure></p><p>5.Adaboost模型<br><a href="http://www.cnblogs.com/pinard/p/6133937.html" target="_blank" rel="noopener">原理</a> &amp; <a href="https://www.cnblogs.com/pinard/p/6136914.html" target="_blank" rel="noopener">模型参数</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">base = DecisionTreeClassifier(n_estimators=<span class="number">100</span>, max_depth = <span class="number">3</span>, min_sample_split=<span class="number">4</span>, random_state=<span class="number">1</span>, oob_score=<span class="keyword">True</span>) </span><br><span class="line"><span class="comment"># 超过4个样本就进行样本的分割构建叶节点, 基分类器个数100，最大树深3，oob_score考虑带外分数</span></span><br><span class="line">AB_model = AdaBoostClassifier(base_estimator = base, learning_rate = <span class="number">0.1</span>)</span><br><span class="line">AB_model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = AB_model.predict(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确度: %.5.f'</span>%metrics.accuracy_score(y_train, y_train_hat)</span><br><span class="line"><span class="comment"># Adaboost是另一种集成模型，利用决策树模型作为基分类器，与上面的bagging的区别在于，bagging是可以并行的，各个模型的确定可以随机产生，最后平均化即可</span></span><br><span class="line"><span class="comment"># 但是对于Adaboost来说各个基分类器是串行产生的，每次新产生的分类器都与前面所有的分类器相关，具体是新的分类器是通过前面所有模型的残差和确定的</span></span><br><span class="line"><span class="comment"># 相当于不断强化基分类器与真实值的差别，因此Adaboost的基分类器需要更加泛化相比较Bagging的及模型</span></span><br><span class="line"><span class="comment"># 举个例子假如基分类器都是决策树，Bagging的深度更深，Adaboost的深度更浅</span></span><br><span class="line"><span class="comment"># 这里learning_rate实际上是fk(x)=fk−1(x)+ναkGk(x)中的ν(0&lt;ν&lt;1)，其中αk是根据分类器的错误率进行确定的模型权重</span></span><br><span class="line"><span class="comment"># Gk(x)是根据样本权重重新确定的基分类器，fk(x)是膜前获得的强分类器是k个基分类器的结合，理论上ν越小的话迭代下次数越多</span></span><br></pre></td></tr></table></figure></p><p>6.GBDT模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GBDT 每个基分类器要相对弱一点因为是提升树</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">gbdt_model = GradientBoostingClassifier(learning_rate=<span class="number">0.1</span>, max_depth=<span class="number">3</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">gbdt_model.fit(x_train, y_train)</span><br><span class="line">gbdt_y_train_hat = gbdt_model.predict(x_train)</span><br><span class="line">gbdt_y_test_hat = gbdt_model.predict(x_test)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.4f'</span>%metrics.accuracy_score(y_train, gbdt_y_train_hat)</span><br></pre></td></tr></table></figure></p><p>7.xgboost模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xgboost也是一种快速效果好的集成模型</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line">train_data = xgb.DMatrix(x_train, y_train)</span><br><span class="line">test_data = xgb.DMatrix(x_test, y_test)</span><br><span class="line">watch_list = [(test_data, <span class="string">'eval'</span>), (train_data, <span class="string">'train'</span>)]</span><br><span class="line">params = &#123;<span class="string">'eta'</span>:<span class="number">0.1</span>, <span class="string">'max_depth'</span>:<span class="number">6</span>, <span class="string">'objective'</span>:<span class="string">'multi:softmax'</span>, <span class="string">'num_class'</span>:<span class="number">3</span>&#125;</span><br><span class="line">xgb_model = xgb.train(params, train_data, num_boost_round=<span class="number">50</span>, evals=watch_list, evals_result=&#123;<span class="string">'eval_metric'</span>:<span class="string">'logloss'</span>&#125;) <span class="comment">#设置对应评估指标</span></span><br><span class="line">y_test_hat_xgb = xgb_model.predict(test_data) <span class="comment">#######test_data类型，xgb_model跟sklearn不同</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'xgb model: %.3f'</span>%(sum(y_test_hat_xgb==y_test)*<span class="number">1.0</span>/len(y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用XGBOOST的sklearn接口进行模型构建，这个方便点使用习惯和sklearn其他模型类似</span></span><br><span class="line">xgb_model = xgb.XGBClassifier(learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">100</span>, max_depth=<span class="number">2</span>, objective=<span class="string">'multi:softmax'</span>)</span><br><span class="line">xgb_model.fit(x_train, y_train)</span><br><span class="line">xgb_y_train_hat = xgb_model.predict(x_train)</span><br><span class="line">xgb_y_test_hat = xgb_model.predict(x_test)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.4f'</span>%metrics.accuracy_score(y_train, xgb_y_train_hat)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'验证集准确率: %.4f'</span>%metrics.accuracy_score(y_test, xgb_y_test_hat)</span><br></pre></td></tr></table></figure></p><p><a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html?highlight=fit#module-xgboost.sklearn" target="_blank" rel="noopener">sklearn API</a> &amp; <a href="https://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="noopener">参数解释</a> &amp; <a href="https://github.com/dmlc/xgboost/tree/master/demo#tutorials" target="_blank" rel="noopener">github使用教程</a> &amp; <a href="https://www.zhihu.com/question/41354392/answer/98658997" target="_blank" rel="noopener">GDBT和XGBOOSt区别</a> &amp; <a href="https://zhuanlan.zhihu.com/p/28663369" target="_blank" rel="noopener">Tatanic实例</a> &amp; <a href="https://zhuanlan.zhihu.com/p/31182879" target="_blank" rel="noopener"><strong>知乎教程</strong></a> &amp; <a href="https://zhuanlan.zhihu.com/p/26683576" target="_blank" rel="noopener"><strong>Ensemble模型介绍</strong></a></p><p>8.SVM模型<a href="https://www.cnblogs.com/pinard/p/6117515.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">model = svm.SVC(C=<span class="number">0.1</span>, kernel=<span class="string">'linear'</span>, decision_function_shape=<span class="string">'ovr'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">0</span>]&#125;)</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line">y_train_hat = model.predit(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'decision_function:\n'</span>, clf.decision_function(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\npredict:\n'</span>, clf.predict(x_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量的数目：'</span>, clf.n_support_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量的系数：'</span>, clf.dual_coef_</span><br><span class="line"><span class="keyword">print</span> <span class="string">'支撑向量: '</span>, clf.support_ <span class="comment"># 这个是对应的支持向量的索引值</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'模型精度: '</span>, model.score(x_train, y_train)</span><br><span class="line"><span class="comment"># C是惩罚系数，当C很大的时候为了保证损失函数最小对应的惩罚因子需要很小，使得模型很严格，决策边界之间的距离很小</span></span><br><span class="line"><span class="comment"># class_weight是为了方便对不平衡数据的操作，如果类别数据数量级差的太多的话会使模型准确度下降</span></span><br><span class="line"><span class="comment"># kernel可以选择不同的核函数，decision_function_shape是进行one vers rest，可以使用ovo,这样的话一对一</span></span><br><span class="line"><span class="comment"># decision_function计算每个样本到每一类的距离，选取最大的那个作为预测类别（因为在决策边界两侧），decision_function的ovr和ovo列数有差别</span></span><br><span class="line"><span class="comment"># predict就是正常的返回类别对应的数字</span></span><br><span class="line"><span class="comment"># svm的score返回的是精度类似于metrics.accuracy_score(x_train, y_train)</span></span><br><span class="line"></span><br><span class="line">weight = [<span class="number">2</span>,<span class="number">30</span>,<span class="number">2</span>,<span class="number">30</span>]</span><br><span class="line">clfs = [svm.SVC(C=<span class="number">1</span>, kernel=<span class="string">'linear'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">0</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">1</span>, kernel=<span class="string">'linear'</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">1</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">0.8</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.5</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">2</span>]&#125;),</span><br><span class="line">       svm.SVC(C=<span class="number">0.8</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.5</span>, class_weight=&#123;<span class="number">-1</span>:<span class="number">1</span>, <span class="number">1</span>:weight[<span class="number">3</span>]&#125;)]</span><br><span class="line"><span class="comment"># 对于不平衡数据进行权重的分配，保证结果的准确性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用SVM进行回归分析</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">print(<span class="string">'SVR - RBF'</span>)</span><br><span class="line">svr_rbf = svm.SVR(kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.2</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_rbf.fit(x, y)</span><br><span class="line">print(<span class="string">'SVR - Linear'</span>)</span><br><span class="line">svr_linear = svm.SVR(kernel=<span class="string">'linear'</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_linear.fit(x, y)</span><br><span class="line">print(<span class="string">'SVR - Polynomial'</span>)</span><br><span class="line">svr_poly = svm.SVR(kernel=<span class="string">'poly'</span>, degree=<span class="number">3</span>, C=<span class="number">100</span>)</span><br><span class="line">svr_poly.fit(x, y)</span><br><span class="line">print(<span class="string">'Fit OK.'</span>)</span><br><span class="line"><span class="comment"># 注意这里kernel可以选择linear/rbf分别对应线性核以及高斯核，其中线性核和高斯核分别有两个比较重要的参数</span></span><br><span class="line"><span class="comment"># C和gamma，其中C上面已经解释过了，gamma是一个跟核函数相关的参数，gamma是∂2的倒数，表征高斯核的方差大小，</span></span><br><span class="line"><span class="comment"># 所以∂2的倒数表征的是高斯核的精度，gamma值越大也就数据在训练集上准确度越高，增大过拟合的风险</span></span><br><span class="line"><span class="comment"># PS:kernel还可以选择poly多项式核，配合的参数是degree</span></span><br></pre></td></tr></table></figure></p><h2 id="构建无监督模型"><a href="#构建无监督模型" class="headerlink" title="构建无监督模型"></a>构建无监督模型</h2><p>1.Kmeans聚类<a href="https://www.cnblogs.com/pinard/p/6169370.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets <span class="keyword">as</span> ds</span><br><span class="line">x, y = ds.make_blobs(<span class="number">400</span>, n_features=<span class="number">2</span>, centers=<span class="number">4</span>, cluster_std=(<span class="number">1</span>, <span class="number">2.5</span>, <span class="number">0.5</span>, <span class="number">2</span>), random_state=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 这个函数的功能是根据高斯分布进行构建随机数据，用于后续的聚类分析</span></span><br><span class="line"><span class="comment"># 其中400是产生的样本的个数，n_features是产生的数据的维度，centers是对应数据的类别，cluster_std是定义不同类别的方差</span></span><br><span class="line"><span class="comment"># 这里centers可以是一组array数据，作为中心</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">model = KMeans(n_clusters=<span class="number">4</span>, init=<span class="string">'k-means++'</span>, n_init=<span class="number">10</span>, max_iter=<span class="number">300</span>)</span><br><span class="line">model.fit(x, y)</span><br><span class="line">y_hat = model.predict(x)</span><br><span class="line">model.cluster_centers_ <span class="comment"># 输出对应的聚类中心</span></span><br><span class="line"><span class="comment"># KMeans算法主要有这几个主要参数，n_cluster是聚类类别，init是中心点初始化方法，因为KMeans初值敏感所以需要迭代多次，</span></span><br><span class="line"><span class="comment"># n_init就是控制这个的参数，当数据是非凸集的时候max_iter的设置防止算法不收敛</span></span><br></pre></td></tr></table></figure></p><p>2.AP聚类算法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AffinityPropagation</span><br><span class="line">model = AffinityPropagation(affinity=<span class="string">'euclidean'</span>)</span><br><span class="line">model.fit(x, y)</span><br><span class="line">model.cluster_centers_indices_ <span class="comment"># 返回的是中心点的索引</span></span><br><span class="line">y_hat = model.labels_ <span class="comment">#返回的是预测的数据类别</span></span><br></pre></td></tr></table></figure></p><p>3.DBSCAN算法(<a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="noopener">参考1</a>,<a href="http://scikit-learn.org/stable/auto_examples/cluster/plot_dbscan.html#sphx-glr-auto-examples-cluster-plot-dbscan-py" target="_blank" rel="noopener">参考2</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">model = DBSCAN(eps=m, min_samples=n) <span class="comment"># eps对应算法的半径, min_samples对应算法在ε半径之内包含的最小点数，用来确定核心对象</span></span><br><span class="line">model.fit(x)</span><br><span class="line">y_hat = model.labels_ <span class="comment"># 预测类别值</span></span><br><span class="line">y_coresample = model.core_sample_indices_ <span class="comment"># 预测类别中心点</span></span><br><span class="line">n_clusters_ = len(set(y_hat)) - (<span class="number">1</span> <span class="keyword">if</span> <span class="number">-1</span> <span class="keyword">in</span> y_hat <span class="keyword">else</span> <span class="number">0</span>) <span class="comment"># 注意算法会把噪音点归为-1</span></span><br><span class="line"><span class="comment"># DBSCAN对数据本身没有分布要求，不像Kmeans假设数据是高斯分布的，DBSCAN产生的聚类形状可以不为类圆形</span></span><br><span class="line"><span class="comment"># 固定ε，min_samples越大越严格；固定min_samples，ε越小越严格</span></span><br><span class="line"><span class="comment"># DBSCAN通过计算每个数据点的高局部密度点距离和本身的密度确定每个点的类别，高局部密度点距离大密度大的点为聚类中心</span></span><br><span class="line"><span class="comment"># 高局部密度点距离大密度小的点为噪声，高局部密度点距离小密度大的点为普通点，高局部密度点距离小密度大的点不好判断</span></span><br><span class="line"><span class="comment"># ps:密度就是每个点ε邻域内的点数，高局部密度点距离就是比该点密度大的点中与之距离最小的距离</span></span><br></pre></td></tr></table></figure></p><p>4.MeanShift聚类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MeanShift</span><br><span class="line">model = MeanShift(bin_seeding=<span class="keyword">True</span>, bandwidth=band_width)</span><br><span class="line"><span class="comment"># 只需要给出圆的半径就好，圆的中心根据圆圈内包含的点的中心不断更新</span></span><br></pre></td></tr></table></figure></p><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>1.模型准确率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">print</span> <span class="string">'训练集准确率: %.5f'</span>%metrics.accuracy_score(y_train, y_train_hat) <span class="comment"># 先放真实值再放预测值，类型是ndarray</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'测试集准确率: %.5f'</span>%metrics.accuracy_score(y_test, y_test_hat) <span class="comment"># 先放真实值再放预测值，类型是ndarray</span></span><br><span class="line"><span class="comment"># 这里y_train和y_train_hat都是由0、1组成的</span></span><br></pre></td></tr></table></figure></p><p>2.模型的ROC、AUC<a href="https://blog.csdn.net/YE1215172385/article/details/79443552" target="_blank" rel="noopener">micro/macro</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">micro_AUC = metrics.roc_auc_score(y_true, y_probability, average=<span class="string">'micro'</span>)</span><br><span class="line">macro_AUC = metrics.roc_auc_score(y_true, y_probability, average=<span class="string">'macro'</span>)</span><br><span class="line">fpr, tpr, threshold = metrics.roc_curve(y_true.ravel(), y_probability.ravel())</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>), dpi=<span class="number">80</span>, facecolor=<span class="string">'w'</span>)</span><br><span class="line">plt(fpr, tpr, <span class="string">'r-'</span>, lw=<span class="number">2</span>, label=<span class="string">'AUC: %.5f'</span>%micro_AUC)</span><br><span class="line">plt.xlabel(<span class="string">'FPR'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'TPR'</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>))</span><br><span class="line">plt.yticks(np.arange(<span class="number">-0.1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>))</span><br><span class="line">plt.title(<span class="string">'ROC curve'</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">plt.grid(b=<span class="keyword">True</span>, ls=<span class="string">':'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">'lower right'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对上述评估标准进行说明，首先y_true和y_probability是一个n*m的ndarray对象，n是样本数，m是响应变量的类别数</span></span><br><span class="line"><span class="comment"># 其中y_true是对应多类别的真实值，每一行只有一个1其余为0，y_probability每一行是不同类别的预测概率</span></span><br><span class="line"><span class="comment"># 在计算AUC得分的时候，如果是多分类问题，有两种计算方式，第一种对每一列绘制ROC计算AUC，即对每一类别分别计算</span></span><br><span class="line"><span class="comment"># 另一种是将n*m的矩阵按行首尾连接，形成一个n*m长的array，对其绘制ROC同时计算AUC，这两种分别是macro和micro</span></span><br><span class="line"><span class="comment"># metrics.roc_curve是用来获得在不同theshold下得到的FPR和TPR的对应值，其中.ravel()方法用来展开数据，相当于按照micro的方法绘制</span></span><br></pre></td></tr></table></figure></p><p>3.模型的MSE(Mean square error)<a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=10814010" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算模型的均方误差</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">metrics.mean_squared_error(y_True, y_hat)</span><br></pre></td></tr></table></figure></p><p>4.模型的其他评估(Mean square error) <a href="https://blog.argcv.com/articles/1036.c" target="_blank" rel="noopener">参考</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score, f1_score, fbeta_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_fscore_support, classification_report</span><br><span class="line">fbeta = fbeta_score(y_true, y_hat, beta=beta)</span><br><span class="line">precision = precision_score(y_true, y_hat)</span><br><span class="line">recall = recall_score(y_true, y_hat)</span><br><span class="line">print(<span class="string">'f1 score: \t'</span>, f1_score(y_true, y_hat))</span><br><span class="line">fbeta = fbeta_score(y_true, y_hat, beta=beta)</span><br><span class="line"><span class="comment"># precision score = tp/(tp+fp)和准确度的区别在于只关注正类，准确率是所有类别都关注</span></span><br><span class="line"><span class="comment"># recal score = tp/(tp+fn)</span></span><br><span class="line"><span class="comment"># F1 = 2*(precision*recall)/(precision+recall) F1相当于P和R调和均值，越大模型效果越好</span></span><br><span class="line"><span class="comment"># fbeta_score是P和R的调和均值，beta&lt;1 precision的权重更大，beta&gt;1 recall的权重更大</span></span><br></pre></td></tr></table></figure></p><p>5.聚类方法的评估(<a href="https://blog.csdn.net/Mr_tyting/article/details/76719062" target="_blank" rel="noopener">方法解释</a><a href="https://blog.csdn.net/sinat_26917383/article/details/70577710" target="_blank" rel="noopener">参考1</a>, <a href="http://sklearn.apachecn.org/cn/0.19.0/modules/clustering.html" target="_blank" rel="noopener">参考2</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Homogeneity：'</span>, homogeneity_score(y, y_pred))</span><br><span class="line">print(<span class="string">'completeness：'</span>, completeness_score(y, y_pred))</span><br><span class="line">print(<span class="string">'V measure：'</span>, v_measure_score(y, y_pred))</span><br><span class="line">print(<span class="string">'AMI：'</span>, adjusted_mutual_info_score(y, y_pred))</span><br><span class="line">print(<span class="string">'ARI：'</span>, adjusted_rand_score(y, y_pred))</span><br><span class="line">print(<span class="string">'Silhouette：'</span>, silhouette_score(x, y_pred), <span class="string">'\n'</span>) <span class="comment"># 轮廓系数，1-类内距离/最小类外距离，1的时候最优，真实值也不一定是1..</span></span><br><span class="line"><span class="comment"># 聚类算法在真实的应用中一般难以获取真实的数据标签，除非手动区分，所以上述评估标准比较鸡肋，不深入解释</span></span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1.欧氏距离计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> euclidean_distances</span><br><span class="line">m = euclidean_distances(data, squared=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 返回一个n*n的矩阵计算的是亮亮之间的距离</span></span><br></pre></td></tr></table></figure></p><h2 id="Pipeline构建"><a href="#Pipeline构建" class="headerlink" title="Pipeline构建"></a>Pipeline构建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pipeline的使用是为了方便对数据处理的流程化，举个简单的example:特征变换+逻辑回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line">model = Pipeline([</span><br><span class="line">(<span class="string">'poly'</span>, PolynomialFeatures(degree = <span class="number">2</span>, include_bias = <span class="keyword">True</span>)),</span><br><span class="line">(<span class="string">'LR'</span>, LogisticRegressionCV(Cs = np.logspace(<span class="number">-3</span>, <span class="number">4</span>, <span class="number">8</span>), cv = <span class="number">5</span>, fit_intercept = <span class="keyword">False</span>))</span><br><span class="line">])</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'最优参数:  '</span>, model.get_params(<span class="string">'LR'</span>)[<span class="string">'LR'</span>].C_</span><br><span class="line"><span class="comment"># model包括两步，第一步对特征进行转换，第二步对转换好的特征进行逻辑回归模型构建</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lanchunhui/article/details/50521648" target="_blank" rel="noopener">Pipeline原理解析</a></p><h2 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> best_estimator_, RandomizedSearchCV    <span class="comment"># 0.17 grid_search</span></span><br><span class="line">model = svm.SVR(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">c_can = np.logspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">gamma_can = np.logspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">svr = GridSearchCV(model, param_grid=&#123;<span class="string">'C'</span>: c_can, <span class="string">'gamma'</span>: gamma_can&#125;, cv=<span class="number">5</span>)</span><br><span class="line">svr.fit(x, y)</span><br><span class="line">print(<span class="string">'验证参数：\n'</span>, svr.best_params_)</span><br><span class="line"><span class="comment"># cross validation交叉验证对应的参数</span></span><br><span class="line"><span class="comment"># best_params_对应model的参数，对于内部的参数通过best_params_之后再提取，比如svr中的support_</span></span><br></pre></td></tr></table></figure><h2 id="分类数据进行绘图"><a href="#分类数据进行绘图" class="headerlink" title="分类数据进行绘图"></a>分类数据进行绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.对于多分类数据进行划分区域，对坐标轴中的各个点进行预测，并对预测的点给与相应的颜色，例如对x1，x2进行绘图</span></span><br><span class="line">x1_min, x1_max = x1.min(), x1.max()</span><br><span class="line">x2_min, x2_max = x2.min(), x2.max()</span><br><span class="line">x1_array = np.arange(x1_min, x1_max, <span class="number">0.02</span>)</span><br><span class="line">x2_array = np.arange(x2_min, x2_max, <span class="number">0.02</span>)</span><br><span class="line">x1_tmp, x2_tmp = np.meshgrid(x1_array, x2_array)</span><br><span class="line">x_plot = np.stack((x1_tmp.flat, x2_tmp.flat), axis=<span class="number">1</span>) <span class="comment">#x_plot是一个列为2的数据，第一列是x轴值，第二列是y轴值</span></span><br><span class="line">y_meshgrid_hat = model.predict(x_plot)</span><br><span class="line">plt.scatter(x_plot[:,<span class="number">0</span>], x_plot[:,<span class="number">1</span>], c=y_meshgrid_hat, cmap = mpl.colors.ListedColormap([<span class="string">'#77E0A0'</span>, <span class="string">'#FF8080'</span>, <span class="string">'#A0A0FF'</span>]))</span><br><span class="line">plt.scatter(data.iloc[:,<span class="number">2</span>].values, data.iloc[:,<span class="number">3</span>].values, c=pd.Categorical(data.iloc[:,<span class="number">-1</span>]).codes, cmap = mpl.colors.ListedColormap([<span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>]))</span><br><span class="line"><span class="comment"># cmap参数是对应到不同的y_meshgrid_hat的值的颜色</span></span><br><span class="line">参考: http://sklearn.apachecn.org/cn/<span class="number">0.19</span><span class="number">.0</span>/auto_examples/linear_model/plot_iris_logistic.html<span class="comment">#sphx-glr-auto-examples-linear-model-plot-iris-logistic-py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的绘图方法</span></span><br><span class="line">x1, x2 = np.mgrid[x1_min:x1_max:<span class="number">500j</span>, x2_min:x2_max:<span class="number">500j</span>]</span><br><span class="line">cm_light = mpl.colors.ListedColormap([<span class="string">'#FF8080'</span>, <span class="string">'#80FF80'</span>, <span class="string">'#8080FF'</span>, <span class="string">'#F0F080'</span>])</span><br><span class="line">cm_dark = mpl.colors.ListedColormap([<span class="string">'r'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'y'</span>])</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span></span><br><span class="line">plt.figure(facecolor=<span class="string">'w'</span>)</span><br><span class="line">plt.pcolormesh(x1, x2, y_test, cmap=cm_light)</span><br><span class="line">plt.contour(x1, x2, y_test, levels=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), colors=<span class="string">'k'</span>, linestyles=<span class="string">'--'</span>)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], s=<span class="number">20</span>, c=y, cmap=cm_dark, edgecolors=<span class="string">'k'</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.xlabel(<span class="string">'$X_1$'</span>, fontsize=<span class="number">11</span>)</span><br><span class="line">plt.ylabel(<span class="string">'$X_2$'</span>, fontsize=<span class="number">11</span>)</span><br><span class="line">plt.xlim((x1_min, x1_max))</span><br><span class="line">plt.ylim((x2_min, x2_max))</span><br><span class="line">plt.grid(b=<span class="keyword">True</span>)</span><br><span class="line">plt.tight_layout(pad=<span class="number">2.5</span>)</span><br><span class="line">plt.title(<span class="string">'SVM多分类方法：One/One or One/Other'</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.单独做legend，不推荐，需要自己去看对应的类别，如果需要绘图上的调整还是用python吧</span></span><br><span class="line">patchs = [mpatches.Patch(color=<span class="string">'red'</span>, label=<span class="string">'Iris-setosa'</span>),</span><br><span class="line">          mpatches.Patch(color=<span class="string">'green'</span>, label=<span class="string">'Iris-versicolor'</span>),</span><br><span class="line">          mpatches.Patch(color=<span class="string">'blue'</span>, label=<span class="string">'Iris-virginica'</span>)]</span><br><span class="line">plt.legend(handles=patchs, fancybox=<span class="keyword">True</span>, framealpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.对预测值和真实值进行对比</span></span><br><span class="line">y_order = y_test.argsort()</span><br><span class="line">plt.plot(np.arange(len(y_order)), y_test[y_order], <span class="string">'g-'</span>, label=<span class="string">'True'</span>)</span><br><span class="line">plt.plot(np.arange(len(y_order)), y_test_hat[y_order], <span class="string">'r-'</span>, label=<span class="string">'Predicted'</span>)</span><br><span class="line"><span class="comment"># 分别绘制真实值和预测值，看两者的差别</span></span><br></pre></td></tr></table></figure><h2 id="模型保存"><a href="#模型保存" class="headerlink" title="模型保存"></a>模型保存</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'xxx.model'</span>):</span><br><span class="line">model = joblib.load(<span class="string">'xxx.model'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">joblib.dump(model, <span class="string">'xxx.model'</span>)</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li><p>对于使用sklearn过程中出现warning的情况，可以通过使用下列代码进行warning的隐藏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure></li><li><p>对于使用jupyter notbook的同学可以使用magic命令使得画图的时候直接显示图片代替 “matplotlib.pyplot.show()”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% matplotlib inline</span><br></pre></td></tr></table></figure></li></ol><h2 id="还有一些东西没来得及总计，有机会再补充"><a href="#还有一些东西没来得及总计，有机会再补充" class="headerlink" title="还有一些东西没来得及总计，有机会再补充"></a>还有一些东西没来得及总计，有机会再补充</h2><p>#####################   2018.8.2   ############################</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;机器学习算法的实践笔记&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./images/sklearn.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine learning" scheme="http://WenchaoXiu.github.io/categories/Machine-learning/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo command</title>
    <link href="http://WenchaoXiu.github.io/2018/07/12/firstblog_hexo/"/>
    <id>http://WenchaoXiu.github.io/2018/07/12/firstblog_hexo/</id>
    <published>2018-07-12T08:07:52.000Z</published>
    <updated>2018-07-13T06:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description">记录一下如何使用hexo进行博客撰写</p><a id="more"></a><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug -p 5000</span><br></pre></td></tr></table></figure><h2 id="网上更新"><a href="#网上更新" class="headerlink" title="网上更新"></a>网上更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post md_name</span><br></pre></td></tr></table></figure><p>更多<a href="http://moxfive.xyz/2015/12/21/common-hexo-commands/" target="_blank" rel="noopener">hexo命令</a><br>更多内容参见<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">blog</a><br>对于markdown的使用可以参考这篇<a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%B8%8B%E7%9A%84Markdown%E8%AF%AD%E6%B3%95%28GFM%29%E5%86%99%E5%8D%9A%E5%AE%A2.html" target="_blank" rel="noopener">blog</a></p><hr>]]></content>
    
    <summary type="html">
    
      hexo command
    
    </summary>
    
    
  </entry>
  
</feed>
