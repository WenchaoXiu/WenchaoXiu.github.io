<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ML, Python, R, Algorithms" />




  


  <link rel="alternate" href="/atom.xml" title="WenchaoXiu" type="application/atom+xml" />






<meta name="description" content="使用HIVE进行大体量数据的数据分析学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="HIVE命令学习">
<meta property="og:url" content="http://WenchaoXiu.github.io/2020/03/04/Hive-learning/index.html">
<meta property="og:site_name" content="WenchaoXiu">
<meta property="og:description" content="使用HIVE进行大体量数据的数据分析学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://wenchaoxiu.github.io/2020/03/04/Hive-learning/Hive架构.png">
<meta property="og:updated_time" content="2020-03-04T07:30:41.720Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HIVE命令学习">
<meta name="twitter:description" content="使用HIVE进行大体量数据的数据分析学习笔记">
<meta name="twitter:image" content="http://wenchaoxiu.github.io/2020/03/04/Hive-learning/Hive架构.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://WenchaoXiu.github.io/2020/03/04/Hive-learning/"/>





  <title>HIVE命令学习 | WenchaoXiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WenchaoXiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just try blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://WenchaoXiu.github.io/2020/03/04/Hive-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WenchaoXiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WenchaoXiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HIVE命令学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-04T14:03:49+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HIVE/" itemprop="url" rel="index">
                    <span itemprop="name">HIVE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  使用HIVE进行大体量数据的数据分析学习笔记
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description">该学习笔记主要基于b站尚硅谷中HIVE教程</p>

<!-- <img src="https://" alt="" style="width:100%" />
 -->
<a id="more"></a>
<h2 id="Hive简介"><a href="#Hive简介" class="headerlink" title="Hive简介"></a><font color="red">Hive简介</font></h2><h3 id="Hive基本概念"><a href="#Hive基本概念" class="headerlink" title="Hive基本概念"></a>Hive基本概念</h3><ol>
<li>Hive是一个分析框架，区别于Hadoop，Hadoop是存储及分析框架，存储对应分布式管理系统HDFS，分析框架是MapReduce。是一个基于Hadoop的<strong>数据仓库工具</strong>，将结构化的业务数据映射为一张表，提供类SQL查询功能。</li>
<li>本质是，将HQL转化为MapReduce程序，类似于Hadoop的一个客户端。<br> a. Hive处理的数据在HDFS中<br> b. 底层实现是MapReduce<br> c. 执行程序运行在Yarn上</li>
</ol>
<h3 id="Hive优缺点"><a href="#Hive优缺点" class="headerlink" title="Hive优缺点"></a>Hive优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>类SQL，简单，易上手</li>
<li>适用于大数据，小数据无优势，因为延迟高</li>
<li>可以自定义函数，扩展性好</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>延迟性比较高，实时性要求不高的场合，离线场景</li>
<li>迭代式计算无法表达，及多个MR（MapReduce）串联较难</li>
<li>数据挖掘方面不擅长，特指ML（Machine Learning）算法之类的</li>
<li>效率低，基于Hadoop来的</li>
</ol>
<h3 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h3><p>其中Meta store是存储相应的表与文件的相关信息的，包括文件大小，文件位置等等信息，存储在数据库中，默认是derby，后面可以换成MySQL。换句话说通过HQL语句转化为底层的MR语句，查询的原数据存在HDFS，元数据(meta data)处于数据库中。</p>
<div style="width: 300px; margin: auto"><img src="Hive架构.png" alt="Hive架构"></div>


<h3 id="Hive与数据库的比较"><a href="#Hive与数据库的比较" class="headerlink" title="Hive与数据库的比较"></a>Hive与数据库的比较</h3><ol>
<li><strong>查询语言</strong>：类似</li>
<li><strong>存储位置</strong>：Hive是Hadoop的HDFS中的，SQL是存储在本地中的。</li>
<li><strong>数据更新</strong>：SQL数据库需要经常修改，而Hive则<em>读多写少</em></li>
<li><strong>索引</strong>：Hive没有索引，因为数据比较大，建索引意义不大，不适合在线数据查询</li>
<li><strong>执行</strong>：Hive通过MR实现的，而数据库有自己的执行引擎</li>
<li><strong>执行延迟</strong>：Hive由于没有索引需要扫描表，延迟高，启动慢</li>
<li><strong>可扩展性</strong>：Hive基于Hadoop，所以存储扩展和计算扩展都较高，MySQL也可扩展，但是相对来说扩展能力有限，最大100台</li>
<li><strong>数据规模</strong>：相比较于MySQL来说可以支持很大规模的数据</li>
</ol>
<h2 id="Hive安装与配置"><a href="#Hive安装与配置" class="headerlink" title="Hive安装与配置"></a><font color="red">Hive安装与配置</font></h2><h3 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h3><ol>
<li><a href="http://hive.apache.org/" target="_blank" rel="noopener"><strong>官网地址</strong></a></li>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted" target="_blank" rel="noopener"><strong>文档查看</strong></a></li>
<li><a href="http://archive.apache.org/dist/hive/" target="_blank" rel="noopener"><strong>下载地址</strong></a></li>
<li><strong>基本操作</strong><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> # 展示数据库，显示有一个<span class="keyword">default</span>数据库</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">default</span> # 使用<span class="keyword">default</span>数据库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="keyword">string</span>) # 建表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> # 有student表</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student # 查询</span><br><span class="line">insert into table student values(1，'banzhang'); # 插值</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件系统中导入Hive案例"><a href="#文件系统中导入Hive案例" class="headerlink" title="文件系统中导入Hive案例"></a>文件系统中导入Hive案例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table student(id int,name string) row format delimited fields terminated by '\t'; # 注意基于文件插入内容时，需要在建表的时候指定文件行分隔符，否则依据文件插入内容是会有问题</span><br><span class="line"></span><br><span class="line">load data local inpath 'xxx' into table student; # 将xxx文件导入到student表中，如果在HDFS上，则去掉local，非本地加载。其实load本质就是hadoop里面的put</span><br><span class="line"># hadoop fs -put stu1.txt xxx # 如果表中缺少数据，需要额外加入，可以使用hadoop进行put，select * 一样可以读进来</span><br><span class="line">quit; # 退出Hive</span><br></pre></td></tr></table></figure>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>由于只能打开一个Hive（derby），因此需要安装MySQL，使用MySQL的Metastore，保证打开多个Hive</p>
<ol>
<li>将mysql中连接的jar包复制到hive/lib下</li>
<li>修改配置，包括同其他设备的连接，包括打印表名等设置</li>
</ol>
<h3 id="Hive交互命令"><a href="#Hive交互命令" class="headerlink" title="Hive交互命令"></a>Hive交互命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/hive -<span class="keyword">help</span> # 查看命令，主要有两个参数，-e，-f，前者是命令行，后者是文件</span><br><span class="line"><span class="keyword">bin</span>/hive -e <span class="string">"select * from aa;"</span> # 可以直接不进入Hive进行结果返回</span><br><span class="line"><span class="keyword">bin</span>/hive -f xx.hql &gt; xx.hql.result.txt # 将xx.hql命令中的结果写到xx.hql.result.txt中</span><br></pre></td></tr></table></figure>
<h3 id="Hive其他命令"><a href="#Hive其他命令" class="headerlink" title="Hive其他命令"></a>Hive其他命令</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/hive # 启动hive</span><br><span class="line">dfs -ls /; # 查看hdfs里面文件内容</span><br><span class="line">! ls ./ # 本地文件内容</span><br></pre></td></tr></table></figure>
<font color="red">注：由于Hadoop没怎么接触过，有一些配置没太搞懂，后续需要重新学习</font>

<h2 id="Hive-数据类型"><a href="#Hive-数据类型" class="headerlink" title="Hive 数据类型"></a><font color="red">Hive 数据类型</font></h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol>
<li>常用的有INT，BIGINT，DOUBLE，STRING，分别对应于java中int，long，double，string，大小写没关系，其中string理论上可以存到2G的数据</li>
</ol>
<h3 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a>集合数据类型</h3><ol>
<li>STRUCT，类似于c语言中的struct，可以通过”点”来访问，.first这种</li>
<li>MAP，是键值对元组集合</li>
<li>ARRAY，数组类型</li>
</ol>
<p><strong>注：比较少用，一般会使用自定义函数进行拆分，形成扁平化的数据。Hive只能识别一行一行的数据，JSON之类的格式是无法识别的。</strong></p>
<p><em>一个例子</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件中的一行内容：</span></span><br><span class="line"><span class="comment"># songsong,bingbing_lili,xiao # song:18_xiaoxiao song:19,hui long guan_beijing </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建表命令</span></span><br><span class="line"><span class="comment"># 注意不同内容间间隔符要一致，例如：无论array还是map还是struct中多个元素都由'_'分割，因为都是集合类型。如不一致，会有问题，所以需要提前处理文件，保证文件后面读入较为顺利。</span></span><br><span class="line">create table <span class="built_in">test</span>(</span><br><span class="line">name string,</span><br><span class="line">friends array&lt;string&gt;,</span><br><span class="line">children map&lt;string, int&gt;</span><br><span class="line">address struct&lt;street:string, city:string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by <span class="string">','</span></span><br><span class="line">collection items teminated by<span class="string">'_'</span></span><br><span class="line">map keys terminated by <span class="string">':'</span></span><br><span class="line">lines terminated by <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件内容载入表中</span></span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">'xxx'</span> into table <span class="built_in">test</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问集合元素</span></span><br><span class="line">select friends[1] from <span class="built_in">test</span>; <span class="comment"># 访问friends列第二个元素</span></span><br><span class="line">select children[<span class="string">'xiaosong'</span>] from <span class="built_in">test</span>; <span class="comment"># 查看children列中xiaosong对应的value，与array的区别在于，array使用数字角标，map使用key值</span></span><br><span class="line">select address.city from <span class="built_in">test</span> <span class="comment"># struct访问方式使用 "."+属性名</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><ol>
<li>隐式类型转换<br> a. TINYINT -&gt; INT; INT -&gt; BIGINT<br> b. 整数类型、FLOAT、STRING -&gt; DOUBLE，注意STRING必须要是数值类型的<br> c. 整形除BIGINT -&gt; FLOAT<br> d. BOOLEAN不可转其他类型</li>
<li>强转<br> a. cast(‘1’ as int)，得到int类型1<br> b. cast(‘x’ as int)，无法强转会失败，失败之后返回空值NULL</li>
</ol>
<h2 id="DDL数据定义"><a href="#DDL数据定义" class="headerlink" title="DDL数据定义"></a><font color="red">DDL数据定义</font></h2><p><strong>Data Definition Language 数据定义语言，主要包括创建、修改、删除行为</strong></p>
<h3 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h3><h4 id="数据库的增"><a href="#数据库的增" class="headerlink" title="数据库的增"></a>数据库的增</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database hive; <span class="comment"># 创建数据库，其中hive也可以写成 库名.表名 这种形式，表示在库名下建某个表名</span></span><br><span class="line">create database <span class="keyword">if</span> not exists hive; <span class="comment"># 创建数据库，需要判断是否已经有该数据库了</span></span><br><span class="line">create database hive2 location <span class="string">'/hive2'</span> <span class="comment"># 在根目录下建一个hive2的数据库，之后建的表在/hive2文件夹中，文件名和库名可以不一样，不一样的时候默认是default</span></span><br><span class="line">use hive; <span class="comment"># 使用该数据库</span></span><br><span class="line">create table <span class="built_in">test</span>(id int) <span class="comment"># 在hive库中建test表，其中有一个字段叫做id类型是int型</span></span><br></pre></td></tr></table></figure>
<h4 id="数据库的删"><a href="#数据库的删" class="headerlink" title="数据库的删"></a>数据库的删</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop database hive; <span class="comment"># 将空数据库hive删除</span></span><br><span class="line">drop database hive cascade; <span class="comment"># 当hive库中存在表的时候，上条命令无法直接删除，需要加cascade进行强删</span></span><br></pre></td></tr></table></figure>
<h4 id="数据库的改"><a href="#数据库的改" class="headerlink" title="数据库的改"></a>数据库的改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database hive <span class="built_in">set</span> dbproperties(<span class="string">'createtime'</span>=<span class="string">'20200228'</span>) <span class="comment"># 注意，所谓对数据库的改动，是对数据库以key-value对加一些属性，但无法改变相应的数据库名称、数据库位置</span></span><br></pre></td></tr></table></figure>
<h4 id="数据库的查"><a href="#数据库的查" class="headerlink" title="数据库的查"></a>数据库的查</h4><ol>
<li><p>查数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show databases; <span class="comment"># 打印存在数据库</span></span><br><span class="line">show databases like <span class="string">'hive*'</span>; <span class="comment"># 模糊查询，前缀为hive的数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查数据库详情</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desc database hive; <span class="comment"># 显示数据库的信息，包括名称、位置、所有者之类的</span></span><br><span class="line">desc database extended hive; <span class="comment"># 显示数据库的信息，扩展信息，后续加入的信息可以查看</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="表的增删改查"><a href="#表的增删改查" class="headerlink" title="表的增删改查"></a>表的增删改查</h3><p>表内容的查询命令较为复杂，因此后面章节再讲。</p>
<h4 id="创建普通表"><a href="#创建普通表" class="headerlink" title="创建普通表"></a>创建普通表</h4><ol>
<li><p>基本语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[COMMENT table_comment] </span><br><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[CLUSTERED BY (col_name, col_name, ...) </span><br><span class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] </span><br><span class="line">[ROW FORMAT row_format] </span><br><span class="line">[STORED AS file_format] </span><br><span class="line">[LOCATION hdfs_path]</span><br><span class="line"><span class="comment"># EXTERNAL表明创建的表为外部表与之相对的为管理表</span></span><br><span class="line"><span class="comment"># 其中COMMENT为添加注释信息</span></span><br><span class="line"><span class="comment"># PARTITIONED为分区，将一套数据分成多个文件夹</span></span><br><span class="line"><span class="comment"># CLUSTERED为分桶，将一套数据分成多个文件</span></span><br><span class="line"><span class="comment"># ROW FORMAT对文件格式进行限制</span></span><br><span class="line"><span class="comment"># LOCATION为库存储位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>管理表（内部表）、外部表区别<br>内部表与外部表是通过建表时是否有EXTERNAL决定的，两者的区别：内部表认为原始数据是内部管理的，外部表则不是。翻译成人话，删除内部表的时候meta data与original data全部删除，外部表，只删除meta data。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop database hive; <span class="comment"># 删除表</span></span><br><span class="line">show tables; <span class="comment"># 此时无论外部表还是内部表，删除的表信息都没了，但是此时外部表源数据还在。当重新构建外部表的时候，使用select * from xxx是可以看见删表之前的数据的（原因：整体的流程是先从meta data中寻找源数据信息，再去源数据中调，源数据与元数据创建先后无关）。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show tables; <span class="comment"># 展示表</span></span><br><span class="line">show create table cc; <span class="comment"># 展示表cc中详细信息</span></span><br></pre></td></tr></table></figure>
<p><strong>注：临时表可以建成内部表，其他表一般建成外部表较为安全，防止删库跑路。</strong></p>
<ol start="3">
<li>内部表外部表转换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desc formatted dept; <span class="comment"># 查看dept表的详细信息，其中有表的类型信息，属于内部表还是外部表</span></span><br><span class="line">alter table dept <span class="built_in">set</span> tblproperties(<span class="string">'EXTERNAL'</span>=<span class="string">'TRUE'</span>); <span class="comment"># 将manage table变成外部表，注意'EXTERNAL'='TRUE'是区分大小写的!!!如果小写，相当于加了一个属性，即external=true属性</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h4><ol>
<li><p>分区表含义及作用<br>分区表实际就是HDFS系统上的一个独立文件夹，正常一个表是一个文件夹，但是分区表之下还有一个文件夹存储着不同的基于该表的分割表。分区表的作用是为了加速操作，例如：以时间进行分区，如果select某字段的时候局限在某个时间点，可以只在该分区下进行搜索，不必整张表搜索。通过where关键词进行筛选，称作谓词下推，执行的时候先from找表，再where过滤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分区表</span></span><br><span class="line">create table dept_partition(no int, name string, loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (month string)</span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">'xxx1'</span> into table dept partition(month=<span class="string">'202001'</span>)<span class="comment"># 对该条数据加载，并指定分区为202001。实际产生了一个为month=202001的文件夹，里面存储了加载的数据。</span></span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">'xxx2'</span> into table dept partition(month=<span class="string">'202002'</span>) <span class="comment"># 同上</span></span><br><span class="line">select * from dept_partition; <span class="comment"># 上述两个分区的数据都会显示，其中month会作为一个列存在。注意需要和sql中的index区分，index是存在表中的信息，HIVE是以文件夹进行存储的。</span></span><br><span class="line">select * from dept_partition <span class="built_in">where</span> month=<span class="string">'202001'</span> <span class="comment"># 只显示分区信息为202001的数据，换句话说只扫描了month=202001文件夹</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加分区表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition add partition(month=<span class="string">'2020-03'</span>) partition(month=<span class="string">'2020-04'</span>) <span class="comment"># 可以添加多个分区，实际上就是在dept_partition库所在文件夹中添加多个文件夹。mack repair table dept_partition 多文件恢复 partition(month='2020-04') # 可以添加多个分区，实际上就是在dept_partition库所在文件夹中添加多个文件夹。mack repair table dept_partition 多文件恢复c partition(month='2020-04') # 可以添加多个分区，实际上就是在dept_partition库所在文件夹中添加多个文件夹。mack repair table dept_partition 多文件恢复 partition(month='2020-04') # 可以添加多个分区，实际上就是在dept_partition库所在文件夹中添加多个文件夹。mack repair table dept_partition 多文件恢复c。</span></span><br><span class="line">hadoop fs -put file xxx/month=2020-03 <span class="comment"># 将文件放在分区文件夹之后，可以使用select访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition drop partition(month=<span class="string">'2020-03'</span>) <span class="comment"># 删除分区</span></span><br><span class="line">alter table dept_partition drop partition(month=<span class="string">'2020-03'</span>),partition(month=<span class="string">'2020-04'</span>) <span class="comment"># 删除多个分区需要逗号隔开，区别于添加时的空格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show partitions dept_partition; <span class="comment"># 查看分区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建二级分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其实就是多加一个字段，相当于多加一层文件夹</span></span><br><span class="line">create table dept_partition(no int, name string,loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (month string, day string)</span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span>;</span><br><span class="line"><span class="comment"># 过滤数据</span></span><br><span class="line">select * from dept_partition <span class="built_in">where</span> month=<span class="string">'2020-07'</span> and day=<span class="string">'01'</span> <span class="comment"># 二级分区的过滤</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h4><ol>
<li><p>重命名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table old rename to new; <span class="comment"># 将表名old修改为new</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加删除分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition add partition(month=<span class="string">'2020-03'</span>) <span class="comment"># 增加分区</span></span><br><span class="line">alter table dept_partition drop partition(month=<span class="string">'2020-03'</span>) <span class="comment"># 删除分区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加、修改、替换列名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add 和 replace 可以多个</span></span><br><span class="line">alter table <span class="built_in">test</span> add columns (name string);</span><br><span class="line"><span class="comment"># change 只能改一个</span></span><br><span class="line">alter table <span class="built_in">test</span> change column name sex string; <span class="comment"># 将name列改成sex，类型必须写上去。名称和类型可以与之前相同也可不同</span></span><br><span class="line"><span class="comment"># replace是对所有列名都修改</span></span><br><span class="line">alter table <span class="built_in">test</span> replace columns (a int); <span class="comment"># 换句话说，无论之前有多少列，现在都改成一列a类型为int，原数据不变，元数据变化。如果只有一列，那么只读原数据的第一列，类型和原数据不匹配返回NULL。</span></span><br><span class="line">desc <span class="built_in">test</span>; <span class="comment"># 查看表结构</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
<h2 id="DML数据操作"><a href="#DML数据操作" class="headerlink" title="DML数据操作"></a><font color="red">DML数据操作</font></h2><p><strong>Data Manipulation Language 数据操作语言，主要包括select，update，insert，delete等</strong></p>
<h3 id="数据的导入"><a href="#数据的导入" class="headerlink" title="数据的导入"></a>数据的导入</h3><ol>
<li><p>load数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data [<span class="built_in">local</span>] inpath <span class="string">'/opt/module/datas/student.txt'</span> [overwrite] into table student [partition (partcol1=val1,…)]; <span class="comment"># local是本地导入，如果不写，远端HDFS导入；overwrite是覆盖，直接into是追加；partition是追加分区，追加的内容是写在表中靠上的位置的。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>insert数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建表</span></span><br><span class="line">create table student (id int, name string) partitioned by (month string) row format delimited fields terminated by <span class="string">'\t'</span>;</span><br><span class="line"><span class="comment"># 基本插入</span></span><br><span class="line">insert into table student partition(month=<span class="string">'202002'</span>) values(1, <span class="string">'zhangsan'</span>) <span class="comment"># 会走MR</span></span><br><span class="line"><span class="comment"># 查询插入</span></span><br><span class="line">insert into table student</span><br><span class="line">select id from <span class="built_in">test</span>; <span class="comment"># 将test的id插入到student表中</span></span><br><span class="line">insert overwrite table student</span><br><span class="line">select id from <span class="built_in">test</span>; <span class="comment"># 将test的id插入到student表中，注意会覆盖！与load区分，没有into</span></span><br><span class="line"><span class="comment"># 创建表基于select插入数据</span></span><br><span class="line">create table test1</span><br><span class="line">as select id from <span class="built_in">test</span>; <span class="comment"># 1.创建表；2.在表中加入select筛选出来的数据</span></span><br><span class="line"><span class="comment"># 创建表基于location插入数据</span></span><br><span class="line">create table test2(id int, name string)</span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span></span><br><span class="line">location <span class="string">'xxx'</span> <span class="comment"># 其中xxx文文件路径</span></span><br><span class="line"><span class="comment"># import数据到指定表中</span></span><br><span class="line">import table <span class="built_in">test</span> partition(month=<span class="string">'202002'</span>) from <span class="string">'xxx'</span> <span class="comment"># 注意xxx一定要是export导出路径，随便一个文件是不行的，要使用load</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数据的导出"><a href="#数据的导出" class="headerlink" title="数据的导出"></a>数据的导出</h3><ol>
<li><p>insert 导出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询结果格式化导出到本地/HDFS</span></span><br><span class="line">insert overwrite <span class="built_in">local</span> directory <span class="string">'xxx'</span></span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span></span><br><span class="line">select * from student<span class="comment"># 结果导入本地,导入HDFS去掉local，不要忘记分隔符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HIVE SHELL命令导出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/hive -e <span class="string">'select * from test'</span> &gt; xxx.txt <span class="comment"># 将test表中数据导出到xxx.txt文件</span></span><br><span class="line">bin/hive -f <span class="string">'...'</span> &gt; xxx.txt <span class="comment"># 执行脚本进行文件内容的导出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>export 导出到HDFS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> table <span class="built_in">test</span> to <span class="string">'xxx'</span> <span class="comment"># 将test表导出到xxx路径，相当于copy，导出了元数据和原数据</span></span><br><span class="line">import table <span class="built_in">test</span> from <span class="string">'xxx'</span> <span class="comment"># 配合之前export导出结果使用，表格式必须要是数据空的，或者test不存在</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>清除数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table <span class="built_in">test</span>; <span class="comment"># 将原数据删除，保留元数据即表结构，因此只能操作内部表（管理表）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据表查询"><a href="#数据表查询" class="headerlink" title="数据表查询"></a><font color="red">数据表查询</font></h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><h4 id="全表及特定列查询"><a href="#全表及特定列查询" class="headerlink" title="全表及特定列查询"></a>全表及特定列查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询全表</span></span><br><span class="line">select * from <span class="built_in">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定列查询</span></span><br><span class="line">select id,name from <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
<p><strong>规则：</strong><br><strong>1. 大小写不敏感</strong><br><strong>2. 可以一行也可多行</strong><br><strong>3. 关键字不能缩写不能分行</strong><br><strong>4. 字句一般分行写</strong><br><strong>5. 分号表明语句结束</strong></p>
<h4 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ename as name, dbid id from <span class="built_in">test</span>; <span class="comment"># 查询结果的列名改成需要的名字，as可加可不加</span></span><br></pre></td></tr></table></figure>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>运算符：+ - * / % &amp;  | ^ ~<br>分别是：加/减/乘/除，取余，按位与/或/异或/非<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id+1 from <span class="built_in">test</span>; <span class="comment">#加操作</span></span><br></pre></td></tr></table></figure></p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select count(*) cnt from <span class="built_in">test</span>; <span class="comment"># 查看数量</span></span><br><span class="line">select max(salary) maxsal from <span class="built_in">test</span>; <span class="comment"># 查看最大值</span></span><br><span class="line">select min(salary) minsal from <span class="built_in">test</span>; <span class="comment"># 查看最小值</span></span><br><span class="line">select sum(salary) sumsal from <span class="built_in">test</span>; <span class="comment"># 查看总和</span></span><br><span class="line">select avg(salary) avgsal from <span class="built_in">test</span>; <span class="comment"># 查看平均值</span></span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">limit</span> 5; <span class="comment"># 对查询结果只返回5条</span></span><br></pre></td></tr></table></figure>
<p><strong>注：会触发MR任务</strong></p>
<h3 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h3><ol>
<li>基本where<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> sal&gt;1000; <span class="comment"># 过滤</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=b <span class="comment"># 相等，ab中有一个为null都返回null；select null='a'会返回null</span></span><br><span class="line">a&lt;=&gt;b <span class="comment"># 大部分时和=一样，当两个都为null时，返回true，一个为null返回false</span></span><br><span class="line">a!=b <span class="comment"># 不等</span></span><br><span class="line">a&lt;b,a&lt;=b,a&gt;b,a&gt;=b; <span class="comment"># 同=符号，其中有一个为null返回null</span></span><br><span class="line">a [not] between b and c; <span class="comment"># 区间内，加not就是非区间内。eg:select 'b' between 'a' and 'c'，返回true。注意between是左右都闭的区间。</span></span><br><span class="line">a is [not] null <span class="comment"># 判断a是否为null</span></span><br><span class="line"><span class="keyword">in</span> <span class="comment">#查看是不是在一个集合里面，eg:select 'a' in ('a','b')返回true</span></span><br></pre></td></tr></table></figure>
<h4 id="Like和RLike比较运算符"><a href="#Like和RLike比较运算符" class="headerlink" title="Like和RLike比较运算符"></a>Like和RLike比较运算符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _ % 分别匹配单个字符和多个字符</span></span><br><span class="line">select <span class="string">'a'</span> like <span class="string">'a_'</span> <span class="comment"># 返回false，因为_为占位符必须对应一个字符</span></span><br><span class="line">select <span class="string">'a'</span> like <span class="string">'a%'</span> <span class="comment"># 返回ture，因为是多个字符</span></span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> sal RLIKE <span class="string">'[2]'</span>; <span class="comment"># RLIKE是java中的正则表达式，这句话是说匹配sal字段中包含2的那些</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>包含and or not<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> sal&gt;100 and sal&lt;1000; <span class="comment"># 使用and</span></span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> sal&gt;1000 or id&lt;300; <span class="comment"># 使用and</span></span><br><span class="line">select * from <span class="built_in">test</span> <span class="built_in">where</span> id not IN(20, 30); <span class="comment"># 使用and</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="group-by函数"><a href="#group-by函数" class="headerlink" title="group by函数"></a>group by函数</h4><p>group by，一般和聚合函数使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select t.id, avg(t.sal) avg_sal from <span class="built_in">test</span> t group by t.id <span class="comment"># 查询某个部门id的平均工资</span></span><br><span class="line">select t.id, t.job, avg(t.sal) avg_sal from <span class="built_in">test</span> t group by t.id,t.job <span class="comment"># 查询某个部门id某种工作的的平均工资，可groupby多个</span></span><br></pre></td></tr></table></figure></p>
<h4 id="having函数"><a href="#having函数" class="headerlink" title="having函数"></a>having函数</h4><p>having和group by的区别：having与group by公用；where后面不能接分组函数，having可以；where针对表中列起作用，having针对查询结果中的列起作用，换句话说where是先筛选，having是对group by之后的结果筛选<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id, avg(sal) avg_sal from <span class="built_in">test</span> group by id; <span class="comment"># 查看不同部门id的平均薪水</span></span><br><span class="line">select id, avg(sal) avg_sal from <span class="built_in">test</span> group by id having avg_sal&gt;2000; <span class="comment"># 查看平均薪资大于2000的部门</span></span><br></pre></td></tr></table></figure></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="join两表连接"><a href="#join两表连接" class="headerlink" title="join两表连接"></a>join两表连接</h4><pre><code>a. 只支持等值连接，非等值连接不支持(!= &gt; &lt; &gt;= &lt;=等)
b. 表名可以简化，简化的一个好处是提高效率，因为写明之后直接可以定位到相应的表上，多表连接的时候尤其有用
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select t1.id, t1.name from test1 t1 join test2 t2 on t1.id=t2.id; <span class="comment"># 将两个表按照id进行join，内连接。</span></span><br><span class="line">select t1.id, t1.name from test1 t1 left join test2 t2 on t1.id=t2.id; <span class="comment"># 将两个表按照id进行join，左连接。</span></span><br><span class="line">select t1.id, t1.name from test1 t1 right join test2 t2 on t1.id=t2.id; <span class="comment"># 将两个表按照id进行join，右连接。</span></span><br><span class="line">select t1.id, t1.name from test1 t1 full join test2 t2 on t1.id=t2.id; <span class="comment"># 将两个表按照id进行join，全外连接。</span></span><br><span class="line">select eid, dname from emp,dept; <span class="comment"># 返回所有eid和dname的排列组合。当不给定连接条件的时候，数据表之间会进行笛卡尔积操作，即两表数据条目数相乘，当表中数据量比较大的时候相当危险。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不支持or连接，会报错</span></span><br><span class="line">select e.no, e.name, d.no </span><br><span class="line">from emp e </span><br><span class="line">join dept d on e.no=d.no or e.name=d.name;</span><br></pre></td></tr></table></figure>
<h4 id="join多表连接"><a href="#join多表连接" class="headerlink" title="join多表连接"></a>join多表连接</h4><p>连接n个表至少需要n-1个连接条件<br>A join B on … join C on …<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.name, d.deptno, l.locname</span><br><span class="line">from emp e</span><br><span class="line">join dept d on d.deptno=e.deptno</span><br><span class="line">join location l on d.loc=l.loc;<span class="comment"># 注意先启动1个MR对d、e表进行连接，再启动一个MR对d、l连接，原因是HIVE总是按照从左至右顺序执行的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="全局排序"><a href="#全局排序" class="headerlink" title="全局排序"></a>全局排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by sal asc; <span class="comment"># 按工资排序，默认升序</span></span><br><span class="line">select * from emp order by sal desc; <span class="comment"># 按工资排序，降序排列</span></span><br><span class="line"><span class="comment"># 当出现order by的时候只有一个reducer</span></span><br></pre></td></tr></table></figure>
<h4 id="按照别名排序"><a href="#按照别名排序" class="headerlink" title="按照别名排序"></a>按照别名排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ename, sal*2 twosal from emp order by twosal; <span class="comment"># 薪水两倍排序</span></span><br></pre></td></tr></table></figure>
<h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, name from <span class="built_in">test</span> order by id, sal; <span class="comment"># 先按id排序，再按sal排序</span></span><br></pre></td></tr></table></figure>
<p> sort by排序<br>sort by只能对每个reducer进行排序，不是全局哦<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces=3; <span class="comment"># 设置</span></span><br><span class="line">select * from <span class="built_in">test</span> sort by id desc; <span class="comment"># 结果不太明朗</span></span><br><span class="line">insert overwrite <span class="built_in">local</span> directory <span class="string">'xxx'</span></span><br><span class="line">select * from <span class="built_in">test</span> sort by id desc; <span class="comment"># 写入文件，注意分3个文件，因为mapreduce之前设置了三个，每个文件中id都是降序的，但是id并不区分</span></span><br></pre></td></tr></table></figure></p>
<h4 id="分区排序"><a href="#分区排序" class="headerlink" title="分区排序"></a>分区排序</h4><p>结合sort by使用，用于sort by之前<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> mapreduce.job.reduces=3; <span class="comment"># 一定要分配多reduce</span></span><br><span class="line">insert overwrite <span class="built_in">local</span> directory <span class="string">'xxx'</span></span><br><span class="line">select * from emp distribute by deptno</span><br><span class="line">sort by empno desc; <span class="comment"># 基于deptno分区排序，并基于empno排序。写入文件夹中有三个文件，不同deptno分布在不同文件，文件内部按照empno降序</span></span><br></pre></td></tr></table></figure></p>
<h4 id="cluster-by"><a href="#cluster-by" class="headerlink" title="cluster by"></a>cluster by</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面两条命令是一样的，相当于是分成多个分区，每个分区内部都按照deptno排序</span></span><br><span class="line"><span class="comment"># 注意：cluster by只能按升序排序，不能降序</span></span><br><span class="line">select * from emp cluster by deptno; </span><br><span class="line">select * from emp distribute by deptno sort by deptno;</span><br></pre></td></tr></table></figure>
<p><strong>注：当reducer是n个，但是distribute by的列名种类数大于n个时，会随机分配到n个文件中</strong></p>
<h3 id="分桶及抽样查询"><a href="#分桶及抽样查询" class="headerlink" title="分桶及抽样查询"></a>分桶及抽样查询</h3><p>分区和分桶，分区是放在不同的文件夹中，分桶是在同一个文件夹中多个文件，distribute by类似于分桶<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分区字段是新的，分桶字段是表中有的字段</span></span><br><span class="line"><span class="comment"># 分桶建表</span></span><br><span class="line">create table stu buck(id int, name string)</span><br><span class="line">clustered by(id) into 4 buckets</span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span> <span class="comment"># 注意load和insert都没办法建立分桶效果，因为load是put一个文件，不可能分多份put</span></span><br><span class="line"></span><br><span class="line">create table stu(id int, name string)</span><br><span class="line">row format delimited fields terminated by <span class="string">'\t'</span>;</span><br><span class="line">load data <span class="built_in">local</span> inpath <span class="string">'/opt/module/datas/student.txt'</span> into table stu; <span class="comment"># 文件内容放到一个普通表</span></span><br><span class="line"><span class="built_in">set</span> hive.enforce.bucketing=<span class="literal">true</span>; <span class="comment"># 设置开启分桶</span></span><br><span class="line"><span class="built_in">set</span> mapreduce.job.reduces=-1;</span><br><span class="line">insert into table stu_buck</span><br><span class="line">select id, name from stu; <span class="comment"># stu是之前的一个普通表，从文件中读取的</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注：一个小窍门，对于查询的都不带ed，对于建表之类的需要带ed。比如：建分桶表clustered，数据排序查询使用cluster，再如partitioned by</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tablesample(bucket x out of y on id)</span></span><br><span class="line"><span class="comment"># 注意x&lt;y，其含义是从x开始抽（从1开始），一共抽z/y个，z为设定的表的桶数</span></span><br><span class="line">select * from stu_buck tablesample(bucket 1 out of 4 on id); <span class="comment"># 分桶抽样</span></span><br></pre></td></tr></table></figure></p>
<h3 id="其他常用查询函数"><a href="#其他常用查询函数" class="headerlink" title="其他常用查询函数"></a>其他常用查询函数</h3><h4 id="空字段赋值"><a href="#空字段赋值" class="headerlink" title="空字段赋值"></a>空字段赋值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select nvl(sal, -1) from emp; <span class="comment"># 查询emp表中的sal这列，如果值为NULL，则赋值为-1</span></span><br><span class="line">select nvl(sal, id) from emp; <span class="comment"># 查询emp表中的sal这列，如果值为NULL，可以使用id类替代</span></span><br></pre></td></tr></table></figure>
<h4 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化时间</span></span><br><span class="line">select date_format(<span class="string">'1987-5-23'</span>, <span class="string">'yyyy-MM'</span>) <span class="comment"># 返回对应年月</span></span><br><span class="line">select date_format(<span class="string">'1987-5-23'</span>, <span class="string">'yyyy-MM-dd HH:mm:ss'</span>) <span class="comment"># 返回对应年月日，时分秒</span></span><br><span class="line">select date_format(<span class="string">'1987-5-23'</span>, <span class="string">'yyyy-MM'</span>)&lt;<span class="string">'2020-01'</span> <span class="comment"># 年月可以比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间和天数相加</span></span><br><span class="line">select date_add(<span class="string">'2020-02-29'</span>, 5) <span class="comment"># 返回2020-03-05，相当于对当前时间进行后推</span></span><br><span class="line">select date_add(<span class="string">'2020-02-29'</span>, -5) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间和天数相减</span></span><br><span class="line">select date_sub(<span class="string">'2020-02-29'</span>, 5) <span class="comment"># 和上面记一个就行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两时间相减</span></span><br><span class="line">select datediff(<span class="string">'2020-02-29'</span>, <span class="string">'2020-02-27'</span>)</span><br><span class="line"></span><br><span class="line">select regexp_replace(<span class="string">'2020/02/15'</span>,<span class="string">'/'</span>,<span class="string">'-'</span>) <span class="comment"># 字符替换，将/进行替换</span></span><br></pre></td></tr></table></figure>
<p><strong>注：date_format, date_add, date_sub, datediff都只认以-分割的时间格式，需要regexp_replace替换</strong></p>
<h4 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看emp表中按deptid分组后，各组男女数目</span></span><br><span class="line">select deptid,</span><br><span class="line">sum(<span class="keyword">case</span> sex when <span class="string">'男'</span> <span class="keyword">then</span> 1 <span class="keyword">else</span> 0 end) male_cnt,</span><br><span class="line">sum(<span class="keyword">case</span> sex when <span class="string">'女'</span> <span class="keyword">then</span> 1 <span class="keyword">else</span> 0 end) female_cnt</span><br><span class="line">from emp group by deptid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于只有两种条件选择，可以使用if-then形式</span></span><br><span class="line">select deptid, </span><br><span class="line">sum(<span class="keyword">if</span>(sex=<span class="string">'男'</span>,1,0)) male_cnt,</span><br><span class="line">sum(<span class="keyword">if</span>(sex=<span class="string">'女'</span>,1,0)) female_cnt</span><br><span class="line">from emp group by deptid;</span><br></pre></td></tr></table></figure>
<h4 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">select concat(<span class="string">'hello'</span>, <span class="string">'-'</span>, <span class="string">'world'</span>) <span class="comment"># 拼接字符串</span></span><br><span class="line">select concat(id, <span class="string">'-'</span>, name) from <span class="built_in">test</span>; <span class="comment"># 对test的两列id和name进行拼接</span></span><br><span class="line"></span><br><span class="line">select concat_ws(<span class="string">'-'</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>); <span class="comment"># 对字符串进行拼接</span></span><br><span class="line">select concat_ws(<span class="string">'-'</span>, id, name, address) from dept; <span class="comment"># 对dept中id和name两列进行合并，注意分隔符写在最开头</span></span><br><span class="line"></span><br><span class="line">select collect_set(id) from dept; <span class="comment"># 对dept表中id这列去重，注意也有collect_list函数，即数组</span></span><br><span class="line"></span><br><span class="line">select concat_ws(<span class="string">'_'</span>,collect_set(id)) from dept; <span class="comment"># 对dept表中id这列去重，并使用concat函数进行聚合。数字可以使用cast强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个实例：</span></span><br><span class="line"><span class="comment"># 北京 a 嘻嘻     北京,a 嘻嘻|呵呵</span></span><br><span class="line"><span class="comment"># 上海 b 哈哈     上海,b 哈哈|桀桀</span></span><br><span class="line"><span class="comment"># 北京 a 呵呵 =&gt;  广州,c 咯咯</span></span><br><span class="line"><span class="comment"># 广州 c 咯咯    </span></span><br><span class="line"><span class="comment"># 上海 b 桀桀    </span></span><br><span class="line"><span class="comment"># 拆成两部分，先是前两列进行合并，再进行groupby</span></span><br><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">select </span><br><span class="line">    concat_ws(<span class="string">','</span>, address, name) address_name, laugh </span><br><span class="line">from </span><br><span class="line">    <span class="built_in">test</span>; <span class="comment"># t1</span></span><br><span class="line"><span class="comment"># 第二步</span></span><br><span class="line">select </span><br><span class="line">     address_name, concat_ws(<span class="string">'|'</span>, collect_set(laugh))</span><br><span class="line">from </span><br><span class="line">    t1</span><br><span class="line">group by address_name</span><br><span class="line">;</span><br><span class="line"><span class="comment"># 完整步骤</span></span><br><span class="line">select </span><br><span class="line">     address_name, concat_ws(<span class="string">'|'</span>, collect_set(laugh))</span><br><span class="line">from </span><br><span class="line">    (select </span><br><span class="line">    concat_ws(<span class="string">','</span>, address, name) address_name, laugh </span><br><span class="line">from </span><br><span class="line">    <span class="built_in">test</span>)t1</span><br><span class="line">group by address_name; <span class="comment"># 将第一步第二步合并的code</span></span><br></pre></td></tr></table></figure>
<h4 id="行转列-explode"><a href="#行转列-explode" class="headerlink" title="行转列(explode)"></a>行转列(explode)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个例子:</span></span><br><span class="line"><span class="comment"># movie	category</span></span><br><span class="line"><span class="comment"># 《疑犯追踪》	悬疑,动作,科幻,剧情</span></span><br><span class="line"><span class="comment"># 《Lie to me》	悬疑,警匪,动作,心理,剧情</span></span><br><span class="line"><span class="comment"># 《战狼2》	战争,动作,灾难</span></span><br><span class="line"><span class="comment"># =&gt;=&gt;=&gt;=&gt;=&gt;=&gt; 转换成</span></span><br><span class="line"><span class="comment"># 《疑犯追踪》      悬疑</span></span><br><span class="line"><span class="comment"># 《疑犯追踪》      动作</span></span><br><span class="line"><span class="comment"># 《疑犯追踪》      科幻</span></span><br><span class="line"><span class="comment"># 《疑犯追踪》      剧情</span></span><br><span class="line"><span class="comment"># 《Lie to me》   悬疑</span></span><br><span class="line"><span class="comment"># 《Lie to me》   警匪</span></span><br><span class="line"><span class="comment"># 《Lie to me》   动作</span></span><br><span class="line"><span class="comment"># 《Lie to me》   心理</span></span><br><span class="line"><span class="comment"># 《Lie to me》   剧情</span></span><br><span class="line"><span class="comment"># 《战狼2》        战争</span></span><br><span class="line"><span class="comment"># 《战狼2》        动作</span></span><br><span class="line"><span class="comment"># 《战狼2》        灾难</span></span><br><span class="line">select explode(category) from movieinfo; <span class="comment"># 会将category这一列按照顺序整体展开</span></span><br><span class="line">select </span><br><span class="line">    movie movie_cat </span><br><span class="line">from </span><br><span class="line">    movieinfo lateral view explode(category) tmp as movie_cat; <span class="comment"># 注意，需要lateral view和explode连用，最后写上列的别名，tmp是表的别名</span></span><br></pre></td></tr></table></figure>
<h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">select name,count(*)</span><br><span class="line">from business</span><br><span class="line"><span class="built_in">where</span> substring(date, 1, 7)=<span class="string">'2017-04'</span></span><br><span class="line">group by name; <span class="comment"># 显示的是name及其对应出现的次数</span></span><br><span class="line"></span><br><span class="line">select name,count(*) over()</span><br><span class="line">from business</span><br><span class="line"><span class="built_in">where</span> substring(date, 1, 7)=<span class="string">'2017-04'</span></span><br><span class="line">group by name; <span class="comment"># 显示的是name及当前不重复的name的总数量。换句话说相当于对去掉count(*) over()之后的结果进行count(*)，因为事先groupby，所以就是name的类别数</span></span><br><span class="line"></span><br><span class="line">select date,cost,sum(cost) over(order by date)</span><br><span class="line">from business; <span class="comment"># 对date排序之后，对每一条进行开窗，即求所有日期的累和操作。如果不加order by那么对查询结果所有cost求和，即所有条目的值都相等。</span></span><br><span class="line"></span><br><span class="line">select name, date, cost, sum(cost) over(distribute by name) </span><br><span class="line">from business; <span class="comment"># 展示每条购物明细，并对每位顾客的消费总额进行展示。不能用group by，需要替代为distribute by。</span></span><br><span class="line"></span><br><span class="line">select name, date, cost, sum(cost) over(distribute by name sort by date) </span><br><span class="line">from business; <span class="comment"># 展示每条购物明细，并对每位顾客不同天的消费记录按时间顺序进行累加。distribute by与sort by连用。</span></span><br><span class="line"></span><br><span class="line">select name,orderdate,cost, </span><br><span class="line">lag(orderdate,1,<span class="string">'1900-01-01'</span>) over(partition by name order by orderdate ) as time1</span><br><span class="line">from business; <span class="comment"># 查询每个顾客的购物明细及上一次购买记录的时间。lag函数统计窗口内往上第n行值，第一个参数为字段名，第二个参数为n，第三个参数为缺失值填充，如不指定，默认为NULL。注意partition by name order by orderdate可以替换为distribute by ... sort by，同时末尾可以加desc或者asc。</span></span><br><span class="line"></span><br><span class="line">select name,orderdate,cost,  lag(orderdate,1,<span class="string">'9999-99-99'</span>) lead(partition by name order by orderdate ) as time1</span><br><span class="line">from business; <span class="comment"># lead是统计窗口内向下第n行值。</span></span><br><span class="line"></span><br><span class="line">select name, orderdate, cost, ntiles(5) over() ntile5</span><br><span class="line">from business; <span class="comment"># 该命令的作用是对所有数据行进行5等分，并且对每一行进行编号，从1开始，如果行数不足以整除，最后的编号可能会较之前的编号少。</span></span><br><span class="line"><span class="comment"># 该命令的使用场景为：当求某个数据前n%的数据时，可以在ntiles对应的括号中写入1/n%对应的数字，例如：求前20%的数据，可以使用ntile(5)，即分5份取1份，需使用子查询。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：lag，lead，ntile函数后面必须跟over字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：over内部可以使用关键字：current row，n preceding，n following，unbounded preceding，unbounded following，分别表示当前行，前n行，后n行，从头开始，到尾部。结合rows between ... and ...使用，是左闭右闭的区间，注意and前面一定大于其后面的。</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">select</span><br><span class="line">name, orderdate, cost, sum(cost) over(rows between 2 preceding and current row)</span><br><span class="line">from business; <span class="comment"># 表示查看原始数据每条数据及其前两条数据之和，partition by写在括号内rows前面</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结来说，over是对每个窗口(默认每条)进行相应聚合函数使用的命令，我感觉有点类似于pandas里面的groupby+apply+自定义函数，都是在指定窗口内进行操作，并返回“1”个结果。over的行数与除over所在行之外的命令所执行结果对应的行数相等，如果想去重，建议使用group by。</strong></p>
</blockquote>
<blockquote>
<p><strong>HIVE命令写的顺序：select，from，join，where，group by，order by，having，limit</strong></p>
</blockquote>
<blockquote>
<p><strong>HIVE命令执行的顺序：from，on，join，where，group by，having，select，order by，limit。命令中存在子查询的先做子查询，提示我们做表的join的时候如果有过滤条件可以将过滤条件写进子查询，之后再join。</strong></p>
</blockquote>
<h4 id="排名函数-窗口函数"><a href="#排名函数-窗口函数" class="headerlink" title="排名函数(窗口函数)"></a>排名函数(窗口函数)</h4><blockquote>
<p>排名函数也属于窗口函数<br>总共有三种，分别为<strong>rank()</strong>, <strong>dense_rank()</strong>, <strong>row_number()</strong>,三者的区别在于对排序相同时的处理方式。<br>举例：当4人的数学成绩为99，99，98，97时，要求对上述成绩进行排名。</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">结果</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>rank()</td>
<td style="text-align:center">1,1,3,4</td>
<td>排序相同时会重复，总数不变</td>
</tr>
<tr>
<td>dense_rank()</td>
<td style="text-align:center">1,1,2,3</td>
<td>排序相同时会重复，但总数会减少</td>
</tr>
<tr>
<td>row_number()</td>
<td style="text-align:center">1,2,3,4</td>
<td>会根据顺序计算</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">    name ,subject, score,</span><br><span class="line">    rank() over(partition by subject order by score desc) rank1,</span><br><span class="line">    dense_rank() over(partition by subject order by score desc) rank2,</span><br><span class="line">    row_number() over(partition by subject order by score desc) rank3</span><br><span class="line">from </span><br><span class="line">    score; <span class="comment"># 分别使用三种函数</span></span><br><span class="line"><span class="comment"># 使用的场景：某个店铺访问前3的用户信息，通过rank得到用户排名，之后使用where对rank小于4的过滤即可。limit不好用于分区，一般用于整体。</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><font color="red">函数</font></h2><h3 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show <span class="built_in">functions</span>; <span class="comment"># 查看系统自带函数</span></span><br><span class="line">desc <span class="keyword">function</span> upper; <span class="comment"># 显示自带函数的用法</span></span><br><span class="line">desc <span class="keyword">function</span> extended upper; <span class="comment"># 详细的显示自带函数的用法</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><blockquote>
<p>自定义函数主要有三种类型：</p>
<ol>
<li><strong>UDF</strong>(user-defined-function): 一进一出，如datediff。</li>
<li><strong>UDAF</strong>(user-defined-aggregation-function):多进一出，如max。</li>
<li><strong>UDTF</strong>(user-defined-table-generating-function):一进多出，如explode。</li>
</ol>
</blockquote>
<blockquote>
<p>编程步骤：</p>
<ol>
<li>继承org.apache.hadoop.hive.ql.UDF</li>
<li>需要实现evaluate函数，evaluate函数支持重载</li>
<li>在HIVE的命令行窗口创建函数<br>a. 添加jar包：<br><strong>add jar linux_jar_path</strong><br>b. 创建function:<br><strong>create [temporary] function [dbname.]function_name AS class_name # 使用temporary表示退出之后该功能删除，dbname表示对应库名。dbname指定了自定义函数使用的库，如果换了数据库(use xxx)会显示函数未定义。</strong></li>
<li>在HIVE的命令行窗口删除函数<br><strong>Drop [temporary] function [if exists] [dbname.]function name</strong><br><strong>注意UDF必须要有返回类型，可以是NULL，但不能是void</strong></li>
<li>使用：<br><strong>select myfun(id) from test; # 对test表中id这列使用自定义函数</strong></li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><font color="red">其他</font></h2><ol>
<li><p>distinct与双group</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">双group去重可能会稍微快一点</span><br><span class="line"><span class="comment"># distinct</span></span><br><span class="line">select</span><br><span class="line">    shop,</span><br><span class="line">    count(distinct id) user_cnt</span><br><span class="line">from</span><br><span class="line">    visit</span><br><span class="line">group by </span><br><span class="line">    shop;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双group</span></span><br><span class="line">select </span><br><span class="line">    shop,</span><br><span class="line">    count(*) user_cnt</span><br><span class="line">form</span><br><span class="line">    (</span><br><span class="line">select </span><br><span class="line">    shop, id</span><br><span class="line">from</span><br><span class="line">    visit</span><br><span class="line">group by</span><br><span class="line">    shop,id)t1</span><br><span class="line">group by </span><br><span class="line">    shop;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表中的列可以使用“.”来取用，例如：test表中的id列，test.id</p>
</li>
<li>select … from t1,t2,t3 from可以取多个表</li>
<li>floor()向下取整</li>
<li>网上有对sql进行格式优化的工具，可读性高</li>
<li>能先过滤数据集，就先过滤，方便效率的提高</li>
<li>连续n天问题思路：利用row_number + over对日期给定排序后的rank值，之后，使用date_sub对日期和rank值相减，再使用sum + over对上步相同日期差值组计算行量，最后过滤数量&gt;=n对应的数据行即可。（详见b站-尚硅谷HIVE-蚂蚁森林解法二）</li>
<li>sum(消费) + over(partition by 用户+ order by 时间+ rows between unbounded preceding and current row)可以用于对用户按时间顺序累积的消费进行统计。</li>
<li>word-count思路：split + explode + group by + count</li>
</ol>
<p>##</p>
<hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/25/Vim-learning/" rel="next" title="Vim命令学习">
                <i class="fa fa-chevron-left"></i> Vim命令学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpeg"
                alt="WenchaoXiu" />
            
              <p class="site-author-name" itemprop="name">WenchaoXiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive简介"><span class="nav-number">1.</span> <span class="nav-text">Hive简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">Hive基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive优缺点"><span class="nav-number">1.2.</span> <span class="nav-text">Hive优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">1.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive架构"><span class="nav-number">1.3.</span> <span class="nav-text">Hive架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive与数据库的比较"><span class="nav-number">1.4.</span> <span class="nav-text">Hive与数据库的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive安装与配置"><span class="nav-number">2.</span> <span class="nav-text">Hive安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive安装"><span class="nav-number">2.1.</span> <span class="nav-text">Hive安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统中导入Hive案例"><span class="nav-number">2.2.</span> <span class="nav-text">文件系统中导入Hive案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装MySQL"><span class="nav-number">2.3.</span> <span class="nav-text">安装MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive交互命令"><span class="nav-number">2.4.</span> <span class="nav-text">Hive交互命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive其他命令"><span class="nav-number">2.5.</span> <span class="nav-text">Hive其他命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive-数据类型"><span class="nav-number">3.</span> <span class="nav-text">Hive 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合数据类型"><span class="nav-number">3.2.</span> <span class="nav-text">集合数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转化"><span class="nav-number">3.3.</span> <span class="nav-text">类型转化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDL数据定义"><span class="nav-number">4.</span> <span class="nav-text">DDL数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库的增删改查"><span class="nav-number">4.1.</span> <span class="nav-text">数据库的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库的增"><span class="nav-number">4.1.1.</span> <span class="nav-text">数据库的增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库的删"><span class="nav-number">4.1.2.</span> <span class="nav-text">数据库的删</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库的改"><span class="nav-number">4.1.3.</span> <span class="nav-text">数据库的改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库的查"><span class="nav-number">4.1.4.</span> <span class="nav-text">数据库的查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表的增删改查"><span class="nav-number">4.2.</span> <span class="nav-text">表的增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建普通表"><span class="nav-number">4.2.1.</span> <span class="nav-text">创建普通表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建分区表"><span class="nav-number">4.2.2.</span> <span class="nav-text">创建分区表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表的修改"><span class="nav-number">4.2.3.</span> <span class="nav-text">表的修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表的删除"><span class="nav-number">4.2.4.</span> <span class="nav-text">表的删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML数据操作"><span class="nav-number">5.</span> <span class="nav-text">DML数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据的导入"><span class="nav-number">5.1.</span> <span class="nav-text">数据的导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据的导出"><span class="nav-number">5.2.</span> <span class="nav-text">数据的导出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据表查询"><span class="nav-number">6.</span> <span class="nav-text">数据表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本查询"><span class="nav-number">6.1.</span> <span class="nav-text">基本查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全表及特定列查询"><span class="nav-number">6.1.1.</span> <span class="nav-text">全表及特定列查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列别名"><span class="nav-number">6.1.2.</span> <span class="nav-text">列别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算数运算符"><span class="nav-number">6.1.3.</span> <span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用函数"><span class="nav-number">6.1.4.</span> <span class="nav-text">常用函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where语句"><span class="nav-number">6.2.</span> <span class="nav-text">where语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较运算符"><span class="nav-number">6.2.1.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Like和RLike比较运算符"><span class="nav-number">6.2.2.</span> <span class="nav-text">Like和RLike比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">6.2.3.</span> <span class="nav-text">逻辑运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组"><span class="nav-number">6.3.</span> <span class="nav-text">分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#group-by函数"><span class="nav-number">6.3.1.</span> <span class="nav-text">group by函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#having函数"><span class="nav-number">6.3.2.</span> <span class="nav-text">having函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接"><span class="nav-number">6.4.</span> <span class="nav-text">连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join两表连接"><span class="nav-number">6.4.1.</span> <span class="nav-text">join两表连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join多表连接"><span class="nav-number">6.4.2.</span> <span class="nav-text">join多表连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">6.5.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局排序"><span class="nav-number">6.5.1.</span> <span class="nav-text">全局排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按照别名排序"><span class="nav-number">6.5.2.</span> <span class="nav-text">按照别名排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多字段排序"><span class="nav-number">6.5.3.</span> <span class="nav-text">多字段排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区排序"><span class="nav-number">6.5.4.</span> <span class="nav-text">分区排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cluster-by"><span class="nav-number">6.5.5.</span> <span class="nav-text">cluster by</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分桶及抽样查询"><span class="nav-number">6.6.</span> <span class="nav-text">分桶及抽样查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他常用查询函数"><span class="nav-number">6.7.</span> <span class="nav-text">其他常用查询函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空字段赋值"><span class="nav-number">6.7.1.</span> <span class="nav-text">空字段赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间类"><span class="nav-number">6.7.2.</span> <span class="nav-text">时间类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CASE-WHEN"><span class="nav-number">6.7.3.</span> <span class="nav-text">CASE WHEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列转行"><span class="nav-number">6.7.4.</span> <span class="nav-text">列转行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行转列-explode"><span class="nav-number">6.7.5.</span> <span class="nav-text">行转列(explode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#窗口函数"><span class="nav-number">6.7.6.</span> <span class="nav-text">窗口函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排名函数-窗口函数"><span class="nav-number">6.7.7.</span> <span class="nav-text">排名函数(窗口函数)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统内置函数"><span class="nav-number">7.1.</span> <span class="nav-text">系统内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义函数"><span class="nav-number">7.2.</span> <span class="nav-text">自定义函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-car"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WenchaoXiu</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
