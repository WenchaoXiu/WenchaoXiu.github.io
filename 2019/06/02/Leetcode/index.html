<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ML, Python, R, Algorithms" />




  


  <link rel="alternate" href="/atom.xml" title="WenchaoXiu" type="application/atom+xml" />






<meta name="description" content="面试算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode">
<meta property="og:url" content="http://WenchaoXiu.github.io/2019/06/02/Leetcode/index.html">
<meta property="og:site_name" content="WenchaoXiu">
<meta property="og:description" content="面试算法">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:///">
<meta property="og:updated_time" content="2019-10-01T11:44:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode">
<meta name="twitter:description" content="面试算法">
<meta name="twitter:image" content="https:///">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://WenchaoXiu.github.io/2019/06/02/Leetcode/"/>





  <title>Leetcode | WenchaoXiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WenchaoXiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just try blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://WenchaoXiu.github.io/2019/06/02/Leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WenchaoXiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WenchaoXiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T11:17:06+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  面试算法
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description"></p>

<p><img src="https://" alt="" style="width:100%"></p>
<a id="more"></a>
<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>解题思路：</strong><br>对于target来说，从array的右上角进行搜索如果target比当前的数大则行加1列不变，向下搜索；如果target比当前的数小则列减1行不变，向左搜索。如果最后行列超出限制，则返回false。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row,col = <span class="number">0</span>,len(array[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> row&lt;=len(array)<span class="number">-1</span> <span class="keyword">and</span> col&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[row][col]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> target&gt;array[row][col]:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>可能有其他解法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%20'</span>.join(s.split(<span class="string">' '</span>))</span><br></pre></td></tr></table></figure>
<h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p><strong>解题思路</strong><br>使用递归，首先给出终止条件，如果链表为空返回[]，之后只需要return 当前链表的next+[当前的value]即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> listNode <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.printListFromTailToHead(listNode.next)+[listNode.val]</span><br></pre></td></tr></table></figure>
<h2 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4. 重建二叉树"></a>4. 重建二叉树</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>解题思路：</strong><br>使用递归进行重构，首先给出终止条件，如果当前list是空返回none，如果长度只有1，返回当前值为根节点的tree，除了上面两个情况，首先构建root，是前序遍历的第一个值，之后根据index函数求解对应中序遍历list总改值节点的位置，之后使用递归，将前序遍历list和中序遍历list分别拆分作为左右节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            idx = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">            root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:(idx+<span class="number">1</span>)], tin[:idx])</span><br><span class="line">            root.right = self.reConstructBinaryTree(pre[(idx+<span class="number">1</span>):], tin[(idx+<span class="number">1</span>):])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a>5. 用两个栈实现队列</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p>
<p><strong>解题思路：</strong><br>构建两个两个list，push的话就不断压栈即可，pop的话如果list2有元素则弹出，否者将list1中的值全部弹出并压入list2中最后弹出一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''使用两个栈，list的append和pop本身就是栈,记得初始化两个list</span></span><br><span class="line"><span class="string">    如果有新值需要插入的话直接插入stack1中，如果有值要弹出的话，如果stack2中还有值，直接弹，否则</span></span><br><span class="line"><span class="string">    把stack1中的值弹出到stack2中再弹出'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure>
<h2 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>解题思路：</strong><br>根据题目的思路，其实只要遍历数组找到对应的相邻的两个值是倒序的即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rotateArray)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i]&gt;rotateArray[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a>7. 斐波那契数列</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p><strong>解题思路：</strong><br>fib数列主要使用递归表达式实现，只需要存储前后两个数字就可以进行更新，f(n) = f(n-1)+f(n-2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        before, after = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">            before,after = after, before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure>
<h2 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a>8. 跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><strong>解题思路：</strong><br>依然使用递归思路，假设f(n)为当前台阶的跳法，因为只有两种跳跃方式，所以之前的一次跳跃方式只可能跳了1次或者跳了2次，如果跳了1次，那么其实和f(n-1)一样，如果跳了2次，那么其实和f(n-2)一样，所以可以通过递推公式f(n) = f(n-1)+f(n-2)进行更新</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        before = <span class="number">1</span></span><br><span class="line">        after = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            before,after = after,before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure>
<h2 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a>9. 变态跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>解题思路:</strong><br>其实跟上一题类似，只不过推广一下，相当于对之前所有的可能性求和，作为当前台阶的跳法，即f(n) = f(n-1)+f(n-2)…f(1),f(1)为1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number ==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        alist = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            alist.append(sum(alist)+<span class="number">1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a>10. 矩形覆盖</h2><p>我们可以用2 <em> 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p><strong>解题思路：</strong><br>仍然使用上题的思路，因为当前的砖只能横着放，或者竖着放，因此上一次是竖着放的时候f(n)方法和f(n-1)方法相同，上一次是横着放的时候f(n)方法和f(n-2)方法相同，所以的得到递归式 f(n) = f(n-1) + f(n-2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> number==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        before,after = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=number:</span><br><span class="line">            before,after = after, before+after</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure>
<h2 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11. 二进制中1的个数"></a>11. 二进制中1的个数</h2><h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12. 数值的整数次方"></a>12. 数值的整数次方</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p>
<p><strong>解题思路：</strong><br>对于exponent为0/1/-1单独计算，之后判断正负设定flag，然后判断exponent%2是否为1，如果为1转化为base <em> [(base </em> base) <strong> (exponent/2)]，否则为(base * base) </strong> (exponent/2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> exponent==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line">        <span class="keyword">elif</span> exponent==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/base</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            isneg = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> exponent&lt;<span class="number">0</span>:</span><br><span class="line">                isneg = <span class="keyword">True</span></span><br><span class="line">            exponent = abs(exponent)</span><br><span class="line">            <span class="keyword">if</span> exponent%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                ret = self.Power(base*base,exponent/<span class="number">2</span>)*base</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = self.Power(base*base,exponent/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ret <span class="keyword">if</span> isneg <span class="keyword">else</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13. 调整数组顺序使奇数位于偶数前面"></a>13. 调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>解题思路</strong><br>使用list自带的insert以及pop，pop弹出对应的index的值，insert插入的位置可能比遍历数组的指针要慢（使用两个指针，一个指针遍历数组，一个指针用来标定奇数的位置）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 利用pop和insert</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(array):</span><br><span class="line">            <span class="keyword">if</span> v%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">                array.insert(idx,array.pop(k))</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h2 id="14-反转链表"><a href="#14-反转链表" class="headerlink" title="14. 反转链表"></a>14. 反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p><strong>解题思路：</strong><br>使用头插法，设置新链表，同时对于旧链表的next值改为新链表的next，并将新链表的next赋值为旧链表，注意需要更新旧链表，在最上层更新防止覆盖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        ret = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            nextval = pHead.next</span><br><span class="line">            pHead.next = ret.next</span><br><span class="line">            ret.next = pHead</span><br><span class="line">            pHead = nextval</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="15-合并两个排序的链表"><a href="#15-合并两个排序的链表" class="headerlink" title="15. 合并两个排序的链表"></a>15. 合并两个排序的链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>解题思路：</strong><br>设置新链表，如果满足两个旧链表都不为空，则比较大小，并将小值赋给next，同时next更新，跳出循环之后，如果其中一个还不为空就直接加在新链表的next上即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val&gt;=pHead2.val:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">if</span> pHead1:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="16-数组中出现次数超过一半的数字"><a href="#16-数组中出现次数超过一半的数字" class="headerlink" title="16. 数组中出现次数超过一半的数字"></a>16. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p><strong>解题思路：</strong><br>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p>
<p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        val = numbers[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i==val:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt==<span class="number">0</span>:</span><br><span class="line">                val = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i==val:</span><br><span class="line">                ret += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> val <span class="keyword">if</span> ret&gt;(len(numbers)/<span class="number">2</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="17-最小的K个数"><a href="#17-最小的K个数" class="headerlink" title="17. 最小的K个数"></a>17. 最小的K个数</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>解题思路：</strong><br>使用快排，把比当前数字小的数字作为left list，比当前数字大的数字作为right list，递归排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(x)&lt;=<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = []</span><br><span class="line">                right = []</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> x[<span class="number">1</span>:]:</span><br><span class="line">                    <span class="keyword">if</span> i&lt;=x[<span class="number">0</span>]:</span><br><span class="line">                        left.append(i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right.append(i)</span><br><span class="line">                <span class="keyword">return</span> quickSort(left) + [x[<span class="number">0</span>]] + quickSort(right)</span><br><span class="line">        <span class="keyword">if</span> k&gt;len(tinput):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> quickSort(tinput)[:k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr)</span>:</span></span><br><span class="line">    m = arr[<span class="number">0</span>]</span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=m]</span><br><span class="line">    h = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;m]</span><br><span class="line">    <span class="keyword">return</span> l,m,h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(arr, k)</span>:</span></span><br><span class="line">    l,m,h = partition(arr)</span><br><span class="line">    <span class="keyword">if</span> len(l)==k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">elif</span> len(l)&lt;k<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> select(h, k-len(l)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> select(l, k)</span><br><span class="line">select([<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="18-连续子数组的最大和"><a href="#18-连续子数组的最大和" class="headerlink" title="18. 连续子数组的最大和"></a>18. 连续子数组的最大和</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<p><strong>解题思路：</strong><br>如果list不存在返回0，长度为1返回第一个元素，否则对list进行遍历，分别设置两个变量，一个变量记录以当前元素结尾时最大和，一个记录整体最大值，使用tmpmax=max(tmpmax+i, i),maxval=max(maxval,tmpmax)，最后返回maxval即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># f(n) = max(a[n], f(n-1)+a[n])</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">if</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line">        alist = [array[<span class="number">0</span>],]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">            tmp = max(array[i], alist[<span class="number">-1</span>]+array[i])</span><br><span class="line">            alist.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> max(alist)</span><br></pre></td></tr></table></figure>
<h2 id="19-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#19-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="19. 整数中1出现的次数（从1到n整数中1出现的次数）"></a>19. 整数中1出现的次数（从1到n整数中1出现的次数）</h2><p>求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数？为此他特别数了一下1 ~ 13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<p><strong>解题思路：</strong><br>对每个位置为1的个数进行加和，对每个位置上来说主要考虑三种情况，为0，为1，大于1，详细请看这个blog<a href="https://blog.csdn.net/weixin_40533355/article/details/83861895" target="_blank" rel="noopener">思路</a><br>设置三个变量，cnt记录1个数，base记录当前指数位数，raw记录原始数字，<br>对于n不为0，n=n/10,single=n%10，之后对single进行判断，如果single为0则cnt+=n <em> (10 ** base)<br>如果为1，cnt+=n </em> (10 <strong> base)+raw%(10 </strong> base)+1<br>如果为其他，cnt+=(n+1) * (10 ** base)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        base = <span class="number">0</span></span><br><span class="line">        raw = n</span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">0</span>:</span><br><span class="line">            single = n%<span class="number">10</span></span><br><span class="line">            n = n/<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> single==<span class="number">0</span>:</span><br><span class="line">                cnt += n*(<span class="number">10</span>**base) <span class="comment"># 0的时候只有上面的数字会影响</span></span><br><span class="line">            <span class="keyword">elif</span> single==<span class="number">1</span>:</span><br><span class="line">                cnt += n*(<span class="number">10</span>**base) + raw%(<span class="number">10</span>**base) + <span class="number">1</span> <span class="comment"># 1的时候上下都影响</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += (n+<span class="number">1</span>)*(<span class="number">10</span>**base) <span class="comment"># &gt;1时上面影响+所有下面的</span></span><br><span class="line">            base += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h2 id="20-把数组排成最小的数"><a href="#20-把数组排成最小的数" class="headerlink" title="20. 把数组排成最小的数"></a>20. 把数组排成最小的数</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>解题思路：</strong><br>注意这里活用sorted的cmp比较器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = map(str, numbers)</span><br><span class="line">        ret = sorted(alist, cmp=<span class="keyword">lambda</span> x,y: cmp(x+y,y+x)) <span class="comment"># 如果x+y小输出x后y</span></span><br><span class="line">        <span class="comment"># ret = sorted(alist, cmp=lambda x,y: cmp(y+x,x+y)) # 如果x+y小输出y后x</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ret)</span><br></pre></td></tr></table></figure>
<h2 id="21-第一个只出现一次的字符"><a href="#21-第一个只出现一次的字符" class="headerlink" title="21. 第一个只出现一次的字符"></a>21. 第一个只出现一次的字符</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<p><strong>解题思路：</strong><br>利用字典，没啥说的，基本操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = []</span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                adic[v] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[v] = <span class="number">1</span></span><br><span class="line">                alist.append((k,v)) <span class="comment"># 活用元组保存位置</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> alist:</span><br><span class="line">            <span class="keyword">if</span> adic[v]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="22-数组中只出现一次的数字"><a href="#22-数组中只出现一次的数字" class="headerlink" title="22. 数组中只出现一次的数字"></a>22. 数组中只出现一次的数字</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p><strong>解题思路：</strong><br>使用字典，使用list，如果在就remove，最后剩下的就返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">            <span class="keyword">if</span> adic[i]==<span class="number">1</span>:</span><br><span class="line">                alist.append(i)</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h2 id="23-和为S的连续正数序列"><a href="#23-和为S的连续正数序列" class="headerlink" title="23. 和为S的连续正数序列"></a>23. 和为S的连续正数序列</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9 ~ 16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p><strong>解题思路：</strong><br>使用滑窗法，设定一个list存结果，start为1，end为2，计算start-end之间的和，如果start &lt; end就while循环，如果和与target相同，list加入结果，如果大，start+1，如果小end+1同时更新和，直到最后返回list即可</p>
<p>注意：两个窗口都是从左边出发，不是两边夹逼。另外，当小于目标数时high++；大于目标数时low++，如果是high–，那么你仔细想想，你的窗口还怎么往后移动，整个结果在第一次大于目标数之后就不会往后移动，相反，而是在在这个low和high之间夹逼试探，最终啥都找不到或者只能找到一个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = []</span><br><span class="line">        idx_low,idx_high = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        sum_val = (idx_low+idx_high)*(idx_high-idx_low+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> idx_low&lt;idx_high:</span><br><span class="line">            <span class="keyword">if</span> sum_val==tsum:</span><br><span class="line">                alist.append(range(idx_low,idx_high+<span class="number">1</span>))</span><br><span class="line">                idx_high += <span class="number">1</span> <span class="comment"># 需要更新否则stall在这里了</span></span><br><span class="line">                sum_val += idx_high <span class="comment"># 这里只要加新的即可</span></span><br><span class="line">            <span class="keyword">elif</span> sum_val&lt;tsum:</span><br><span class="line">                idx_high += <span class="number">1</span></span><br><span class="line">                sum_val += idx_high <span class="comment"># 这里只要加新的即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum_val -= idx_low <span class="comment"># 注意顺序</span></span><br><span class="line">                idx_low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h2 id="24-翻转单词顺序列"><a href="#24-翻转单词顺序列" class="headerlink" title="24. 翻转单词顺序列"></a>24. 翻转单词顺序列</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(s.split(<span class="string">' '</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="25-求1-2-3-…-n"><a href="#25-求1-2-3-…-n" class="headerlink" title="25. 求1+2+3+…+n"></a>25. 求1+2+3+…+n</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p><strong>解题思路：</strong><br>肯定是要用递归来解决，但是又不能使用if来给出终止条件，所以只能通过逻辑符号进行终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> self.Sum_Solution(n<span class="number">-1</span>)+n</span><br></pre></td></tr></table></figure>
<h2 id="26-数组中重复的数字"><a href="#26-数组中重复的数字" class="headerlink" title="26. 数组中重复的数字"></a>26. 数组中重复的数字</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p><strong>解题思路：</strong><br>对数组进行遍历，对于每个位置，while判断当前index和value是否不相等，如果不等进入循环，判断value和list[value]相等则输出，不相等则替换位置，直至index和value相等。最后返回false</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">while</span> k!=v:</span><br><span class="line">                <span class="keyword">if</span> v==numbers[v]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = v</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                tmp = numbers[v]</span><br><span class="line">                numbers[v] = v</span><br><span class="line">                v = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="27-构建乘积数组"><a href="#27-构建乘积数组" class="headerlink" title="27. 构建乘积数组"></a>27. 构建乘积数组</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。</p>
<p><strong>解题思路：</strong><br>主要想法就是两次遍历，正序遍历每个元素都为前面所有元素之积，倒序遍历每个元素都为所有后面元素之积</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = [<span class="number">1</span>]</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[:<span class="number">-1</span>]:</span><br><span class="line">            tmp *= i</span><br><span class="line">            ret.append(tmp)</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            tmp *= A[i+<span class="number">1</span>]</span><br><span class="line">            ret[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="28-二叉树的下一个结点"><a href="#28-二叉树的下一个结点" class="headerlink" title="28. 二叉树的下一个结点"></a>28. 二叉树的下一个结点</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>解题思路：</strong><br>因为是基于中序遍历，所以正常遍历是左中右，首先判断某个节点是否有右节点，如果有右节点设置临时节点tmp同时对tmp.left不断遍历，直到null然后返回对应值<br>对于没有有节点的值，向上找到父节点，判断是否父节点的left与当前节点是否相同，相同的话返回父节点，否则不断向上追溯，直到某个父节点的left与当前节点相同返回父节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            tmp = pNode.right</span><br><span class="line">            <span class="keyword">while</span> tmp.left:</span><br><span class="line">                tmp = tmp.left</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.next:</span><br><span class="line">                parent = pNode.next</span><br><span class="line">                <span class="keyword">if</span> (parent.left==pNode):</span><br><span class="line">                    <span class="keyword">return</span> parent</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h2 id="29-矩阵中的路径"><a href="#29-矩阵中的路径" class="headerlink" title="29. 矩阵中的路径"></a>29. 矩阵中的路径</h2><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p><strong>解题思路：</strong></p>
<pre><code>- 这道题利用回溯法，需要设定对应的矩阵的状态情况以及当前路径长度，需要一个辅助函数，主函数给定边界条件，当cols和rows都小于0或者要搜寻的路径小于0的时候返回False。
- 因为不知道具体的其实点在哪，所以两层循环，对不同的ij进行试探hasPathCore(matrix, rows, cols, path, i, j, pathlen, markMTX)，其中pathlen是给定的路径的长度，markMTX是对应的状态。
- hasPathCore这个函数首先判断pathlen是否跟len(path)相等，如果相等返回true。之后查看col/row是否满足边界条件，以及markMTX[i][j]状态是否未遍历，以及matrix[i][j]是否跟path[pathlen]相等，如果相等对当前矩阵状态进行变更同时pathlen+1，分别对上下左右进行递归or连接，如果返回true，直接return，如果返回false，对矩阵状态/pathlen进行退回，返回false
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># 过滤条件</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> cols&lt;<span class="number">0</span> <span class="keyword">or</span> rows&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        markMTX = [<span class="number">0</span>]*(rows*cols)</span><br><span class="line">        pathlen = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 确定逐个起始点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> self.hasPathCore(matrix, rows, cols, path, i, j, pathlen, markMTX):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathCore</span><span class="params">(self, matrix, rows, cols, path, row, col, pathlen, markMTX)</span>:</span></span><br><span class="line">        <span class="comment"># 3.终止条件</span></span><br><span class="line">        <span class="keyword">if</span> pathlen == len(path):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 2.设置初始防止一开始不满足</span></span><br><span class="line">        haspath = <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 1.满足条件递归</span></span><br><span class="line">        <span class="keyword">if</span> row&gt;=<span class="number">0</span> <span class="keyword">and</span> row&lt;rows <span class="keyword">and</span> col&gt;=<span class="number">0</span> <span class="keyword">and</span> col&lt;cols <span class="keyword">and</span> matrix[cols*row+col]==path[pathlen] <span class="keyword">and</span> <span class="keyword">not</span> markMTX[cols*row+col]:</span><br><span class="line">            pathlen += <span class="number">1</span></span><br><span class="line">            markMTX[cols*row+col] = <span class="number">1</span></span><br><span class="line">            haspath = self.hasPathCore(matrix, rows, cols, path, row<span class="number">-1</span>, col, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row+<span class="number">1</span>, col, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row, col<span class="number">-1</span>, pathlen, markMTX) <span class="keyword">or</span> \</span><br><span class="line">                self.hasPathCore(matrix, rows, cols, path, row, col+<span class="number">1</span>, pathlen, markMTX)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> haspath:</span><br><span class="line">                pathlen -= <span class="number">1</span></span><br><span class="line">                markMTX[cols*row+col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> haspath</span><br></pre></td></tr></table></figure>
<h2 id="30-机器人的运动范围"><a href="#30-机器人的运动范围" class="headerlink" title="30. 机器人的运动范围"></a>30. 机器人的运动范围</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<p><strong>解题思路：</strong><br>边界判断，是否长宽都小于0，否则返回0<br>之后设置辅助函数，一个是求位数和的，一个是用来计算能有多少个符合的格子，设定矩阵状态，给定00为起始点，对于每次满足ij范围且state[i][j]为0且坐标位数之和小于阈值，则计算count=1+上下左右，返回count即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stateMTX = [<span class="number">0</span>]*(rows*cols)</span><br><span class="line">        num = self.GetNum(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, stateMTX)</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNum</span><span class="params">(self, threshold, rows, cols, row, col, markmatrix)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.GetSum(threshold, rows, cols, row, col, markmatrix):</span><br><span class="line">            markmatrix[row * cols + col] = <span class="keyword">True</span></span><br><span class="line">            count = <span class="number">1</span> + self.GetNum(threshold, rows, cols, row - <span class="number">1</span>, col, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row, col - <span class="number">1</span>, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row + <span class="number">1</span>, col, markmatrix) + \</span><br><span class="line">                    self.GetNum(threshold, rows, cols, row, col + <span class="number">1</span>, markmatrix)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetSum</span><span class="params">(self, threshold, rows, cols, row, col, markmatrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> self.getdigit(row) + self.getdigit(</span><br><span class="line">                col) &lt;= threshold <span class="keyword">and</span> <span class="keyword">not</span> markmatrix[row * cols + col]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdigit</span><span class="params">(self,number)</span>:</span></span><br><span class="line">        sumval = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number&gt;<span class="number">0</span>:</span><br><span class="line">            sumval += number%<span class="number">10</span></span><br><span class="line">            number = number//<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sumval</span><br></pre></td></tr></table></figure>
<h3 id="31-剪绳子-leetcode-343-整数拆分"><a href="#31-剪绳子-leetcode-343-整数拆分" class="headerlink" title="31. 剪绳子(leetcode 343 整数拆分)"></a>31. 剪绳子(leetcode 343 整数拆分)</h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>你可以假设 n 不小于 2 且不大于 58。</p>
<p>n = 2<br>return 1 (2 = 1 + 1)</p>
<p>n = 10<br>return 36 (10 = 3 + 3 + 4)</p>
<p><strong>解题思路</strong><br>使用动态规划，当长度为2时返回1，当长度为3时返回2，当长度大于等于4时，因为当前最优解是建立在之前最优解的基础上的，因此，只需要遍历之前最优解进行乘积找到最大即可。首先设定list[0,1,2,3]因为按照分各状态前三个分各状态是这样的，之后只需要不断向list里面添加最大值即可。最后输出最后一个元素即可。</p>
<p>或者求与3的余数，如果为1减一个3错一个4，为2则单拎出2.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">            idx = <span class="number">4</span></span><br><span class="line">            <span class="keyword">while</span> idx&lt;=n:</span><br><span class="line">                maxval = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,idx):</span><br><span class="line">                    maxval = max(maxval, alist[i]*alist[idx-i])</span><br><span class="line">                alist.append(maxval)</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="32-在-O-1-时间内删除链表节点"><a href="#32-在-O-1-时间内删除链表节点" class="headerlink" title="32. 在 O(1) 时间内删除链表节点"></a>32. 在 O(1) 时间内删除链表节点</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解题思路:</span><br><span class="line">判断链表是否存在，然后判断删除节点的<span class="keyword">next</span>是否是<span class="keyword">null</span>，如果不是<span class="keyword">null</span>，直接<span class="keyword">delete</span>.val = <span class="keyword">next</span>.val以及<span class="keyword">delete</span>.<span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>即可</span><br><span class="line">如果是<span class="keyword">null</span>要判断head是否与<span class="keyword">delete</span>相等，如果相等直接head=None，否则产生一个tmp节点遍历直至tmp.<span class="keyword">next</span>与删除节点相等，同时使tmp.<span class="keyword">next</span>=<span class="keyword">null</span>即可</span><br></pre></td></tr></table></figure>
<h3 id="33-删除链表中重复的结点"><a href="#33-删除链表中重复的结点" class="headerlink" title="33. 删除链表中重复的结点"></a>33. 删除链表中重复的结点</h3><p><strong>解题思路：</strong><br>对于基础情况如果phead为空或者next为空返回本身，否则设定nextnode，如果nextnode值与当前值不等，直接利用递归phead.next=self.deleteDuplication(phead.next)然后return-phead，否则使用while循环在满足有nextnode以及nextnode.val==phead.val条件时，不断.next，然后跳出循环时，返回利用递归返回self.deleteDuplication(nextnode)即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nextnode = pHead.next</span><br><span class="line">            <span class="keyword">if</span> nextnode.val==pHead.val:</span><br><span class="line">                <span class="keyword">while</span> nextnode <span class="keyword">and</span> nextnode.val==pHead.val:</span><br><span class="line">                    nextnode = nextnode.next</span><br><span class="line">                <span class="keyword">return</span> self.deleteDuplication(nextnode)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pHead.next = self.deleteDuplication(pHead.next)</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>
<h2 id="34-链表中倒数第-K-个结点"><a href="#34-链表中倒数第-K-个结点" class="headerlink" title="34. 链表中倒数第 K 个结点"></a>34. 链表中倒数第 K 个结点</h2><p><strong>解题思路</strong><br>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<p>注意边界条件，k为负数head为空，还要考虑k&gt;len(head)的情况，使用while循环避免</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p1,p2 = head,head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> i&lt;k:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p2</span><br></pre></td></tr></table></figure>
<h2 id="35-链表中环的入口结点"><a href="#35-链表中环的入口结点" class="headerlink" title="35. 链表中环的入口结点"></a>35. 链表中环的入口结点</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>解题思路：</strong><br>首先确定是否有环，快慢指针如果相等返回相遇节点。(一定在环里)<br>确定环的长度，根据该点在环内，如果相遇记录下长度<br>之后重新弄两个节点，想让一个走环长度，一个作为头，只后相同步数(1)相遇即为入口(因为此时环中点以及起始点距离环入口刚好都相等)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断是否为有环链表，如果是的话计算环的长度，指定两个idx，其中一个往后延伸环长度距离，之后以相同的步伐后移，</span></span><br><span class="line"><span class="string">        当相交的时候对应的节点即为入口</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isloop</span><span class="params">(pHead)</span>:</span></span><br><span class="line">            <span class="comment"># 判断是否为loop，是返回橡胶节点，一定在环中</span></span><br><span class="line">            idx1,idx2 = pHead, pHead</span><br><span class="line">            <span class="keyword">while</span> idx1.next <span class="keyword">and</span> idx2.next.next:</span><br><span class="line">                idx1 = idx1.next</span><br><span class="line">                idx2 = idx2.next.next</span><br><span class="line">                <span class="keyword">if</span> idx1 == idx2:</span><br><span class="line">                    <span class="keyword">return</span> idx1</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 计算环长度</span></span><br><span class="line">        ret = isloop(pHead)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            tmp = ret</span><br><span class="line">            length = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> tmp.next != ret:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                tmp = tmp.next</span><br><span class="line">            <span class="comment"># idx2先往后延长length距离，在以相同步伐前进，如果相等返回idx1/idx2节点</span></span><br><span class="line">            idx1,idx2 = pHead, pHead</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                idx2 = idx2.next</span><br><span class="line">            <span class="keyword">while</span> idx1!=idx2:</span><br><span class="line">                idx1 = idx1.next</span><br><span class="line">                idx2 = idx2.next</span><br><span class="line">            <span class="keyword">return</span> idx1</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h2 id="36-树的子结构"><a href="#36-树的子结构" class="headerlink" title="36. 树的子结构"></a>36. 树的子结构</h2><p><strong>解题思路：</strong><br>设置一个辅助函数，叫做isRootSubtree，给定两个树，判断是不是这两个树相等，如果root1不存在或者root1.val!=root.val返回false，如果root2为None返回true，之后再利用isRootSubtree递归判断左右两个节点<br>对于主函数，如果root1或者root2为空返回false(因为空树不是子结构)，否则判断isRootSubtree以及对左右节点进行递归循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_subtree</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(A.left,B.left) <span class="keyword">and</span> self.is_subtree(A.right, B.right)</span><br></pre></td></tr></table></figure>
<h2 id="37-二叉树的镜像"><a href="#37-二叉树的镜像" class="headerlink" title="37. 二叉树的镜像"></a>37. 二叉树的镜像</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><strong>解题思路：</strong><br>首先边界条件，如果根节点是空的那么返回false，然后左右交换，再判断如果左节点存在则对于左节点递归，如果右节点存在则对于右节点递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''还是使用递归，中间不变左右交换，因此先判断tree是不是空，而且左右是否全为空，如果是false停止，</span></span><br><span class="line"><span class="string">        然后先换一次左和右，如果左子树非空再利用递归在左子树，右子树也是相同的'''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure>
<h2 id="38-对称的二叉树"><a href="#38-对称的二叉树" class="headerlink" title="38 对称的二叉树"></a>38 对称的二叉树</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p><strong>解题思路：</strong><br>根节点如果为空返回true，否则使用辅助函数isequal来判断根节点左子节点与右节点是否相等<br>辅助函数是为了判断树是否是对称的，判断两个节点如果都空返回true，如果两个节点有一个空返回false，如果两个节点值相等再使用递归返回对左右子树分别判断and连接结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_right</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> left.val==right.val:</span><br><span class="line">            <span class="keyword">return</span> self.left_right(left.left,right.right) <span class="keyword">and</span> self.left_right(left.right,right.left)</span><br><span class="line">        <span class="comment"># class里面所有的function都需要使用self调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 根节点比较特殊</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.left_right(pRoot.left, pRoot.right)</span><br></pre></td></tr></table></figure>
<h2 id="39-顺时针打印矩阵"><a href="#39-顺时针打印矩阵" class="headerlink" title="39. 顺时针打印矩阵"></a>39. 顺时针打印矩阵</h2><p>矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<p><strong>解题思路：</strong><br>首先确定矩阵row和col的边界，使用while循环在row的上边界&lt;=下边界和col左边界&lt;=右边界时，<br>对矩阵顺时针遍历，一行一列之后需要判断row的上下边界是否相等，不相等遍历添加，同理col左右边界也是一样。最后统一对上下左右边界进行更新</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        ret = []</span><br><span class="line">        c1,c2,r1,r2 = <span class="number">0</span>,len(matrix[<span class="number">0</span>])<span class="number">-1</span>,<span class="number">0</span>,len(matrix)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> c1&lt;=c2 <span class="keyword">and</span> r1&lt;=r2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(c1,c2+<span class="number">1</span>):</span><br><span class="line">                ret.append(matrix[r1][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r1+<span class="number">1</span>,r2+<span class="number">1</span>):</span><br><span class="line">                ret.append(matrix[i][c2])</span><br><span class="line">            <span class="keyword">if</span> r1!=r2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(c1,c2)[::<span class="number">-1</span>]:</span><br><span class="line">                    ret.append(matrix[r2][i])</span><br><span class="line">            <span class="keyword">if</span> c1!=c2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(r1+<span class="number">1</span>,r2)[::<span class="number">-1</span>]:</span><br><span class="line">                    ret.append(matrix[i][c1])</span><br><span class="line">            c1+=<span class="number">1</span>;c2-=<span class="number">1</span>;r1+=<span class="number">1</span>;r2-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="40-包含-min-函数的栈"><a href="#40-包含-min-函数的栈" class="headerlink" title="40. 包含 min 函数的栈"></a>40. 包含 min 函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p>
<p><strong>题目解析：</strong><br>对于整个class，设置初始值函数，设置push函数，如果help栈为空data和help压入，如果data压入的值小于help最后一个值，则将新值压入help，弹栈的时候help和data都弹，栈的最小值求解的时候直接弹出辅助栈最后一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    定义两个list分别是数据以及辅助列表，当有数值压入的时候，data一定压入，help判断是否为空，为空压入，</span></span><br><span class="line"><span class="string">    不为空时如果最后一个值大于新值，也压入。弹栈的时候如果help和data相同则都弹出，否则只弹出data。</span></span><br><span class="line"><span class="string">    top返回最后一个值即可。min返回help最后一个值即可。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line">        self.help = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.data.append(node)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.help:</span><br><span class="line">            self.help.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.help[<span class="number">-1</span>]&gt;node:</span><br><span class="line">            self.help.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.data[<span class="number">-1</span>] == self.help[<span class="number">-1</span>]:</span><br><span class="line">            self.help.pop()</span><br><span class="line">        <span class="keyword">return</span> self.data.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.data[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.help[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="41-栈的压入、弹出序列"><a href="#41-栈的压入、弹出序列" class="headerlink" title="41. 栈的压入、弹出序列"></a>41. 栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。<br>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<p><strong>解题思路：</strong><br>遍历压栈list，使用while循环如果压栈不空且压栈值与弹栈值第一个相等则弹出值，同时弹栈序列index向后推，最后判断压栈是否为空，为空返回true否则false</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        借助一个list和一个指针实现，list存储压栈元素，指针表征弹栈位置，</span></span><br><span class="line"><span class="string">        遍历压栈，如果压栈之后最后一个元素和弹栈指针所指元素相等(list不空)，那么list弹栈，指针加1，</span></span><br><span class="line"><span class="string">        如果不是则继续遍历压栈，最后查看list情况，如果空了返回True反之返回False</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        alist = []</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pushV: <span class="comment"># 压栈只有一次，遍历即可</span></span><br><span class="line">            alist.append(i)</span><br><span class="line">            <span class="keyword">while</span> alist <span class="keyword">and</span> alist[<span class="number">-1</span>]==popV[j]:</span><br><span class="line">                alist.pop()</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> alist:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="42-从上往下打印二叉树"><a href="#42-从上往下打印二叉树" class="headerlink" title="42 从上往下打印二叉树"></a>42 从上往下打印二叉树</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p>
<p><strong>解题思路:</strong><br>使用广度优先搜索，考虑边界，如果根节点为空返回None，设置一个list放置节点，先放入根节点，如果list不空，则弹出节点同时加入节点对应的val，如果节点左右节点是有的之加入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        通过每次只输出根节点的值，并把后续的值append到tmp中，直至tmp为空，遍历完成</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        alist = []</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            cur = tmp.pop(<span class="number">0</span>)</span><br><span class="line">            alist.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                tmp.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                tmp.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h2 id="43-把二叉树打印成多行"><a href="#43-把二叉树打印成多行" class="headerlink" title="43. 把二叉树打印成多行"></a>43. 把二叉树打印成多行</h2><p><strong>解题思路：</strong><br>对于根节点进行判断，如果空则返回false，如果不空，加入临时list中，在list不为空时，使用一个辅助list保存当前层值，同时记录当前list长度，再利用一个循环对长度范围进行遍历，之后将list加入到结果列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = []</span><br><span class="line">            tmp = [pRoot]</span><br><span class="line">            <span class="keyword">while</span> tmp:</span><br><span class="line">                alist = []</span><br><span class="line">                length = len(tmp)</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                    node = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                    alist.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        tmp.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        tmp.append(node.right)</span><br><span class="line">                ret.append(alist)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="44-按之字形顺序打印二叉树"><a href="#44-按之字形顺序打印二叉树" class="headerlink" title="44. 按之字形顺序打印二叉树"></a>44. 按之字形顺序打印二叉树</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><strong>解题思路：</strong><br>和上题一样，列表控制元素添加，当前列表长度控制行数，同时再加一个cnt用来判断是否是基数行，如果是则正序否则倒序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist = [pRoot]</span><br><span class="line">            ret = []</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> alist:</span><br><span class="line">                length = len(alist)</span><br><span class="line">                vallist = []</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">                    pop = alist.pop(<span class="number">0</span>)</span><br><span class="line">                    vallist.append(pop.val)</span><br><span class="line">                    <span class="keyword">if</span> pop.left:</span><br><span class="line">                        alist.append(pop.left)</span><br><span class="line">                    <span class="keyword">if</span> pop.right:</span><br><span class="line">                        alist.append(pop.right)</span><br><span class="line">                <span class="keyword">if</span> cnt%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                    ret.append(vallist)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ret.append(vallist[::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="45-二叉搜索树的后序遍历序列"><a href="#45-二叉搜索树的后序遍历序列" class="headerlink" title="45. 二叉搜索树的后序遍历序列"></a>45. 二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p>
<p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p>
<p><strong>解题思路:</strong><br>对于二叉搜索树，左&lt;中&lt;右，后序遍历是左右中，因此，list最后一个是根节点，根据根节点的值将list分成两部分，左节点右节点，分割index，如果右节点的值中有小于根节点的，返回false，否则返回true。之后如果左节点不空递归查看，右节点一样，然后返回左右结果并值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：</span></span><br><span class="line"><span class="string">        这里要输出False/True而不是yes/no</span></span><br><span class="line"><span class="string">        注意二叉搜索树指的是二叉树中所有左边节点数值都比根节点数值小，右边节点数值都比根节点数值大</span></span><br><span class="line"><span class="string">        后续遍历是先左节点再右节点最后根节点</span></span><br><span class="line"><span class="string">        按照后序遍历方法root一定是最后一个值，左节点树在前右节点树在后，所以可以根据root值将list分为</span></span><br><span class="line"><span class="string">        两部分，所以根据前部分值确定分隔点index(小于root)，再根据index确定时候后半部分值都大于root，</span></span><br><span class="line"><span class="string">        如果是的话返回true，否则返回False，列表为空返回false</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        root = sequence[<span class="number">-1</span>]</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence[:<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i&lt;root:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sequence[idx:<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> j &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> sequence[:idx+<span class="number">1</span>]:</span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[:idx+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> sequence[idx+<span class="number">1</span>:<span class="number">-1</span>]:</span><br><span class="line">            right =  self.VerifySquenceOfBST(sequence[idx+<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure>
<h2 id="46-二叉树中和为某一值的路径"><a href="#46-二叉树中和为某一值的路径" class="headerlink" title="46. 二叉树中和为某一值的路径"></a>46. 二叉树中和为某一值的路径</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<p><strong>解题思路：</strong><br>使用递归，终止条件有两个如果tree为none返回none，如果node左右节点为空且当前节点值与target相等，返回[[node.val]]，然后对左右节点分别使用递归，最后遍历左右节点，分别于root.val相加返回最终值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [] <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val==expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]] <span class="comment"># 终止条件</span></span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val) <span class="comment"># 循环体</span></span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val) <span class="comment"># 循环体</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:</span><br><span class="line">            ret.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="47-复杂链表的复制"><a href="#47-复杂链表的复制" class="headerlink" title="47. 复杂链表的复制"></a>47. 复杂链表的复制</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<p><strong>解题思路：</strong><br>首先找到边界条件，如果为空返回None，之后复制链表分成三步，首先先复制node然后node与前后进行连接(next连接)利用while进行遍历，之后再对random进行复制(如果random存在的话)，最后再对链表进行分割(cur.next存在)，next=cur.next，之后cur.next=next.next，cur=next，之后再返回对应的clone节点即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = RandomListNode(cur.label)</span><br><span class="line">            tmp.next = cur.next</span><br><span class="line">            cur.next = tmp</span><br><span class="line">            cur = tmp.next</span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nextnode = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                nextnode.random = cur.random.next</span><br><span class="line">            cur = nextnode.next</span><br><span class="line">        cur = pHead</span><br><span class="line">        clonehead = pHead.next</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            nextval = cur.next</span><br><span class="line">            cur.next = nextval.next</span><br><span class="line">            cur = nextval</span><br><span class="line">        <span class="keyword">return</span> clonehead</span><br></pre></td></tr></table></figure>
<h2 id="48-二叉搜索树与双向链表"><a href="#48-二叉搜索树与双向链表" class="headerlink" title="48. 二叉搜索树与双向链表"></a>48. 二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>解题思路：</strong><br>其实就是中序遍历的变体，首先初始化listhead和listtail分别为none，之后使用中序遍历，在中间过程中对节点进行判断，如果是第一次，就把root节点给head和tail，否则改变节点指向，tail.right指向root，root.left指向tail，同时tail更新为root，最后返回即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.listhead = <span class="keyword">None</span></span><br><span class="line">        self.listtail = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        self.Convert(pRootOfTree.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.listhead:</span><br><span class="line">            self.listhead = pRootOfTree</span><br><span class="line">            self.listtail = pRootOfTree</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.listtail.right = pRootOfTree</span><br><span class="line">            pRootOfTree.left = self.listtail</span><br><span class="line">            self.listtail = pRootOfTree</span><br><span class="line">        self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="keyword">return</span> self.listhead</span><br></pre></td></tr></table></figure>
<h2 id="49-序列化二叉树"><a href="#49-序列化二叉树" class="headerlink" title="49. 序列化二叉树"></a>49. 序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><strong>解题思路：</strong><br>对于二叉树的序列化，可以对tree进行判断，如果为空返回#，否则返回根值,树左节点遍历,树右节点遍历，使用逗号隔开<br>对于反序列化，对序列按照逗号进行分割，然后使用一个辅助函数，辅助函数：如果list为空返回None，之后对对list.pop(0)，如果该值不为#则返回构建的树，记得左右节点是递归构建的，再return root即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 前序遍历如果有none存在就返回'#'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val)+<span class="string">','</span>+self.Serialize(root.left)+<span class="string">','</span>+self.Serialize(root.right) <span class="comment"># 字符串转化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deser</span><span class="params">(self, alist)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> alist: <span class="comment"># 如果为空#都没了返回None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        val = alist.pop(<span class="number">0</span>) <span class="comment"># 如果有的话pop</span></span><br><span class="line">        root = <span class="keyword">None</span> <span class="comment"># 设定为空，如果上来就是#，也要返回None</span></span><br><span class="line">        <span class="keyword">if</span> val!=<span class="string">'#'</span>:</span><br><span class="line">            root = TreeNode(int(val))</span><br><span class="line">            root.left = self.deser(alist) <span class="comment"># 顺序输出可以保证左右</span></span><br><span class="line">            root.right = self.deser(alist)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        alist = s.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">return</span> self.deser(alist)</span><br></pre></td></tr></table></figure>
<h2 id="50-字符串的排列"><a href="#50-字符串的排列" class="headerlink" title="50. 字符串的排列"></a>50. 字符串的排列</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p>
<p><strong>解题思路：</strong><br>首先基本的边界判断，如果ss为空返回[]，否则设定ret=[]作为结果存放，path=’’作为开始的字符串长度<br>利用辅助函数，递归终止条件是当ss为空的对path插入到ret中(便利到最后一个字符的时候会一次性插入不用担心path有问题)，否则对每个字符进行遍历，使用递归更新子问题</p>
<p>ss是状态，ret是结果，类似于之前的机器人和路径查找，只不过是状态矩阵以及以及length分别作为判断，结果返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(self.help(ss))))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ss)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(ss)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [ss]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> self.help(ss[:i]+ss[i+<span class="number">1</span>:]):</span><br><span class="line">                    ret.append(v+j)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="51-数据流中的中位数"><a href="#51-数据流中的中位数" class="headerlink" title="51. 数据流中的中位数"></a>51. 数据流中的中位数</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p><strong>解题思路：</strong><br>可以初始化一个列表，然后insert数据流中的数，之后对于数据进行排序，在输出中位数即可<br>要熟悉一下各类排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.alist = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.alist.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self,n=None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        list_len = len(self.alist)</span><br><span class="line">        sort_list = sorted(self.alist)</span><br><span class="line">        <span class="keyword">if</span> list_len%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sort_list[list_len/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (sort_list[list_len/<span class="number">2</span>]+sort_list[list_len/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<h2 id="52-字符流中第一个不重复的字符"><a href="#52-字符流中第一个不重复的字符" class="headerlink" title="52 字符流中第一个不重复的字符"></a>52 字符流中第一个不重复的字符</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。</p>
<p><strong>解题思路：</strong><br>设置初始函数，一个s一个dic分别用作记录不重复字符以及对应的字符字典，插入功能：对字符进行统计，如果是新的需要s加入此元素(顺序加入)，之后对于不重复的元素只要遍历self.s进行对比是否为1即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应char</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">        self.adic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.adic[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.adic:</span><br><span class="line">            self.adic[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.adic[char] = <span class="number">1</span></span><br><span class="line">            self.s += char</span><br></pre></td></tr></table></figure>
<h2 id="53-把数字翻译成字符串"><a href="#53-把数字翻译成字符串" class="headerlink" title="53. 把数字翻译成字符串"></a>53. 把数字翻译成字符串</h2><p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”… 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>解题思路：</strong><br>典型的动态规划问题，分歧点就在于是否新加入的字符串能够和上一个字符串构成有效字母。<br>初始值，如果num&lt;0返回0，如果len(str(num))为1，则返回1，否则对其进行倒叙遍历从倒数第二个开始，before,after=0,1,递推公式f(r-2) = f(r-1)+g(r-2,r-1)<em>f(r)；<br>before,after=after,after+flag</em>before</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'10'</span>&lt;s[i<span class="number">-2</span>:i]&lt;=<span class="string">'26'</span> <span class="keyword">and</span> s[i<span class="number">-2</span>:i]!=<span class="string">'20'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-2</span>]+ret[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-2</span>:i]==<span class="string">'10'</span> <span class="keyword">or</span> s[i<span class="number">-2</span>:i]==<span class="string">'20'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-2</span>])</span><br><span class="line">                <span class="keyword">elif</span> s[i<span class="number">-1</span>]!=<span class="string">'0'</span>:</span><br><span class="line">                    ret.append(ret[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ret.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret[len(s)]</span><br><span class="line">https://zhuanlan.zhihu.com/p/<span class="number">60238439</span></span><br></pre></td></tr></table></figure>
<h2 id="54-礼物的最大价值"><a href="#54-礼物的最大价值" class="headerlink" title="54. 礼物的最大价值"></a>54. 礼物的最大价值</h2><p>在一个 m * n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<p><strong>解题思路：</strong><br>还是动态规划，maxval = max(left,up)+val[i][j]<br>首先进行边界判断，如果矩阵row和col都&lt;=0，return 0<br>之后建立dp矩阵存储上一次的值，对row和col进行遍历，利用递推公式将dp进行填充，需要考虑left或者up是否存在(对index判断)，并对dp当前值进行更新，注意left和up要初始化为0<br>最后返回最后一个值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bonus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMost</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(board)&lt;=<span class="number">0</span> <span class="keyword">or</span> len(board[<span class="number">0</span>])&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        row,col=len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(col)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                up,left=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    up = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    left = dp[i][j<span class="number">-1</span>]</span><br><span class="line">                dp[i][j] = max(up,left)+board[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="55-丑数"><a href="#55-丑数" class="headerlink" title="55. 丑数"></a>55. 丑数</h3><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<p><strong>解题思路：</strong><br>对于index&lt;7的直接返回index，之后初始化t2,t3,t5,对应list中的321，之后for循环直到n，向list不断加min(alist[t2]<em>2,alist[t3]</em>3,alist[t5]<em>5)即可<br>更新t2/t3/t5，分别都使用while循环，例如alist[t2]</em>2&lt;=alist[-1], t2+=1<br>最后返回alist[-1]即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        丑数是由235组成的，如果顺序排列好，新的丑数为之前所有丑数*2、3、5之后大于当前最大丑数的最小的值，</span></span><br><span class="line"><span class="string">        但因为是排好序的，只需要确定T2，T3，T5的index这个index之前的数成2，3，5都小于当前最大丑数，只要更新这个index即可</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        alist = range(<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        t2,t3,t5=<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>,index):</span><br><span class="line">            alist.append(min([alist[t2]*<span class="number">2</span>,alist[t3]*<span class="number">3</span>,alist[t5]*<span class="number">5</span>])) <span class="comment"># 添加新丑数</span></span><br><span class="line">            <span class="comment"># 对t2t3t5更新</span></span><br><span class="line">            <span class="keyword">while</span> alist[t2]*<span class="number">2</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> alist[t3]*<span class="number">3</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> alist[t5]*<span class="number">5</span>&lt;=alist[<span class="number">-1</span>]:</span><br><span class="line">                t5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="56-数字在排序数组中出现的次数"><a href="#56-数字在排序数组中出现的次数" class="headerlink" title="56. 数字在排序数组中出现的次数"></a>56. 数字在排序数组中出现的次数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            first = self.getFirstK(data, k , <span class="number">0</span>, len(data) - <span class="number">1</span>)</span><br><span class="line">            last = self.getLastK(data, k, <span class="number">0</span>, len(data) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">-1</span> <span class="keyword">and</span> last &gt; <span class="number">-1</span>:</span><br><span class="line">                num = last - first + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFirstK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        midD = data[mid]</span><br><span class="line">        <span class="keyword">if</span> midD &gt; k:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> midD &lt; k:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>) <span class="keyword">or</span> (mid &gt; <span class="number">0</span> <span class="keyword">and</span> data[mid - <span class="number">1</span>] != k):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.getFirstK(data, k, start, end)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        midD = data[mid]</span><br><span class="line">        <span class="keyword">if</span> midD &gt; k:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> midD &lt; k:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (mid == len(data) - <span class="number">1</span>) <span class="keyword">or</span> (mid &lt; len(data) - <span class="number">1</span> <span class="keyword">and</span> data[mid + <span class="number">1</span>] != k):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.getLastK(data, k, start, end)<span class="comment">#复制粘贴搞错了。。</span></span><br></pre></td></tr></table></figure>
<h2 id="57-二叉查找树的第-K-个结点"><a href="#57-二叉查找树的第-K-个结点" class="headerlink" title="57. 二叉查找树的第 K 个结点"></a>57. 二叉查找树的第 K 个结点</h2><p>利用二叉查找树中序遍历有序的特点。</p>
<p><strong>解题思路</strong><br>二叉树左边&lt;中间&lt;右边，所以使用中序遍历，使用递归，函数要有一个格外的list存结果<br>之后找到第k个元素即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="string">'''中序遍历可以对节点从大到小排'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mid</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            ret.extend(self.mid(root.left)) <span class="comment"># extend是因为返回的是个list</span></span><br><span class="line">        ret.append(root) <span class="comment"># 这里是循环添加的元素</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            ret.extend(self.mid(root.right))</span><br><span class="line">        <span class="keyword">return</span> ret <span class="comment"># 返回的是list</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span>: <span class="comment"># k=0异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        ret = self.mid(pRoot)</span><br><span class="line">        <span class="keyword">if</span> len(ret)&lt;k: <span class="comment"># k异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> ret[k<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#    def mid(self, pRoot):</span></span><br><span class="line"><span class="comment">#        if not pRoot:</span></span><br><span class="line"><span class="comment">#            return []</span></span><br><span class="line"><span class="comment">#        ret = []</span></span><br><span class="line"><span class="comment">#        ret += self.mid(pRoot.left)</span></span><br><span class="line"><span class="comment">#        ret.append(pRoot.val)</span></span><br><span class="line"><span class="comment">#        ret += self.mid(pRoot.right)</span></span><br><span class="line"><span class="comment">#        return ret</span></span><br></pre></td></tr></table></figure>
<h2 id="58-二叉树的深度"><a href="#58-二叉树的深度" class="headerlink" title="58. 二叉树的深度"></a>58. 二叉树的深度</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p><strong>解题思路：</strong><br>递归：一棵树的长度 = 1 (根节点) + max(左子树长度, 右子树长度)<br>所以终止条件如果为空那么久返回0，否则使用递归左节点以及右节点且分别加1，然后判断两者大值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        递归</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.TreeDepth(pRoot.left)+<span class="number">1</span>,self.TreeDepth(pRoot.right)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="59-平衡二叉树"><a href="#59-平衡二叉树" class="headerlink" title="59 平衡二叉树"></a>59 平衡二叉树</h2><p>问题描述：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中的任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>解题思路</strong><br>递归：使用上面的求深度函数，对每个节点的左右子树检查。<br>如果为空返回true，如果左右子树深度差大于1返回false，对左右节点进行递归检查</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        left = self.depth(pRoot.left)</span><br><span class="line">        right = self.depth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> abs(left-right)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">1</span>+self.depth(pRoot.left),<span class="number">1</span>+self.depth(pRoot.right))</span><br></pre></td></tr></table></figure>
<h2 id="60-和为-S-的两个数字"><a href="#60-和为-S-的两个数字" class="headerlink" title="60. 和为 S 的两个数字"></a>60. 和为 S 的两个数字</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<p><strong>解题思路：</strong><br>使用双指针，对于左指针&lt;右指针时while循环，如果对应的数字和为target，返回两个数字，此时肯定成绩最小，否则更新left和right的index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span><span class="params">(self, array, tsum)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        left,right = <span class="number">0</span>, len(array)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            <span class="keyword">if</span> array[left]+array[right]==tsum:</span><br><span class="line">                <span class="keyword">return</span> array[left],array[right]</span><br><span class="line">            <span class="keyword">elif</span> array[left]+array[right]&gt;tsum:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h2 id="61-滑动窗口的最大值"><a href="#61-滑动窗口的最大值" class="headerlink" title="61. 滑动窗口的最大值"></a>61. 滑动窗口的最大值</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<p><strong>解题思路：</strong><br>直接遍历，求最大值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> size==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)-size+<span class="number">1</span>):</span><br><span class="line">            ret.append(max(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="62-扑克牌顺子"><a href="#62-扑克牌顺子" class="headerlink" title="62. 扑克牌顺子"></a>62. 扑克牌顺子</h2><p>五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p>
<p><strong>解题思路：</strong><br>首先统计0的个数，然后对数组排序，从不为0的数开始进行遍历，查看是否相邻数字相等，相等返回false，不相等则cnt-=后-前-1，如果最后cnt&gt;=0，返回false</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers)&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        sortnum = sorted(numbers)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sortnum:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt,len(sortnum)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sortnum[i]==sortnum[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cnt -= sortnum[i+<span class="number">1</span>]-sortnum[i]<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h2><p>可以有一次买入和一次卖出，买入必须在前。求最大收益。 </p>
<p><strong>解题思路：</strong><br>设定当前index之前的最小值(第一个)，和最大收益(初始为0)，对数组进行遍历从第二个开始，确定之前最小值，以及以该节点为结尾的值和之前最大值的max，返回最后的max</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        解题思路：动态规划，f(n) = max(f(n-1), A[n]-min(A[:n-1]))</span></span><br><span class="line"><span class="string">        当前天收入=max(前一天受益，当前天价值-之前所有天最小值)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            maxpre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minpre = prices[<span class="number">0</span>]</span><br><span class="line">            maxpre = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">                maxpre = max(prices[i]-minpre, maxpre)</span><br><span class="line">                minpre = min(minpre, prices[i])</span><br><span class="line">        <span class="keyword">return</span> maxpre</span><br></pre></td></tr></table></figure>
<h2 id="64-圆圈中最后剩下的数"><a href="#64-圆圈中最后剩下的数" class="headerlink" title="64. 圆圈中最后剩下的数"></a>64. 圆圈中最后剩下的数</h2><p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数 …. 这样下去 …. 直到剩下最后一个小朋友，可以不用表演。</p>
<p><strong>解题思路：</strong><br>约瑟夫环，如果n=0时返回-1，如果n=1返回0，之后return (self.xxx(n-1,m)+m)%n<br>环为n,指定数为m，结果等于度为n-1的约瑟夫环+m % n即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (self.xxx(n<span class="number">-1</span>,m)+m)%n</span><br></pre></td></tr></table></figure>
<h2 id="65-n-个骰子的点数"><a href="#65-n-个骰子的点数" class="headerlink" title="65. n 个骰子的点数"></a>65. n 个骰子的点数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把 n 个骰子仍在地上，求点数和为 s 的概率。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">使用动态规划，dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-2</span>]+dp[i<span class="number">-1</span>][j<span class="number">-3</span>]+dp[i<span class="number">-1</span>][j<span class="number">-4</span>]+dp[i<span class="number">-1</span>][j<span class="number">-5</span>]+dp[i<span class="number">-1</span>][j<span class="number">-6</span>]</span><br><span class="line">首先初始化一个矩阵，行是n，列是n*<span class="number">6</span>，值全部为<span class="number">0</span>，然后对于第一行进行初始化，前<span class="number">6</span>个值是<span class="number">1</span></span><br><span class="line">之后使用循环对于<span class="number">1</span>-n来说(<span class="number">1</span>这里代表<span class="number">2</span>)，遍历n~(n+<span class="number">1</span>)*<span class="number">6</span>，动态规划对结果进行填充，最后返回dp[n<span class="number">-1</span>]即可</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/leokingszx/article/details/80794407" target="_blank" rel="noopener">说明</a></p>
<h2 id="66-树中两个节点的最低公共祖先"><a href="#66-树中两个节点的最低公共祖先" class="headerlink" title="66. 树中两个节点的最低公共祖先"></a>66. 树中两个节点的最低公共祖先</h2><p>(1) 二叉查找树<br>解题思路：<br>因为所有节点都不重复，而且按照中序遍历一定是顺序的，所以，首先确定特殊情况，如果root为空返回None，如果root.val&lt;p.val and root.val&lt;q.val，则说明是在右子树，则使用递归(root.right,p,q)<br>如果root.val&gt;p.val and root.val&gt;q.val，则说明是在左子树，则使用递归(root.left,p,q)，否则return root(此时一定不相等)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>(2) 普通二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> p==root <span class="keyword">or</span> q==root: <span class="comment"># 判断特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right =  self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="comment"># 如果左右节点都存在，返回root</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left: <span class="comment"># 否则，如果左节点都存在，返回left</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right: <span class="comment"># 否则，如果右节点都存在，返回right</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<h2 id="67-在排序数组中查找数字"><a href="#67-在排序数组中查找数字" class="headerlink" title="67.在排序数组中查找数字"></a>67.在排序数组中查找数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题描述：统计一个数字在排序数组中出现的次数。如，输入排序数组&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;和数字<span class="number">3</span>，由于<span class="number">3</span>在这个数组中出现了<span class="number">4</span>次，因此输出<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">直接用字典</span><br><span class="line">或者使用二分查找，分别找到头和尾，查头的时候，在k=data[mid]的位置，如果mid是第一位或者如果不是第一位其之前的数不等于k，那么返回mid，否则end为mid<span class="number">-1</span></span><br><span class="line">查尾的时候，在k=data[mid]的位置，如果mid是最后一位或者如果不是最后一位其之后的数不等于k，那么返回mid，否则start为mid+<span class="number">1</span>(start&gt;end返回<span class="number">-1</span>)</span><br><span class="line">之后再使用end-start+<span class="number">1</span>，如果返回<span class="number">-1</span>则直接返回<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="68-数字序列中的某一位数字"><a href="#68-数字序列中的某一位数字" class="headerlink" title="68. 数字序列中的某一位数字"></a>68. 数字序列中的某一位数字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">数字以 <span class="number">0123456789101112131415.</span>.. 的格式序列化到一个字符串中，求这个字符串的第 index 位。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">对于数字进行循环，并且不断累加数字长度，当数字长度大于index的时候输出str(i)[length-n]即可</span><br></pre></td></tr></table></figure>
<h2 id="69-最长不含重复字符的子字符串"><a href="#69-最长不含重复字符的子字符串" class="headerlink" title="69.最长不含重复字符的子字符串"></a>69.最长不含重复字符的子字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题描述：请从字符串中找出一个最长的不包含重复字符串的子字符串，计算该最长子字符串的长度。假设字符串中只包含‘a’~‘z’的字符。例如，在字符串“arabcacfr”中，最长的不含重复字符的子字符串是“acfr”，长度是<span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">动态规划，首先设定三个变量，curmax,totalmax,字母表字典记录上次出现位置(初始<span class="number">-1</span>)</span><br><span class="line">对字符串进行遍历，如果某个字符位置是<span class="number">-1</span>或者字符串位置和上次出现位置之差&gt;cur那么cur+=<span class="number">1</span>，否则cur=两次位置距离差</span><br><span class="line">然后跟totalmax进行比较，进行更新，更新字典。最后返回长度</span><br></pre></td></tr></table></figure>
<h2 id="70-两个链表的第一个公共节点"><a href="#70-两个链表的第一个公共节点" class="headerlink" title="70.两个链表的第一个公共节点"></a>70.两个链表的第一个公共节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">问题描述：输入两个链表，找出它们的第一个公共结点。</span><br><span class="line"></span><br><span class="line">解题思路：</span><br><span class="line">如果<span class="keyword">while</span>循环两个链表不相等的话持续循环，如果<span class="number">1</span>链表到结尾了则让<span class="number">1</span>链表连接到<span class="number">2</span>上否则next，<span class="number">2</span>链表也一样，最后输出共同链表</span><br></pre></td></tr></table></figure>
<h1 id="leetcode习题"><a href="#leetcode习题" class="headerlink" title="leetcode习题"></a>leetcode习题</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<p>给定一个整型数组 nums 和一个目标值 target ，请找出数组中和为 target 的两个整数，并返回这两个数的数组下标。<br>假设：<br>1）每个输入只对应一个答案；<br>2）不允许重复使用数组中的数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">return</span> [adic[v],k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[target-v] = k</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given nums = [0,1,2,2,3,0,4,2], val = 2,<br>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.<br>Note that the order of those five elements can be arbitrary.<br>It doesn’t matter what values are set beyond the returned length.</p>
<p>给定一个数组 nums 和一个值 val ，请在原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>要求：<br>1）原地操作的意思是不允许开辟额外的数组空间，空间复杂度必须为O(1)；<br>2）数组中元素的顺序是可以改变的，也不需要考虑超出新长度后面的元素。</p>
<p><strong>解题思路1：</strong><br>本题难点在于不允许使用额外的数组空间，因此考虑使用两个下标指针 i，j（初始都指向数组头部）：<br>当 nums[j] 等于 val（需移除的元素），忽略当前这个元素，j++；<br>当 nums[j] 不等于 val（需保留的元素），用 nums[j] 的值覆盖 nums[i] 的值，i++，j++。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            <span class="keyword">if</span> nums[start]==val:</span><br><span class="line">                nums[start] = nums[end]</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        nums = nums[:start]</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure></p>
<p><strong>解题思路2：</strong><br>另一种思路仍是采用两个指针，一个从头向后扫，另一个从尾向前扫，遇到和 val 相等的值就和数组尾部的元素交换或覆盖。（假如需要移除的元素很少时，这种思路需要赋值的次数更少）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 保留与val不同的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i!=val:</span><br><span class="line">                nums[count] = i</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        nums = nums[:count] <span class="comment"># 注意这里count其实多加了1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</p>
<p>Example1:<br>Input: [1,3,5,6], 5<br>Output: 2</p>
<p>Example2:<br>Input: [1,3,5,6], 2<br>Output: 1</p>
<p>Example3:<br>Input: [1,3,5,6], 7<br>Output: 4</p>
<p>Example4:<br>Input: [1,3,5,6], 0<br>Output: 0<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p>
<p><strong>解题思路：</strong><br>因为数组是有序的，所以直观的想法是考察nums中相邻元素与target的关系，如果target在相邻元素范围内，进一步判断是否与左边的数相等，进而判断插入或所在位置，当然除此之外还需要考虑target在nums最大最小值之外的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先判断两头</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]&gt;=target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">-1</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment"># 在判断中间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> (target&gt;=nums[i]) <span class="keyword">and</span> (target&lt;=nums[i+<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> target==nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53.Maximum Subarray"></a>53.Maximum Subarray</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p>
<p>Follow up:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>解题思路：</strong><br>利用动态规划思想，我们假设f(n)为末尾下标为n的最优子序列的和，那么f(n-1)即为末尾下标为n-1的最优子序列和，A(n)为nums数组中下标为n的元素，我们来考察三者的关系，即为：f(n)=max( f(n-1)+A(n), A(n) )，解释一下，因为我们之前已经给过定义f(n)是以n为末尾的子序列，那么他只可能有两种情况，要么是f(n-1)所在的子序列加上A(n)作为f(n)，要么就是只有A(n)这一个元素(因为A(n)时一定要存在的)，所以我们只需要判断一下，哪种序列和最大，就保留这个最大值，作为以n为末尾的子序列的最大值。这样我们遍历整个数组，把每个结果存起来，最后比较出最大值，即为整体子序列的最大值(其下标所在位置即为最优子序列末尾下表位置)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = [] <span class="comment"># 存储从0~len(nums)-1为末尾下标的最优子序列值</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                before = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                after = max(before+v,v)</span><br><span class="line">                before = after</span><br><span class="line">            alist.append(before)</span><br><span class="line">        <span class="keyword">return</span> max(alist)</span><br></pre></td></tr></table></figure>
<h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66.Plus One"></a>66.Plus One</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.<br>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.<br>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:<br>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p>
<p>Example 2:<br>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 借助类型转换</span></span><br><span class="line">        before = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            before += str(i)</span><br><span class="line">        after = str(int(before)+<span class="number">1</span>)</span><br><span class="line">        ret = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> after]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>Note:<br>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:<br>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。</p>
<p>说明:<br>初始时， nums1 和 nums2 的元素数量分别为 m 和 n。<br>假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><strong>解题思路：</strong><br>通过双指针进行操作，因为nums1数组长度为m+n且nums1和nums2都是有序的，所以，我们分别把m和n作为nums1和nums2的指针(即指向末尾)，对两个数组遍历，终止条件是其中一个数组下标为0(即只要有一个数组遍历完就结束)，将指针所指的元素进行比较，将较大的数放在num1的末尾，同时较大数所在数组的指针减1，以此类推。最后如果m下标所在数组没有遍历完，则说明剩下的数字都比nums2的最小数字小，nums1数组不应做任何操作，如果nums2所在数组没有遍历完，那么说明nums2剩下的数字都比num1最小值小，此时需要把nums2剩下数字填充到nums1最前面相应位置即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>]&gt;=nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>
<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.Pascal’s Triangle"></a>118.Pascal’s Triangle</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br>Note: In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:<br>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>注意：在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<p><strong>解题思路：</strong><br>官方的图片其实很清楚的解释了原理，即从第三行开始，每一组两边的数都是1，中间的数都是由上一层相邻元素相加获得的，因此如果想要获取当前行数组，只需要上一层数组即可，有点像斐波那契数列的感觉，因为题目要求输出所有行因此需要把每行保存起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,numRows+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">                alist.append([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before = alist[<span class="number">-1</span>]</span><br><span class="line">                after = [<span class="number">1</span>]+[before[j]+before[j+<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]+[<span class="number">1</span>]</span><br><span class="line">                alist.append(after)</span><br><span class="line">            <span class="keyword">print</span> alist</span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121.Best Time to Buy and Sell Stock"></a>121.Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p>
<p>Example1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<p>Example2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。<br>注意你不能在买入股票前卖出股票。</p>
<p><strong>解题思路：</strong><br>动态规划，f(n) = max(f(n-1), A[n]-min(A[:n-1]))<br>当前天收入=max(前一天受益，当前天价值-之前所有天最小值)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_profit = <span class="number">0</span> <span class="comment"># max of f(n)</span></span><br><span class="line">            min_num = prices[<span class="number">0</span>] <span class="comment"># min(A[:n-1])</span></span><br><span class="line">            before = <span class="number">0</span> <span class="comment"># f(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">                cur = prices[i+<span class="number">1</span>] <span class="comment"># A[n]</span></span><br><span class="line">                after = max(before, cur-min_num) <span class="comment"># f(n)</span></span><br><span class="line">                <span class="keyword">print</span> after</span><br><span class="line">                before = after</span><br><span class="line">                min_num = cur <span class="keyword">if</span> cur&lt;min_num <span class="keyword">else</span> min_num <span class="comment"># update min value</span></span><br><span class="line">                max_profit = before <span class="keyword">if</span> before&gt;max_profit <span class="keyword">else</span> max_profit</span><br><span class="line">            <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p>
<h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119.Pascal’s Triangle II"></a>119.Pascal’s Triangle II</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.<br>Note that the row index starts from 0.</p>
<p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><strong>解题思路:</strong><br>当前层可以通过上一层得到，因此每次保留上一层数即可，得到当前层之后，将当前层替换成before即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> rowIndex==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            before = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(rowIndex - <span class="number">1</span>):</span><br><span class="line">                mid = [before[i]+before[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(before)<span class="number">-1</span>)]</span><br><span class="line">                after = [<span class="number">1</span>] + mid + [<span class="number">1</span>]</span><br><span class="line">                before = after</span><br><span class="line">            <span class="keyword">return</span> before</span><br></pre></td></tr></table></figure></p>
<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p><strong>解题思路：</strong><br>与股票买卖1相比，主要的差别在于可以多次买卖，换句话说也就是“股票买卖1”问题每个数字只能进行一次操作，但是该问题每个数字可以进行多次操作(买与卖)。因此，每天先买入(不会亏)，查看下一天，如果会亏就把当天的卖了，就相当于赚了0元，如果下一天会赚那么就直接卖掉，再买入下一天的股票，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i]&lt;prices[i+<span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure></p>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>Example 1:<br>Given nums = [1,1,2],<br>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.<br>It doesn’t matter what you leave beyond the returned length.<br>Example 2:<br>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>解题思路：</strong><br>通过两个下标index和i完成，index下标从0开始，i从1开始，i是用来遍历数组的，当遇到重复值就跳过，index不增加，如果遇到的是非重复值，index下标加1并对原数组进行修改，将值改为i对应的值，直至遍历完整个数组，最后得到的元素组的前index+1个元素就是不重复元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># index控制不重复数字，i对列表变进行遍历</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">        nums = nums[:index+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="167-Two-Sum-II"><a href="#167-Two-Sum-II" class="headerlink" title="167. Two Sum II"></a>167. Two Sum II</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:<br>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<p><strong>解题思路：</strong><br>跟第一题twosum的思路一样<br>就是遍历整个数组，之后将每一个target与数组元素之差作为字典的key存起来，同时将该元素所在位置下标作为value存起来，在遍历过程中，如果遇到元素与之前建立的字典的key相同，即取出之前的元素对应的下标，同时和当前元素对应下标，输出出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">return</span> [adic[v]+<span class="number">1</span>,k+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[target-v] = k</span><br></pre></td></tr></table></figure>
<h2 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169. 求众数"></a>169. 求众数</h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在众数。<br>示例 1:<br>输入: [3,2,3]<br>输出: 3<br>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
<p><strong>解题思路：</strong><br>没啥说的，主要注意sorted的用法，应该还有更快的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sorted(adic.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p><strong>解题思路：</strong><br>利用list的pop功能(类似于栈)对数据弹出，再从头插入即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>, nums.pop())</span><br></pre></td></tr></table></figure>
<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p>
<p>示例 2:<br>输入: [1,2,3,4]<br>输出: false</p>
<p>示例 3:<br>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p>
<p><strong>解题思路：</strong><br>利用集合不重复特性，根据长度进行比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(set(nums))!=len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219.存在重复元素 II"></a>219.存在重复元素 II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且存在 i 和 j 的差的绝对值不大于k的组合。</p>
<p>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p>
<p>示例 2:<br>输入: nums = [1,0,1,1], k = 1<br>输出: true</p>
<p>示例 3:<br>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p>
<p><strong>解题思路：</strong><br>首先建立一个字典，将所有的元素作为key，元素对应的下标作为value，如果value有重复则直接加入相应key所在的list即可，之后遍历字典，如果字典key对应的value有重复值，计算重复值相邻数字之间的差的绝对值，如果绝对值最小值小于k，则证明存在这样一组下标符合条件，否则返回False(即不存在这样的组合)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125; <span class="comment"># 储存数组值及对应index</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> adic:</span><br><span class="line">                adic[j].append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[j] = [i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">            adic_v = adic[i]</span><br><span class="line">            <span class="keyword">if</span> len(adic_v)&gt;<span class="number">1</span>:</span><br><span class="line">                adic_v_diffmin = min([abs(adic_v[j]-adic_v[j+<span class="number">1</span>]) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(adic_v)<span class="number">-1</span>)]) <span class="comment"># 求相邻index的差的绝对值的最小值</span></span><br><span class="line">                <span class="keyword">if</span> adic_v_diffmin&lt;=k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<p>示例 1:<br>输入: [3,0,1]<br>输出: 2</p>
<p>示例 2:<br>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p>
<p>说明:<br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<p><strong>解题思路：</strong><br>求解0-n所有数的和，然后减去nums的和，差的那个数就是缺失的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        list_len = len(nums)</span><br><span class="line">        total = (<span class="number">1</span>+list_len)*list_len/<span class="number">2</span></span><br><span class="line">        rest = total-sum(nums)</span><br><span class="line">        <span class="keyword">return</span> rest</span><br></pre></td></tr></table></figure>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
<p>说明:<br>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<p><strong>解题思路：</strong><br>使用双指针，其中一个指针real_idx代表非0数字下标，另一个指针iter_idx代表遍历数组的下标，连个下标都为0，从头开始遍历数组，当遇到数组为0的时候real_idx不变，当不为0的时候，交换real_idx所在下标的值以及iter_idx所在下标的值，则相当于把0后置，相对的非0值顺序没有改变，最后返回nums原数组即为所求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        real_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> iter_idx <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[iter_idx]!=<span class="number">0</span>:</span><br><span class="line">                nums[real_idx],nums[iter_idx] = nums[iter_idx],nums[real_idx]</span><br><span class="line">                real_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h2 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a>414. 第三大的数</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<p>示例 1:<br>输入: [3, 2, 1]<br>输出: 1<br>解释: 第三大的数是 1.</p>
<p>示例 2:<br>输入: [1, 2]<br>输出: 2<br>解释: 第三大的数不存在, 所以返回最大的数 2 .</p>
<p>示例 3:<br>输入: [2, 2, 3, 1]<br>输出: 1<br>解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。<br>存在两个值为2的数，它们都排第二。</p>
<p><strong>解题思路：</strong><br>遍历数组，可以借鉴求最大值的思路，只不过扩展一下，求解前三大的数字而已，利用判断语句判断nums当前的值的范围，如果比最大值大就替代，在最大值第二大值之间就替代第二大值，在第二大值及第三大值之间就替代第三大值，否则跳过。有一点需要注意的是赋值的顺序，不能有交叉影响下一个复制表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max1, max2, max3 = float(<span class="string">'-inf'</span>),float(<span class="string">'-inf'</span>),float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> [max1,max2,max3]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;max1:</span><br><span class="line">                max3 = max2 <span class="comment"># 注意顺序</span></span><br><span class="line">                max2 = max1</span><br><span class="line">                max1 = i <span class="comment"># 注意修改的值放最后</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;max2:</span><br><span class="line">                max3 = max2</span><br><span class="line">                max2 = i</span><br><span class="line">            <span class="keyword">elif</span> i&gt;max3:</span><br><span class="line">                max3 = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> max3==float(<span class="string">'-inf'</span>):</span><br><span class="line">            <span class="keyword">return</span> max1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max3</span><br></pre></td></tr></table></figure>
<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。<br>找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:<br>输入:<br>[4,3,2,7,8,2,3,1]<br>输出:<br>[5,6]</p>
<p><strong>解题思路：</strong><br>因为长度和给定数组范围一致，所以可以通过对数组中各元素所代表的下标进行标负，进行元素缺失的确认，遍历完之后剩下的正元素下标即为缺失元素，注意需要使用绝对值，因为有可能出现重复的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            nums[abs(i)<span class="number">-1</span>] = -abs(nums[abs(i)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> [k+<span class="number">1</span> <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> v&gt;<span class="number">0</span> ]</span><br></pre></td></tr></table></figure>
<h2 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a>485. 最大连续1的个数</h2><p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p>示例 1:<br>输入: [1,1,0,1,1,1]<br>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</p>
<p>注意：<br>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。</p>
<p><strong>解题思路：</strong><br>确定nums数组中各个0点的位置，之后进行相邻值求差，得到最大值即为最长1个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index0 = [<span class="number">-1</span>]+[k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> v==<span class="number">0</span>]+[len(nums)]</span><br><span class="line">        length_list = [index0[i+<span class="number">1</span>]-index0[i]<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(index0)<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">return</span> max(length_list)</span><br></pre></td></tr></table></figure>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。</p>
<p>示例 1：<br>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</p>
<p>示例 2：<br>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</p>
<p>示例 3：<br>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</p>
<p>提示：<br>0 ≤ N ≤ 30</p>
<p><strong>解题思路：</strong><br>基于表达式进行推导，每次只保留前两个数，基于这两个数生成新的数，之后对这两个数进行更新，以此类推。<br>f(n+2) = f(n) + f(n+1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> N&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            before = <span class="number">1</span></span><br><span class="line">            after = <span class="number">1</span></span><br><span class="line">            n = <span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> n&lt;=N:</span><br><span class="line">                before, after = after, before+after</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure>
<h2 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a>532. 数组中的K-diff数对</h2><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1:<br>输入: [3, 1, 4, 1, 5], k = 2<br>输出: 2<br>解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。<br>尽管数组中有两个1，但我们只应返回不同的数对的数量。</p>
<p>示例 2:<br>输入:[1, 2, 3, 4, 5], k = 1<br>输出: 4<br>解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</p>
<p>示例 3:<br>输入: [1, 3, 1, 5, 4], k = 0<br>输出: 1<br>解释: 数组中只有一个 0-diff 数对，(1, 1)。</p>
<p>注意:<br>数对 (i, j) 和数对 (j, i) 被算作同一数对。<br>数组的长度不超过10,000。<br>所有输入的整数的范围在 [-1e7, 1e7]。</p>
<p><strong>解题思路:</strong><br>这个题目主要的难度在于对题目的解读，其实根据k分成不同情况即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                adic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[i] = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>: <span class="comment"># 意外情况返回0</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">elif</span> k==<span class="number">0</span>: <span class="comment"># 0-diff只需要统计出现次数大于1的数字即可</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> adic.items():</span><br><span class="line">                <span class="keyword">if</span> v&gt;<span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 其余的只需要查看i-k是否在adic中即可,注意不用绝对只是因为(i,j)(j,i)算1对</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                <span class="keyword">if</span> i-k <span class="keyword">in</span> adic:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h2 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a>561. 数组拆分 I</h2><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:<br>输入: [1,4,3,2]<br>输出: 4<br>解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p>
<p>提示:<br>n 是正整数,范围在 [1, 10000].<br>数组中的元素范围在 [-10000, 10000].</p>
<p><strong>解题思路：</strong><br>要是想两对两对数的最小值的和最大，其实从最大的两对数进行推演，如果在nums上找到两个数组成的对，使得这个对的最小值最大，那么一定是整个数组中的最大数以及第二大数，之后再确定剩下数组中数对最小值最大，那么其实就是整个数组的第三大数以及第四大数组成的数对，以此类推，总结起来其实就是对数组排序，同时找到下标为偶数的数字的和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrayPairSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = sum([v <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(sorted(nums)) <span class="keyword">if</span> k%<span class="number">2</span>==<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p><strong>解题思路：</strong><br>链表结构进行解题(没掌握好)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = ret</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val&gt;=l2.val:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            cur = cur.next <span class="comment"># 记得向后推</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next=l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            cur.next=l2</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>示例 2:<br>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<p><strong>解题思路:</strong><br>链表结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        ret = head <span class="comment"># 注意python变量名都是引用!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.next:</span><br><span class="line">            <span class="keyword">while</span> head.next <span class="keyword">and</span> head.val==head.next.val:</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a>566. 重塑矩阵</h2><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1:<br>输入:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br>输出:<br>[[1,2,3,4]]<br>解释:<br>行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</p>
<p>示例 2:<br>输入:<br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br>输出:<br>[[1,2],<br> [3,4]]<br>解释:<br>没有办法将 2 <em> 2 矩阵转化为 2 </em> 4 矩阵。 所以输出原矩阵。</p>
<p>注意：<br>给定矩阵的宽和高范围在 [1, 100]。<br>给定的 r 和 c 都是正数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span><span class="params">(self, nums, r, c)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[List[int]]</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> r*c!=len(nums)*len(nums[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = []</span><br><span class="line">            new = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                    tmp.append(j)</span><br><span class="line">                    <span class="keyword">if</span> len(tmp)==c:</span><br><span class="line">                        new.append(tmp)</span><br><span class="line">                        tmp = []</span><br><span class="line">            <span class="keyword">return</span> new</span><br></pre></td></tr></table></figure>
<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>你找到的子数组应是最短的，请输出它的长度。</p>
<p>示例 1:<br>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p>
<p>说明 :<br>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p>
<p><strong>解题思路</strong><br>就是排序前后数据进行比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(sorted(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[k]!=v:</span><br><span class="line">                alist.append(k)</span><br><span class="line">        <span class="keyword">if</span> len(alist)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(alist) - min(alist) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p><strong>解题思路：</strong><br>利用快慢指针，如果有环快指针一定会在某个时刻与慢指针相遇，否则快指针为空</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> head.next.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow = head.next</span><br><span class="line">        fast = head.next.next</span><br><span class="line">        <span class="keyword">while</span> slow!=fast <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>注意：<br>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<p><strong>解题思路：</strong><br>判断两个链表长度，将较长的链表移动到与短链表相差的长度位置，进行遍历，如果两个链表相同返回当前链表，否则返回None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1,l2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        l1node,l2node = headA,headB</span><br><span class="line">        <span class="keyword">while</span> l1node:</span><br><span class="line">            l1 += <span class="number">1</span></span><br><span class="line">            l1node = l1node.next</span><br><span class="line">        <span class="keyword">while</span> l2node:</span><br><span class="line">            l2 += <span class="number">1</span></span><br><span class="line">            l2node = l2node.next</span><br><span class="line">        <span class="keyword">if</span> l1&gt;l2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l1-l2):</span><br><span class="line">                headA = headA.next</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l2-l1):</span><br><span class="line">                headB = headB.next</span><br><span class="line">        <span class="keyword">while</span> headA!=headB:</span><br><span class="line">            headA,headB = headA.next,headB.next </span><br><span class="line">        <span class="keyword">if</span> headA:</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:<br>输入: flowerbed = [1,0,0,0,1], n = 1<br>输出: True</p>
<p>示例 2:<br>输入: flowerbed = [1,0,0,0,1], n = 2<br>输出: False</p>
<p>注意:<br>数组内已种好的花不会违反种植规则。<br>输入的数组长度范围为 [1, 20000]。<br>n 是非负整数，且不会超过输入数组的大小。<br>在真实的面试中遇到过这道题？</p>
<p><strong>解题思路：</strong><br>头尾加一个0，然后找三个连续的0出现的次数大于n即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type flowerbed: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_list = [<span class="number">0</span>]+flowerbed+[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(new_list)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> new_list[i]==<span class="number">0</span> <span class="keyword">and</span> new_list[i<span class="number">-1</span>]==<span class="number">0</span> <span class="keyword">and</span> new_list[i+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                new_list[i] = <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=n</span><br></pre></td></tr></table></figure>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p><strong>解题思路：</strong><br>转化为数组，再重新构建链表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val != val:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>反转一个单链表。</p>
<p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p><strong>解题思路：</strong><br>将链表转化成list，在进行反转</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val==<span class="number">0</span>:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            <span class="keyword">if</span> head.val:</span><br><span class="line">                alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist[::<span class="number">-1</span>]:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:<br>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2:<br>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<p><strong>解题思路：</strong><br>典型的动态规划问题，dp[i] = max(dp[i-1], dp[i-2]+a[i])<br>所以只需要保存前两天的记录就能根据当天的记录计算当前最大收益，初始的两天算0即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        before = <span class="number">0</span></span><br><span class="line">        after = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            before,after = after, max(before+i, after)</span><br><span class="line">        <span class="keyword">return</span> after</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<p>示例:<br>输入: 19<br>输出: true<br>解释:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p><strong>解题思路：</strong><br>对不是快乐数的进行储存判断(有可能重复)，对是的返回true</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> alist:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist.append(n)</span><br><span class="line">            tmp = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> str(n):</span><br><span class="line">                tmp += int(i)**<span class="number">2</span></span><br><span class="line">            n = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p>统计所有小于非负整数 n 的质数的数量。</p>
<p>示例:<br>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p>
<p><strong>解题思路：</strong><br>对于每个位置赋1，如果是质数就就对其平方之后的所有间隔为本数的赋值为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prime = [<span class="number">1</span>]*n</span><br><span class="line">        prime[:<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prime[i]==<span class="number">1</span>:</span><br><span class="line">                prime[i*i:n:i]=[<span class="number">0</span>]*len(prime[i*i:n:i])</span><br><span class="line">        <span class="keyword">return</span> sum(prime)</span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p>示例 1:<br>输入: 1-&gt;2<br>输出: false</p>
<p>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>
<p><strong>解题思路：</strong><br>转成list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> alist==alist[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p>示例 1:<br>输入: [1,2,3]<br>输出: 6</p>
<p>示例 2:<br>输入: [1,2,3,4]<br>输出: 24</p>
<p><strong>解题思路：</strong><br>最大的三个数乘积以及最小两个数乘积与最大数乘积比较选择大的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sort_list = sorted(nums)</span><br><span class="line">        <span class="keyword">return</span> max(sort_list[<span class="number">-1</span>]*sort_list[<span class="number">-2</span>]*sort_list[<span class="number">-3</span>], sort_list[<span class="number">0</span>]*sort_list[<span class="number">1</span>]*sort_list[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>示例 1:<br>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>示例 2:<br>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明:<br>链表至少包含两个节点。<br>链表中所有节点的值都是唯一的。<br>给定的节点为非末尾节点并且一定是链表中的一个有效节点。<br>不要从你的函数中返回任何结果。</p>
<p><strong>解题思路：</strong><br>注意只有当前要删节点的访问权限，所以直接删除就好。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure>
<h2 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>示例 1:<br>输入: [1,12,-5,-6,50,3], k = 4<br>输出: 12.75<br>解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p>
<p>注意:<br>1 &lt;= k &lt;= n &lt;= 30,000。<br>所给数据范围 [-10,000，10,000]。</p>
<p><strong>解题思路：</strong><br>计算的时候需要主要不能重复计算否则超时，可以使用减去头加上尾的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                mean_val = sum(nums[i:i+k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mean_val = mean_val-nums[i<span class="number">-1</span>]+nums[i+k<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> mean_val&gt;ret:</span><br><span class="line">                ret = mean_val</span><br><span class="line">        <span class="keyword">return</span> ret*<span class="number">1.0</span>/k</span><br></pre></td></tr></table></figure>
<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：<br>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
<p>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：<br>给定链表的结点数介于 1 和 100 之间。</p>
<p><strong>解题思路：</strong><br>借助列表即可完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            alist.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp = ret</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alist[len(alist)/<span class="number">2</span>:]:</span><br><span class="line">            tmp.next = ListNode(i)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>
<h2 id="876"><a href="#876" class="headerlink" title="876"></a>876</h2><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:<br>输入: “III”<br>输出: 3</p>
<p>示例 2:<br>输入: “IV”<br>输出: 4</p>
<p>示例 3:<br>输入: “IX”<br>输出: 9</p>
<p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p>
<p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p><strong>解题思路：</strong><br>从后向前遍历，如果小于前一个就加，如果大于前一个就减</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>,&#125;</span><br><span class="line">        revs = s[::<span class="number">-1</span>]</span><br><span class="line">        numsum = adic[revs[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(revs[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">if</span> adic[v]&gt;=adic[revs[i]]:</span><br><span class="line">                numsum += adic[v]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numsum -= adic[v]</span><br><span class="line">        <span class="keyword">return</span> numsum</span><br></pre></td></tr></table></figure>
<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
<p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p><strong>解题思路：</strong><br>注意这里”前缀”这个描述，之后利用python的转置即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(i))==<span class="number">1</span>:</span><br><span class="line">                ret += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="661-图片平滑器"><a href="#661-图片平滑器" class="headerlink" title="661. 图片平滑器"></a>661. 图片平滑器</h2><p>包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p>
<p>示例 1:<br>输入:<br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br>输出:<br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]</p>
<p>解释:<br>对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0<br>对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0<br>对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0</p>
<p>注意:<br>给定矩阵中的整数范围为 [0, 255]。<br>矩阵的长和宽的范围均为 [1, 150]。</p>
<p><strong>解题思路：</strong><br>就是很简单的遍历，没啥特点，先确定左上角位置坐标以及右下角坐标，然后注意和数组的边界的关系，求均值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">imageSmoother</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row = len(M)</span><br><span class="line">        col = len(M[<span class="number">0</span>])</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                left = [max(i<span class="number">-1</span>,<span class="number">0</span>),max(j<span class="number">-1</span>,<span class="number">0</span>)] <span class="comment"># 左上角坐标</span></span><br><span class="line">                right = [min(i+<span class="number">1</span>,row<span class="number">-1</span>),min(j+<span class="number">1</span>,col<span class="number">-1</span>)] <span class="comment"># 右下角坐标</span></span><br><span class="line">                sum_val = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 遍历需要平滑位置的数值</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> range(left[<span class="number">0</span>],right[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> q <span class="keyword">in</span> range(left[<span class="number">1</span>],right[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># print p,q</span></span><br><span class="line">                        sum_val += M[p][q]</span><br><span class="line">                <span class="comment"># 根据窗口的形状求均值</span></span><br><span class="line">                avg_val = sum_val/((right[<span class="number">0</span>]+<span class="number">1</span>-left[<span class="number">0</span>])*(right[<span class="number">1</span>]+<span class="number">1</span>-left[<span class="number">1</span>]))</span><br><span class="line">                tmp.append(avg_val)</span><br><span class="line">            ret.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:<br>输入: “()”<br>输出: true</p>
<p>示例 2:<br>输入: “()[]{}”<br>输出: true</p>
<p>示例 3:<br>输入: “(]”<br>输出: false</p>
<p>示例 4:<br>输入: “([)]”<br>输出: false</p>
<p>示例 5:<br>输入: “{[]}”<br>输出: true</p>
<p><strong>解题思路:</strong><br>利用栈进行操作，如果是左边的括号就压进去，右边的就弹出，判断最后是否为空即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic = &#123;<span class="string">'('</span>:<span class="string">')'</span>, <span class="string">'['</span>:<span class="string">']'</span>, <span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        alist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic:</span><br><span class="line">                alist.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> alist) <span class="keyword">or</span> adic[alist.pop()]!=i:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> alist:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>##28. 实现strStr()</p>
<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
<p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<p><strong>解题思路：</strong><br>直接判断就可以了，没什么技巧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lenN = len(needle)</span><br><span class="line">        lenH = len(haystack)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenH-lenN+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+lenN]==needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h2><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。<br>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p>
<p>示例 1:<br>输入: [4,2,3]<br>输出: True<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</p>
<p>示例 2:<br>输入: [4,2,1]<br>输出: False<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<br>说明:  n 的范围为 [1, 10,000]。</p>
<p><strong>解题思路：</strong><br>其实就是遇到nums[i]&gt;nums[i+1]时，修改nums[i]还是nums[i+1]，如果在头上修改nums[i]，再根据i-1，i+1判断修改哪个值，i-1&gt;i+1时修改i+1(不能保证i+1不变所以只能修改这个元素)，否则修改i-1保持i+1不变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                    nums[i] = nums[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[i<span class="number">-1</span>]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                        nums[i+<span class="number">1</span>] = nums[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        nums[i] = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cnt&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h2><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>
</ol>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p>示例 1:<br>输入: 1<br>输出: “1”</p>
<p>示例 2:<br>输入: 4<br>输出: “1211”</p>
<p><strong>解题思路：</strong><br>只要保留上一次的值就可以长生出当前值，需要有几个变量记录，i当前正整数，val，cnt使用来统计数字的值以及个数的(转化成字符串统计)，strNum当前的报数值。说白了这道题就是一个统计数字的题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        pre = <span class="string">'1'</span> <span class="comment"># 用来记录之前时刻的数字，用来推断下一个数字</span></span><br><span class="line">        i = <span class="number">1</span> <span class="comment"># 当前数字值</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            val = pre[<span class="number">0</span>] <span class="comment"># 当前的值</span></span><br><span class="line">            cnt = <span class="number">0</span> <span class="comment"># 当前值的个数</span></span><br><span class="line">            strNum = <span class="string">''</span> <span class="comment"># 产生出来的数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> pre:</span><br><span class="line">                <span class="keyword">if</span> j==val:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    strNum += str(cnt)+val <span class="comment"># 拼接</span></span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">                    val = j</span><br><span class="line">            strNum += str(cnt)+val</span><br><span class="line">            pre = strNum</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p>示例:<br>输入: “Hello World”<br>输出: 5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(s.strip().split(<span class="string">' '</span>)[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 3<br>解释: 最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 </p>
<p>示例 2:<br>输入: [2,2,2,2,2]<br>输出: 1<br>解释: 最长连续递增序列是 [2], 长度为1。<br>注意：数组长度不会超过10000。</p>
<p><strong>解题思路：</strong><br>首先肯定是要设置滑动窗口的，比较nums[i]和nums[i+1]的值的大小，同时设置两个变量本别记录当前最大子序列长度，和全局最大子序列长度，每次先判断是否nums[i]&lt;nums[i+1]，如果为真，当前的长度+1也就是tmp+1，同时跟全剧最长子序列比较如果大于全局就更新，如果nums[i]&gt;=nums[i+1]，则重置当前子序列长度即可。注意序列为空的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tmp = <span class="number">1</span> <span class="comment"># 存储当前的升序值</span></span><br><span class="line">        ret = <span class="number">1</span> <span class="comment"># 储存最大的升序值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                tmp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> tmp&gt;ret:</span><br><span class="line">                ret = tmp</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。<br>输入为非空字符串且只包含数字 1 和 0。</p>
<p>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p>示例 2:<br>输入: a = “1010”, b = “1011”<br>输出: “10101”</p>
<p><strong>解题思路：</strong><br>bin十进制转二进制，int将字符串转化为十进制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bin(int(a,<span class="number">2</span>)+int(b,<span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true</p>
<p>示例 2:<br>输入: “race a car”<br>输出: false</p>
<p><strong>解题思路：</strong><br>注意isalnum()的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        tmp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i.isalnum():</span><br><span class="line">                tmp += i.lower()</span><br><span class="line">        <span class="keyword">return</span> tmp==tmp[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a>697. 数组的度</h2><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。<br>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
<p>示例 1:<br>输入: [1, 2, 2, 3, 1]<br>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>最短连续子数组[2, 2]的长度为2，所以返回2.</p>
<p>示例 2:<br>输入: [1,2,2,3,1,4,2]<br>输出: 6</p>
<p>注意:<br>nums.length 在1到50,000区间范围内。<br>nums[i] 是一个在0到49,999范围内的整数。</p>
<p><strong>解题思路：</strong><br>利用字典进行数值个数的统计，并针对出现次数最多的数值确定初始以及末尾对应的index，通过index相减获得对应的最短子序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findShortestSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 对每个值的数量，起始index终止index进行统计</span></span><br><span class="line">        adic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> adic:</span><br><span class="line">                adic[v][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                adic[v][<span class="number">2</span>] = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic[v] = [<span class="number">1</span>,k,<span class="number">-1</span>]</span><br><span class="line">        max_cnt = max(zip(*adic.values())[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 最大频数如果是1直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> max_cnt==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 确定最大频数并找到最短子序列长度</span></span><br><span class="line">        min_len = float(<span class="string">'Inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> adic.items():</span><br><span class="line">            <span class="keyword">if</span> v[<span class="number">0</span>]==max_cnt:</span><br><span class="line">                len_tmp = v[<span class="number">2</span>]-v[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> len_tmp&lt;min_len:</span><br><span class="line">                    min_len = len_tmp</span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>
<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<p><strong>解题思路：</strong><br>根据python指针的特性，使用双指针，一个头一个尾，调换数值顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: List[str]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j = <span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            s[i],s[j] = s[j],s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p>示例 1:<br>输入: “hello”<br>输出: “holle”</p>
<p>示例 2:<br>输入: “leetcode”<br>输出: “leotcede”<br>说明:<br>元音字母不包含字母”y”。</p>
<p><strong>解题思路：</strong><br>其实跟反转字符串是一个套路，双指针即可，唯一需要注意的是需要对元音字母进行判断,注意转化成list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j=<span class="number">0</span>,len(s)<span class="number">-1</span></span><br><span class="line">        s_list = list(s)</span><br><span class="line">        alp = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>] <span class="comment"># 注意大写</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="keyword">if</span> s_list[i] <span class="keyword">in</span> alp:</span><br><span class="line">                <span class="keyword">if</span> s_list[j] <span class="keyword">in</span> alp:</span><br><span class="line">                    s_list[i],s_list[j] = s_list[j],s_list[i]</span><br><span class="line">                    i += <span class="number">1</span> <span class="comment"># 记得换位置啊</span></span><br><span class="line">                    j -= <span class="number">1</span> <span class="comment"># 记得换位置啊</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s_list)</span><br></pre></td></tr></table></figure>
<h2 id="717-1比特与2比特字符"><a href="#717-1比特与2比特字符" class="headerlink" title="717. 1比特与2比特字符"></a>717. 1比特与2比特字符</h2><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。<br>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p>
<p>示例 1:<br>输入:<br>bits = [1, 0, 0]<br>输出: True<br>解释:<br>唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</p>
<p>示例 2:<br>输入:<br>bits = [1, 1, 1, 0]<br>输出: False<br>解释:<br>唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</p>
<p><strong>解题思路：</strong><br>因为list只由0，10/11组成，观察特点，10/11都是以1开头，0是以0开头，因此正向遍历，遇到1跳两个格，因为只能在10/11中且长度为2，遇到0则跳一个格，因为0长度只能是1，最后看指针所指位置，如果是最后一次指针加了2那么说明不是以单个0结尾，否则就是以单个0结尾的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOneBitCharacter</span><span class="params">(self, bits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(bits):</span><br><span class="line">            <span class="keyword">if</span> bits[i]==<span class="number">1</span>:</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                ret = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                ret = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</p>
<p>注意：<br>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<p><strong>解题思路:</strong><br>这个题的意思是：你要从magazine里面找字母，ransomNote中的每个字母都包含在magazine里面，且个数要小于magazine这个里面的个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote, magazine)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ransomNote: str</span></span><br><span class="line"><span class="string">        :type magazine: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adic1 = &#123;&#125;;adic2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic1:</span><br><span class="line">                adic1[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic1[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> adic2:</span><br><span class="line">                adic2[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                adic2[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> adic1.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> adic2 <span class="keyword">and</span> v&lt;=adic2[k]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>案例:<br>s = “leetcode”<br>返回 0.</p>
<p>s = “loveleetcode”,<br>返回 2.</p>
<p><strong>解题思路</strong><br>利用两个list，一个存储uniq字符，一个存储dup字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        uniq = []</span><br><span class="line">        dup = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> uniq:</span><br><span class="line">                uniq.remove(i)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dup:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dup.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dup:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uniq.append(i)</span><br><span class="line">        <span class="keyword">if</span> uniq:</span><br><span class="line">            <span class="keyword">return</span> s.index(uniq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a>724. 寻找数组的中心索引</h2><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。<br>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p>示例 1:<br>输入:<br>nums = [1, 7, 3, 6, 5, 6]<br>输出: 3<br>解释:<br>索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。<br>同时, 3 也是第一个符合要求的中心索引。</p>
<p>示例 2:<br>输入:<br>nums = [1, 2, 3]<br>输出: -1<br>解释:<br>数组中不存在满足此条件的中心索引。<br>说明:</p>
<p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p>
<p><strong>解题思路：</strong><br>先对list求和，之后对list进行遍历，每次遍历都对前半部分进行累加，并通过总和减去前半部分以及当前遍历值求解后半部分值，进行比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pivotIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        sum_val = sum(nums)</span><br><span class="line">        before = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> before==sum_val-before-v:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            before = before+v</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h2 id="…"><a href="#…" class="headerlink" title="…."></a>….</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        三数之和的解题思路：</span></span><br><span class="line"><span class="string">        首先对数组进行排序，之后对数字进行遍历，在遍历过程中如果是第一个或者当前的数字与之前的不相等进行判断，start和end分别是下一节点以及最后节点</span></span><br><span class="line"><span class="string">        start&lt;end进行while循环，如果两个游标以及当前数字之和为0，添加结果，同时两个游标同时更新，下一步跳过相同的</span></span><br><span class="line"><span class="string">        如果不相等的话要么跟新左游标要么右游标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        ret = []<span class="comment"># 记录结果</span></span><br><span class="line">        nums = sorted(nums) <span class="comment"># 一定要排序</span></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            start,end = i+<span class="number">1</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> nums[i]&gt;nums[i<span class="number">-1</span>]:<span class="comment"># 跳过相同的</span></span><br><span class="line">                <span class="keyword">while</span> start&lt;end:</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[start]+nums[end]==<span class="number">0</span>:</span><br><span class="line">                        ret.append([nums[i],nums[start],nums[end]])</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[start]==nums[start<span class="number">-1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            start += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end+<span class="number">1</span>]:<span class="comment">#跳过相同的</span></span><br><span class="line">                            end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i]+nums[start]+nums[end]&gt;<span class="number">0</span>:</span><br><span class="line">                        end -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h2><p><strong>解题思路：</strong><br>如果序列长度大于1可以对序列进行拆分，排序，再进行合并<br>当拆分为只有单个元素的list之后默认就是排好序的<br>这样每次迭代的子部分相当于排好序的list，只需对两个排好序的list进行merge即可<br>将这种思想进行扩展即可<br><a href="https://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="noopener">归并排序思路</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		mid = len(nums)/<span class="number">2</span></span><br><span class="line">		left = mergesort(nums[:mid])</span><br><span class="line">		right = mergesort(nums[mid:])</span><br><span class="line">		<span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">	ret = []</span><br><span class="line">	i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i&lt;len(left) <span class="keyword">and</span> j&lt;len(right):</span><br><span class="line">		<span class="keyword">if</span> left[i]&lt;=right[j]:</span><br><span class="line">			ret.append(left[i])</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			ret.append(right[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i==len(left):</span><br><span class="line">		ret += right[j:]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		ret += left[i:]</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%mergeSort(test)</span><br></pre></td></tr></table></figure>
<h2 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2.桶排序"></a>2.桶排序</h2><p><strong>解题思路:</strong><br>桶排序是一种计数排序，也就是说，建立最小值到最大值之间的list，<br>计算每个数字在nums中出现的次数，填写在在相应list的位置，<br>最后遍历整个list输出值不为出代表的nums中的数字即可<br>(不适用于范围太大元素个数少的list)<br><a href="https://www.cnblogs.com/king-ding/p/bucketsort.html" target="_blank" rel="noopener">桶排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	max_num = max(nums)</span><br><span class="line">	min_num = min(nums)</span><br><span class="line">	init_list = [<span class="number">0</span>]*(max_num-min_num+<span class="number">1</span>)</span><br><span class="line">	ret_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">		init_list[i-min_num] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(init_list):</span><br><span class="line">		<span class="keyword">if</span> v!=<span class="number">0</span>:</span><br><span class="line">			ret_list += [k+min_num]*v</span><br><span class="line">	<span class="keyword">return</span> ret_list</span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h2><p><strong>解题思路:</strong><br>选择第一个位置作为一个标定，之后遍历后面的list，找出比这个数大的，放在右边，<br>找出比这个数小的放在左边，进一步迭代排序左边和右边子list，即可获得排序后的结果<br>(有一点二分的思想)<br><a href="http://yshblog.com/blog/170" target="_blank" rel="noopener">快排思路1</a><br><a href="https://blog.csdn.net/razor87/article/details/71155518" target="_blank" rel="noopener">快排思路2</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		left = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=nums[<span class="number">0</span>]]</span><br><span class="line">		right = [i <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;nums[<span class="number">0</span>]]</span><br><span class="line">		ret = quickSort(left)+[nums[<span class="number">0</span>]]+quickSort(right)</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">test = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%bucketSort(test)</span><br></pre></td></tr></table></figure></p>
<h2 id="4-基数排序"><a href="#4-基数排序" class="headerlink" title="4.基数排序"></a>4.基数排序</h2><p><strong>解题思路:</strong><br>基数排序主要是这样实现的，首先找出所有数字的最大值，通过最大值得到最大数的位数，<br>建立一个空值的list，分别代表0-9十个数。然后通过对nums中的元素的个位数进行提取，进而排序，<br>放到相应的空值list的位置处，之后将遍历完的数组进行合并，作为一次排序的结果，以此类推，<br>直到所有位数都排完，即可得到排序后的数组<br><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">基数排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jishuSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">	k = int(math.ceil(math.log(max(nums), <span class="number">10</span>)))</span><br><span class="line">	alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">		<span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">			alist[(v/<span class="number">10</span>**i)%<span class="number">10</span>].append(v)</span><br><span class="line">		nums = []</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> alist:</span><br><span class="line">			nums.extend(j)</span><br><span class="line">		alist = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">test = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">123</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%test</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%jishuSort(test)</span><br></pre></td></tr></table></figure></p>
<h2 id="5-二叉树排序"><a href="#5-二叉树排序" class="headerlink" title="5.二叉树排序"></a>5.二叉树排序</h2><p><strong>解题思路：</strong><br>二叉树排序主要有几个步骤，构建节点，通过插值构建二叉树，对构建好的二叉树进行遍历<br><a href="https://blog.csdn.net/Rex_WUST/article/details/83274507" target="_blank" rel="noopener">二叉树排序思路</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">		self.value = value</span><br><span class="line">		self.left = <span class="keyword">None</span></span><br><span class="line">		self.right = <span class="keyword">None</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">leftInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">		self.left = Tree(value)</span><br><span class="line">		<span class="keyword">return</span> self.left</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">rightInsert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">		self.right = Tree(value)</span><br><span class="line">		<span class="keyword">return</span> self.right</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertValue</span><span class="params">(node, value)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> node.value&gt;value:</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			insertValue(node.left, value)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node.leftInsert(value)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			insertValue(node.right, value)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node.rightInsert(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOrder</span><span class="params">(node)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> node.value:</span><br><span class="line">		<span class="keyword">if</span> node.left:</span><br><span class="line">			leftOrder(node.left)</span><br><span class="line">		alist.append(node.show()) <span class="comment"># alist是全局变量</span></span><br><span class="line">		<span class="keyword">if</span> node.right:</span><br><span class="line">			leftOrder(node.right)</span><br><span class="line"></span><br><span class="line">alist = []</span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">root = Tree(nums[<span class="number">0</span>])</span><br><span class="line">tree = root</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">	insertValue(tree, i)</span><br><span class="line">leftOrder(tree)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'list before sort: %s'</span>%nums</span><br><span class="line"><span class="keyword">print</span> <span class="string">'list after sort: %s'</span>%alist</span><br></pre></td></tr></table></figure></p>
<hr>











      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/04/WaterMelonBook/" rel="next" title="葫芦书读书笔记">
                <i class="fa fa-chevron-left"></i> 葫芦书读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpeg"
                alt="WenchaoXiu" />
            
              <p class="site-author-name" itemprop="name">WenchaoXiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#剑指offer"><span class="nav-number">1.</span> <span class="nav-text">剑指offer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-二维数组中的查找"><span class="nav-number">1.1.</span> <span class="nav-text">1. 二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-替换空格"><span class="nav-number">1.2.</span> <span class="nav-text">2. 替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-从尾到头打印链表"><span class="nav-number">1.3.</span> <span class="nav-text">3. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-重建二叉树"><span class="nav-number">1.4.</span> <span class="nav-text">4. 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-用两个栈实现队列"><span class="nav-number">1.5.</span> <span class="nav-text">5. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-旋转数组的最小数字"><span class="nav-number">1.6.</span> <span class="nav-text">6. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-斐波那契数列"><span class="nav-number">1.7.</span> <span class="nav-text">7. 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-跳台阶"><span class="nav-number">1.8.</span> <span class="nav-text">8. 跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-变态跳台阶"><span class="nav-number">1.9.</span> <span class="nav-text">9. 变态跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-矩形覆盖"><span class="nav-number">1.10.</span> <span class="nav-text">10. 矩形覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-二进制中1的个数"><span class="nav-number">1.11.</span> <span class="nav-text">11. 二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-数值的整数次方"><span class="nav-number">1.12.</span> <span class="nav-text">12. 数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-调整数组顺序使奇数位于偶数前面"><span class="nav-number">1.13.</span> <span class="nav-text">13. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-反转链表"><span class="nav-number">1.14.</span> <span class="nav-text">14. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-合并两个排序的链表"><span class="nav-number">1.15.</span> <span class="nav-text">15. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-数组中出现次数超过一半的数字"><span class="nav-number">1.16.</span> <span class="nav-text">16. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-最小的K个数"><span class="nav-number">1.17.</span> <span class="nav-text">17. 最小的K个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-连续子数组的最大和"><span class="nav-number">1.18.</span> <span class="nav-text">18. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-整数中1出现的次数（从1到n整数中1出现的次数）"><span class="nav-number">1.19.</span> <span class="nav-text">19. 整数中1出现的次数（从1到n整数中1出现的次数）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-把数组排成最小的数"><span class="nav-number">1.20.</span> <span class="nav-text">20. 把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-第一个只出现一次的字符"><span class="nav-number">1.21.</span> <span class="nav-text">21. 第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-数组中只出现一次的数字"><span class="nav-number">1.22.</span> <span class="nav-text">22. 数组中只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-和为S的连续正数序列"><span class="nav-number">1.23.</span> <span class="nav-text">23. 和为S的连续正数序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-翻转单词顺序列"><span class="nav-number">1.24.</span> <span class="nav-text">24. 翻转单词顺序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-求1-2-3-…-n"><span class="nav-number">1.25.</span> <span class="nav-text">25. 求1+2+3+…+n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-数组中重复的数字"><span class="nav-number">1.26.</span> <span class="nav-text">26. 数组中重复的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-构建乘积数组"><span class="nav-number">1.27.</span> <span class="nav-text">27. 构建乘积数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-二叉树的下一个结点"><span class="nav-number">1.28.</span> <span class="nav-text">28. 二叉树的下一个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-矩阵中的路径"><span class="nav-number">1.29.</span> <span class="nav-text">29. 矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-机器人的运动范围"><span class="nav-number">1.30.</span> <span class="nav-text">30. 机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#31-剪绳子-leetcode-343-整数拆分"><span class="nav-number">1.30.1.</span> <span class="nav-text">31. 剪绳子(leetcode 343 整数拆分)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-在-O-1-时间内删除链表节点"><span class="nav-number">1.31.</span> <span class="nav-text">32. 在 O(1) 时间内删除链表节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#33-删除链表中重复的结点"><span class="nav-number">1.31.1.</span> <span class="nav-text">33. 删除链表中重复的结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-链表中倒数第-K-个结点"><span class="nav-number">1.32.</span> <span class="nav-text">34. 链表中倒数第 K 个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-链表中环的入口结点"><span class="nav-number">1.33.</span> <span class="nav-text">35. 链表中环的入口结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-树的子结构"><span class="nav-number">1.34.</span> <span class="nav-text">36. 树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-二叉树的镜像"><span class="nav-number">1.35.</span> <span class="nav-text">37. 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-对称的二叉树"><span class="nav-number">1.36.</span> <span class="nav-text">38 对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-顺时针打印矩阵"><span class="nav-number">1.37.</span> <span class="nav-text">39. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-包含-min-函数的栈"><span class="nav-number">1.38.</span> <span class="nav-text">40. 包含 min 函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-栈的压入、弹出序列"><span class="nav-number">1.39.</span> <span class="nav-text">41. 栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-从上往下打印二叉树"><span class="nav-number">1.40.</span> <span class="nav-text">42 从上往下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-把二叉树打印成多行"><span class="nav-number">1.41.</span> <span class="nav-text">43. 把二叉树打印成多行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-按之字形顺序打印二叉树"><span class="nav-number">1.42.</span> <span class="nav-text">44. 按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#45-二叉搜索树的后序遍历序列"><span class="nav-number">1.42.1.</span> <span class="nav-text">45. 二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-二叉树中和为某一值的路径"><span class="nav-number">1.43.</span> <span class="nav-text">46. 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-复杂链表的复制"><span class="nav-number">1.44.</span> <span class="nav-text">47. 复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-二叉搜索树与双向链表"><span class="nav-number">1.45.</span> <span class="nav-text">48. 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-序列化二叉树"><span class="nav-number">1.46.</span> <span class="nav-text">49. 序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-字符串的排列"><span class="nav-number">1.47.</span> <span class="nav-text">50. 字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-数据流中的中位数"><span class="nav-number">1.48.</span> <span class="nav-text">51. 数据流中的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-字符流中第一个不重复的字符"><span class="nav-number">1.49.</span> <span class="nav-text">52 字符流中第一个不重复的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-把数字翻译成字符串"><span class="nav-number">1.50.</span> <span class="nav-text">53. 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-礼物的最大价值"><span class="nav-number">1.51.</span> <span class="nav-text">54. 礼物的最大价值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#55-丑数"><span class="nav-number">1.51.1.</span> <span class="nav-text">55. 丑数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-数字在排序数组中出现的次数"><span class="nav-number">1.52.</span> <span class="nav-text">56. 数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-二叉查找树的第-K-个结点"><span class="nav-number">1.53.</span> <span class="nav-text">57. 二叉查找树的第 K 个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-二叉树的深度"><span class="nav-number">1.54.</span> <span class="nav-text">58. 二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-平衡二叉树"><span class="nav-number">1.55.</span> <span class="nav-text">59 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-和为-S-的两个数字"><span class="nav-number">1.56.</span> <span class="nav-text">60. 和为 S 的两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-滑动窗口的最大值"><span class="nav-number">1.57.</span> <span class="nav-text">61. 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-扑克牌顺子"><span class="nav-number">1.58.</span> <span class="nav-text">62. 扑克牌顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-股票的最大利润"><span class="nav-number">1.59.</span> <span class="nav-text">63. 股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-圆圈中最后剩下的数"><span class="nav-number">1.60.</span> <span class="nav-text">64. 圆圈中最后剩下的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-n-个骰子的点数"><span class="nav-number">1.61.</span> <span class="nav-text">65. n 个骰子的点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-树中两个节点的最低公共祖先"><span class="nav-number">1.62.</span> <span class="nav-text">66. 树中两个节点的最低公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-在排序数组中查找数字"><span class="nav-number">1.63.</span> <span class="nav-text">67.在排序数组中查找数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-数字序列中的某一位数字"><span class="nav-number">1.64.</span> <span class="nav-text">68. 数字序列中的某一位数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-最长不含重复字符的子字符串"><span class="nav-number">1.65.</span> <span class="nav-text">69.最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-两个链表的第一个公共节点"><span class="nav-number">1.66.</span> <span class="nav-text">70.两个链表的第一个公共节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode习题"><span class="nav-number">2.</span> <span class="nav-text">leetcode习题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">2.1.</span> <span class="nav-text">1. Two Sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">2.2.</span> <span class="nav-text">27. Remove Element</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-Search-Insert-Position"><span class="nav-number">2.3.</span> <span class="nav-text">35. Search Insert Position</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">2.4.</span> <span class="nav-text">53.Maximum Subarray</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-Plus-One"><span class="nav-number">2.5.</span> <span class="nav-text">66.Plus One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-Merge-Sorted-Array"><span class="nav-number">2.6.</span> <span class="nav-text">88. Merge Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-number">2.7.</span> <span class="nav-text">118.Pascal’s Triangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">2.8.</span> <span class="nav-text">121.Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#119-Pascal’s-Triangle-II"><span class="nav-number">2.9.</span> <span class="nav-text">119.Pascal’s Triangle II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-买卖股票的最佳时机-II"><span class="nav-number">2.10.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">2.11.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#167-Two-Sum-II"><span class="nav-number">2.12.</span> <span class="nav-text">167. Two Sum II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-求众数"><span class="nav-number">2.13.</span> <span class="nav-text">169. 求众数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-旋转数组"><span class="nav-number">2.14.</span> <span class="nav-text">189.旋转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-存在重复元素"><span class="nav-number">2.15.</span> <span class="nav-text">217.存在重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-存在重复元素-II"><span class="nav-number">2.16.</span> <span class="nav-text">219.存在重复元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#268-缺失数字"><span class="nav-number">2.17.</span> <span class="nav-text">268. 缺失数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-移动零"><span class="nav-number">2.18.</span> <span class="nav-text">283. 移动零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#414-第三大的数"><span class="nav-number">2.19.</span> <span class="nav-text">414. 第三大的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-number">2.20.</span> <span class="nav-text">448. 找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#485-最大连续1的个数"><span class="nav-number">2.21.</span> <span class="nav-text">485. 最大连续1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#509-斐波那契数"><span class="nav-number">2.22.</span> <span class="nav-text">509. 斐波那契数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#532-数组中的K-diff数对"><span class="nav-number">2.23.</span> <span class="nav-text">532. 数组中的K-diff数对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#561-数组拆分-I"><span class="nav-number">2.24.</span> <span class="nav-text">561. 数组拆分 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-number">2.25.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-删除排序链表中的重复元素"><span class="nav-number">2.26.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#566-重塑矩阵"><span class="nav-number">2.27.</span> <span class="nav-text">566. 重塑矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#581-最短无序连续子数组"><span class="nav-number">2.28.</span> <span class="nav-text">581. 最短无序连续子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-环形链表"><span class="nav-number">2.29.</span> <span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-相交链表"><span class="nav-number">2.30.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#605-种花问题"><span class="nav-number">2.31.</span> <span class="nav-text">605. 种花问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-移除链表元素"><span class="nav-number">2.32.</span> <span class="nav-text">203. 移除链表元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-反转链表"><span class="nav-number">2.33.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">2.34.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#202-快乐数"><span class="nav-number">2.35.</span> <span class="nav-text">202. 快乐数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-计数质数"><span class="nav-number">2.36.</span> <span class="nav-text">204. 计数质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-回文链表"><span class="nav-number">2.37.</span> <span class="nav-text">234. 回文链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#628-三个数的最大乘积"><span class="nav-number">2.38.</span> <span class="nav-text">628. 三个数的最大乘积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#237-删除链表中的节点"><span class="nav-number">2.39.</span> <span class="nav-text">237. 删除链表中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#643-子数组最大平均数-I"><span class="nav-number">2.40.</span> <span class="nav-text">643. 子数组最大平均数 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#876-链表的中间结点"><span class="nav-number">2.41.</span> <span class="nav-text">876. 链表的中间结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#876"><span class="nav-number">2.42.</span> <span class="nav-text">876</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-罗马数字转整数"><span class="nav-number">2.43.</span> <span class="nav-text">13. 罗马数字转整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">2.44.</span> <span class="nav-text">14. 最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#661-图片平滑器"><span class="nav-number">2.45.</span> <span class="nav-text">661. 图片平滑器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">2.46.</span> <span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#665-非递减数列"><span class="nav-number">2.47.</span> <span class="nav-text">665. 非递减数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-报数"><span class="nav-number">2.48.</span> <span class="nav-text">38. 报数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-最后一个单词的长度"><span class="nav-number">2.49.</span> <span class="nav-text">58. 最后一个单词的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#674-最长连续递增序列"><span class="nav-number">2.50.</span> <span class="nav-text">674. 最长连续递增序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-二进制求和"><span class="nav-number">2.51.</span> <span class="nav-text">67. 二进制求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-验证回文串"><span class="nav-number">2.52.</span> <span class="nav-text">125. 验证回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#697-数组的度"><span class="nav-number">2.53.</span> <span class="nav-text">697. 数组的度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-反转字符串"><span class="nav-number">2.54.</span> <span class="nav-text">344. 反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#345-反转字符串中的元音字母"><span class="nav-number">2.55.</span> <span class="nav-text">345. 反转字符串中的元音字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#717-1比特与2比特字符"><span class="nav-number">2.56.</span> <span class="nav-text">717. 1比特与2比特字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#383-赎金信"><span class="nav-number">2.57.</span> <span class="nav-text">383. 赎金信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#387-字符串中的第一个唯一字符"><span class="nav-number">2.58.</span> <span class="nav-text">387. 字符串中的第一个唯一字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#724-寻找数组的中心索引"><span class="nav-number">2.59.</span> <span class="nav-text">724. 寻找数组的中心索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#…"><span class="nav-number">2.60.</span> <span class="nav-text">….</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-number">3.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-归并排序"><span class="nav-number">3.1.</span> <span class="nav-text">1.归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-桶排序"><span class="nav-number">3.2.</span> <span class="nav-text">2.桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-快速排序"><span class="nav-number">3.3.</span> <span class="nav-text">3.快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-基数排序"><span class="nav-number">3.4.</span> <span class="nav-text">4.基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-二叉树排序"><span class="nav-number">3.5.</span> <span class="nav-text">5.二叉树排序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-car"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WenchaoXiu</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
